<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>cpp挖坑&amp;爬坑 | Zheng's Notes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/latest/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/latest/grids-responsive-min.min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/latest/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/latest/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/latest/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/latest/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">cpp挖坑&amp;爬坑</h1><a id="logo" href="/.">Zheng's Notes</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">cpp挖坑&amp;爬坑</h1><div class="post-meta">2021-04-25<span> | </span><span class="category"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 6.7k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 34</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">变长参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">基本定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80"><span class="toc-number">1.2.</span> <span class="toc-text">循环展开</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%86%99%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">错误写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%86%99%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">正确写法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF%E5%B1%95%E5%BC%80"><span class="toc-number">1.3.</span> <span class="toc-text">变参模板展开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#integer_sequence"><span class="toc-number">1.4.</span> <span class="toc-text">integer_sequence</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC"><span class="toc-number">2.</span> <span class="toc-text">右值&amp;左值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">一个问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number"></span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">0.1.</span> <span class="toc-text">获取容器内部类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E9%80%9A%E8%BF%87%E7%B1%BB%E5%9E%8B%E6%89%A7%E8%A1%8C%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">编译期通过类型执行不同的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BF%9D%E5%AD%98%E5%80%BC"><span class="toc-number">2.</span> <span class="toc-text">类型保存值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%A8%A1%E6%9D%BF%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%A5%97%E8%B7%AF"><span class="toc-number">3.</span> <span class="toc-text">结构体模板元函数的套路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%85%83%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E4%B8%8E%E5%8C%B9%E9%85%8D%E7%9A%84%E5%87%A0%E4%B8%AA%E5%A5%97%E8%B7%AF"><span class="toc-number">4.</span> <span class="toc-text">模板元函数编写与匹配的几个套路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tuple%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8Cfold-expressions%E4%B8%AD%E9%87%8D%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91"><span class="toc-number">5.</span> <span class="toc-text">tuple元素进行fold
expressions中重载操作符遇到的坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">变长模板匹配的模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E6%9D%A5%E5%AE%9E%E7%8E%B0%E9%9B%B6%E6%88%90%E6%9C%AC%E6%8A%BD%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">通过隐式转换来实现零成本抽象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number"></span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit"><span class="toc-number">1.</span> <span class="toc-text">explicit</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#share_ptr"><span class="toc-number"></span> <span class="toc-text">share_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-munmap_chunk-invalid-pointer"><span class="toc-number">2.</span> <span class="toc-text">C++: munmap_chunk(): invalid
pointer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#clang%E7%BC%96%E8%AF%91%E4%B8%AD%E6%8A%A5%E9%94%99-no-viable-overloaded"><span class="toc-number"></span> <span class="toc-text">clang编译中报错 no
viable overloaded &#39;&#x3D;&#39;</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ld-unknown-option--z"><span class="toc-number"></span> <span class="toc-text">ld: unknown option: -z</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ld-unknown-corefoundation"><span class="toc-number"></span> <span class="toc-text">ld: unknown CoreFoundation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#m1%E4%B8%8Aeigen%E4%BD%BF%E7%94%A8fp16%E6%97%B6%E7%9A%84%E5%9D%91"><span class="toc-number"></span> <span class="toc-text">m1上eigen使用fp16时的坑</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80regex%E4%BD%BF%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">c语言regex使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E4%B8%8B%E4%BD%BF%E7%94%A8shared-memory%E7%9A%84%E5%9D%91"><span class="toc-number"></span> <span class="toc-text">linux下使用shared memory的坑</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%B0%83%E8%AF%95dotnet-core%E7%9A%84dump%E4%BF%A1%E6%81%AF"><span class="toc-number"></span> <span class="toc-text">命令行调试dotnet
core的dump信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mac%E4%B8%AD%E7%BC%BA%E5%B0%91gmp%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">mac中缺少gmp的问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mac%E4%B8%AD%E7%BC%96%E8%AF%91%E5%87%BA%E7%8E%B0libclang-cpp.dylib%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">mac中编译出现libclang-cpp.dylib的问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mac%E4%B8%ADstdio.h-file-not-found"><span class="toc-number"></span> <span class="toc-text">mac中&#39;stdio.h&#39; file not found</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#relocation-r_riscv_jal-out-of-range"><span class="toc-number"></span> <span class="toc-text">relocation R_RISCV_JAL out
of range</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lldb-%E8%B0%83%E8%AF%95pythonccsharp"><span class="toc-number"></span> <span class="toc-text">lldb 调试python&#x2F;c++&#x2F;csharp</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lldb-%E8%B0%83%E8%AF%95%E9%80%9A%E8%BF%87loadelf%E5%90%AF%E5%8A%A8%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="toc-number"></span> <span class="toc-text">lldb
调试通过loadelf启动的可执行文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E5%88%86%E5%B8%83%E5%BC%8F%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D"><span class="toc-number"></span> <span class="toc-text">linux分布式资源分配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#taskset"><span class="toc-number">1.</span> <span class="toc-text">taskset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#numactl"><span class="toc-number">2.</span> <span class="toc-text">numactl</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mpi%E6%8C%87%E5%AE%9A%E6%8B%93%E6%89%91"><span class="toc-number">3.</span> <span class="toc-text">mpi指定拓扑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#perf%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number"></span> <span class="toc-text">perf常用命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#profile-python"><span class="toc-number"></span> <span class="toc-text">profile python</span></a></div></div><div class="post-content"><p>记录一些遇到的cpp新特性或者实现技巧上的问题。</p>
<span id="more"></span>
<h2 id="变长参数">变长参数</h2>
<p>我记得三年前我还好好学过，现在都忘光了，重新整理一下：</p>
<h3 id="基本定义">基本定义</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取不同长度的可变参数，打印参数的个数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @tparam T</span></span><br><span class="line"><span class="comment"> * @param args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_varg, basic) &#123;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>, vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">3</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> [ RUN      ] test_varg.basic</span></span><br><span class="line"><span class="comment">  0</span></span><br><span class="line"><span class="comment">  1</span></span><br><span class="line"><span class="comment">  2</span></span><br><span class="line"><span class="comment">  4</span></span><br><span class="line"><span class="comment">  [       OK ] test_varg.basic (0 ms)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="循环展开">循环展开</h3>
<h4 id="错误写法">错误写法</h4>
<p>参数匹配的时候需要注意，多个参数输入，最后会匹配到单参数的输入，但是单参数的时候不会调用无参数的终止函数。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot; ;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T v)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T head, Args... args)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(head);</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;remain size : &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;</span><br><span class="line">  <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_varg, recursive_print_error_version) &#123;</span><br><span class="line">  <span class="built_in">print</span>();</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> [ RUN      ] test_varg.recursive_print</span></span><br><span class="line"><span class="comment">  ;</span></span><br><span class="line"><span class="comment">  1 remain size : 1</span></span><br><span class="line"><span class="comment">  2 1 remain size : 2</span></span><br><span class="line"><span class="comment">  2.3 remain size : 1</span></span><br><span class="line"><span class="comment">  3 [       OK ] test_varg.recursive_print (0 ms)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<h4 id="正确写法">正确写法</h4>
<p>所以我们通常用一个无参的函数来终止，在多参数的函数中调用单个参数的处理方式。下面的例子就展示了正确的<code>log</code>函数以及一个从任意<code>base</code>累加的函数。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ic</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot; ; &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ic</span><span class="params">(T head, Args... args)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; head &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">ic</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (T)(<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function">T <span class="title">sums</span><span class="params">(T v, Ts... vs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v + <span class="built_in">sums</span>&lt;T&gt;(vs...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_varg, recursive_print_right_version) &#123;</span><br><span class="line">  <span class="built_in">ic</span>(<span class="built_in">sums</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">  <span class="built_in">ic</span>(<span class="built_in">sums</span>(<span class="number">1</span>, <span class="number">2.3</span>, <span class="number">3.5</span>));</span><br><span class="line">  <span class="built_in">ic</span>(<span class="built_in">sums</span>(<span class="number">2.3</span>, <span class="number">1</span>, <span class="number">3.5</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[ RUN      ] test_varg.recursive_print_right_version</span></span><br><span class="line"><span class="comment">1  ; </span></span><br><span class="line"><span class="comment">4  ; </span></span><br><span class="line"><span class="comment">4.8  ; </span></span><br><span class="line"><span class="comment">[       OK ] test_varg.recursive_print_right_version (0 ms)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h3 id="变参模板展开">变参模板展开</h3>
<p>这里利用c++17中的特性方便的展开并对参数进行处理。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">toint</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>)t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toints</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="built_in">toint</span>(args)...&#125;;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用if constexpr编译期间即构造出对应的输出方式。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print2</span><span class="params">(Head head, Args... args)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; head;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) &gt; <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; , &quot;</span>;</span><br><span class="line">    <span class="built_in">print2</span>(args...);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; ; &quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_varg, expand_right_version) &#123;</span><br><span class="line">  <span class="keyword">auto</span> arr = <span class="built_in">toints</span>(<span class="number">1.2</span>, <span class="number">2.4</span>, <span class="number">3.6</span>, <span class="number">4.7</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123; <span class="built_in">ic</span>(arr[i]); &#125;</span><br><span class="line">  <span class="keyword">auto</span> arr2 = <span class="built_in">countargs</span>(<span class="number">1.2</span>, <span class="number">2.4</span>, <span class="number">3.6</span>, <span class="number">4.7</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; arr2.<span class="built_in">size</span>(); i++) &#123; <span class="built_in">ic</span>(arr2[i]); &#125;</span><br><span class="line">  <span class="built_in">print2</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;word&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
我们可以利用一个函数对每个参数进行操作，并且结合逗号表达式可以做一些别的事情。
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ RUN      ] test_varg.expand_right_version</span><br><span class="line">1  ; </span><br><span class="line">2  ; </span><br><span class="line">3  ; </span><br><span class="line">4  ; </span><br><span class="line">0  ; </span><br><span class="line">1  ; </span><br><span class="line">2  ; </span><br><span class="line">3  ; </span><br><span class="line">hello , word , <span class="built_in">yes</span> , 1 , 3 , 4.5 ; </span><br><span class="line">[       OK ] test_varg.expand_right_version (0 ms)</span><br></pre></td></tr></table></figure> ### 折叠表达式</p>
<p>用折叠表达式可以把一些简单的递归写的更加简洁，但是他的运算方向和人通常认为的不同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">rsub</span><span class="params">(T... t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (t - ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">lsub</span><span class="params">(T... t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (... - t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_varg, fold_expressions) &#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">rsub</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">lsub</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ RUN      ] test_varg.fold_expressions</span><br><span class="line">3</span><br><span class="line">-13</span><br><span class="line">[       OK ] test_varg.fold_expressions (0 ms)</span><br></pre></td></tr></table></figure>
<h3 id="integer_sequence">integer_sequence</h3>
<p>利用integer_sequence我们可以展开一些数组，并对数组中的每个元素做处理，下面就给出一段编译期展开循环去计算卷积的程序：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span>... W&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">conv1xM</span><span class="params">(<span class="type">float</span>&amp; sum, T r, T k, std::index_sequence&lt;W...&gt;)</span> </span>&#123;</span><br><span class="line">  ((sum += r[W] * k[W]), ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> Filter_W, <span class="keyword">typename</span> T, <span class="type">size_t</span> Filter_H, <span class="type">size_t</span>... H&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">convNxM</span><span class="params">(<span class="type">float</span>&amp; sum, std::array&lt;T, Filter_H&gt;&amp; r, std::array&lt;T, Filter_H&gt;&amp; k,</span></span></span><br><span class="line"><span class="params"><span class="function">             std::index_sequence&lt;H...&gt;)</span> </span>&#123;</span><br><span class="line">  (<span class="built_in">conv1xM</span>(sum, r[H], k[H], std::make_index_sequence&lt;Filter_W&gt;&#123;&#125;), ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> Filter_W, <span class="keyword">typename</span> T, <span class="type">size_t</span> Filter_H&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">convNxM</span><span class="params">(<span class="type">float</span>&amp; sum, std::array&lt;T, Filter_H&gt;&amp; r,</span></span></span><br><span class="line"><span class="params"><span class="function">             std::array&lt;T, Filter_H&gt;&amp; k)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">convNxM</span>&lt;Filter_W&gt;(sum, r, k, std::make_index_sequence&lt;Filter_H&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_tmp, conv) &#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> K_h = <span class="number">3</span>, K_w = <span class="number">6</span>;</span><br><span class="line">  <span class="type">size_t</span> I_h = <span class="number">32</span>, I_w = <span class="number">64</span>;</span><br><span class="line">  <span class="type">float</span> kernel[K_h * K_w];</span><br><span class="line">  std::<span class="built_in">iota</span>(kernel, kernel + K_h * K_w, <span class="number">0</span>);</span><br><span class="line">  <span class="type">float</span> image[I_h * I_w];</span><br><span class="line">  std::<span class="built_in">iota</span>(image, image + I_h * I_w, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">IC</span>(image[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  std::array&lt;<span class="type">float</span>*, K_h&gt; r&#123;image, image + I_w, image + I_w * <span class="number">2</span>&#125;;</span><br><span class="line">  std::array&lt;<span class="type">float</span>*, K_h&gt; k&#123;kernel, kernel + K_w, kernel + K_w * <span class="number">2</span>&#125;;</span><br><span class="line">  <span class="type">float</span> sum = <span class="number">0.</span>;</span><br><span class="line">  <span class="built_in">convNxM</span>&lt;K_w&gt;(sum, r, k);</span><br><span class="line">  <span class="built_in">IC</span>(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ RUN      ] test_tmp.conv</span><br><span class="line">ic| image[0]: 0</span><br><span class="line">ic| <span class="built_in">sum</span>: 14835</span><br><span class="line">[       OK ] test_tmp.conv (0 ms)</span><br></pre></td></tr></table></figure></p>
<p>总之我们利用模板传递静态时期的常量，然后利用index
sequence对当前的数组进行索引从而获得展开循环的加速效果。</p>
<h2 id="右值左值">右值&amp;左值</h2>
<h3 id="一个问题">一个问题</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dosomething</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123; arr[<span class="number">2</span>] = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(rvalue, basic) &#123;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">dosomething</span>(arr);</span><br><span class="line">  <span class="built_in">dosomething</span>(vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模板">模板</h1>
<h3 id="获取容器内部类型">获取容器内部类型</h3>
<p>有个很蛋疼的问题就是对于传入一个array的数据，我们的模板定义需要
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="type">size_t</span> N&gt;</span><br></pre></td></tr></table></figure> 然后我就找了一下有没有方便的办法，发现可以这样：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Array&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">element_type_t</span> =</span><br><span class="line">    std::<span class="type">remove_reference_t</span>&lt;<span class="keyword">decltype</span>(*std::<span class="built_in">begin</span>(std::<span class="built_in">declval</span>&lt;Array&amp;&gt;()))&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N = <span class="number">20</span>, <span class="keyword">typename</span> Array&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">get_same_type_array</span>(Array&amp; a, <span class="type">element_type_t</span>&lt;Array&gt; b) &#123;</span><br><span class="line">  std::array&lt;<span class="type">element_type_t</span>&lt;Array&gt;, N&gt; c&#123;b&#125;;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_tmp, test_get_array_type) &#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> K_h = <span class="number">3</span>, K_w = <span class="number">6</span>;</span><br><span class="line">  <span class="type">size_t</span> I_h = <span class="number">32</span>, I_w = <span class="number">64</span>;</span><br><span class="line">  <span class="type">float</span> kernel[K_h * K_w];</span><br><span class="line">  std::<span class="built_in">iota</span>(kernel, kernel + K_h * K_w, <span class="number">0</span>);</span><br><span class="line">  <span class="type">float</span> image[I_h * I_w];</span><br><span class="line">  std::<span class="built_in">iota</span>(image, image + I_h * I_w, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">IC</span>(image[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  std::array&lt;<span class="type">float</span>*, K_h&gt; r&#123;image, image + I_w, image + I_w * <span class="number">2</span>&#125;;</span><br><span class="line">  std::array&lt;<span class="type">float</span>*, K_h&gt; k&#123;kernel, kernel + K_w, kernel + K_w * <span class="number">2</span>&#125;;</span><br><span class="line">  <span class="keyword">auto</span> b = <span class="built_in">get_same_type_array</span>&lt;<span class="number">5</span>&gt;(r, image);</span><br><span class="line">  <span class="built_in">IC</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实际上也就是静态时期的编译获得类型，然后得知输入b的类型，这样我们少输入一个模板，在多重模板迭代的过程中十分方便。</p>
<p>输出： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ RUN      ] test_tmp.test_get_array_type</span><br><span class="line">ic| image[0]: 0</span><br><span class="line">ic| b: [0x16ceccb30, 0x0, 0x0, 0x0, 0x0]</span><br><span class="line">[       OK ] test_tmp.test_get_array_type (0 ms)</span><br></pre></td></tr></table></figure></p>
<h2 id="编译期通过类型执行不同的代码">编译期通过类型执行不同的代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mat</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="type">float</span>* data;</span><br><span class="line">  <span class="built_in">Mat</span>() &#123; data = <span class="keyword">new</span> <span class="type">float</span>[<span class="number">100</span>]; &#125;</span><br><span class="line">  ~<span class="built_in">Mat</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_mat</span><span class="params">(T&amp; m)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_pointer&lt;T&gt;())</span> </span>&#123;</span><br><span class="line">    <span class="built_in">IC</span>(<span class="string">&quot;is pointer&quot;</span>);</span><br><span class="line">    m[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">IC</span>(<span class="string">&quot;is Mat&quot;</span>);</span><br><span class="line">    m.data[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test_tmp, integral_constant) &#123;</span><br><span class="line">  Mat m1;</span><br><span class="line">  <span class="type">float</span>* m2 = <span class="keyword">new</span> <span class="type">float</span>[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">make_mat</span>(m1);</span><br><span class="line">  <span class="built_in">make_mat</span>(m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[ RUN      ] test_tmp.integral_constant</span><br><span class="line">ic| std::<span class="built_in">string</span>(<span class="string">&quot;is Mat&quot;</span>): <span class="string">&quot;is Mat&quot;</span></span><br><span class="line">ic| std::<span class="built_in">string</span>(<span class="string">&quot;is pointer&quot;</span>): <span class="string">&quot;is pointer&quot;</span></span><br><span class="line">[       OK ] test_tmp.<span class="built_in">integral_constant</span> (<span class="number">0</span> ms)</span><br></pre></td></tr></table></figure>
<h2 id="类型保存值">类型保存值</h2>
<p>这个是我写了半天才发现c++模板的套路,其实就是把一个变量看成一个类型,下面就是把这个模板参数用两种方式表示(不过我暂时还不知道如何选择这两种方式):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">uint64_t</span> mmu_item,</span><br><span class="line">          <span class="type">uint64_t</span> start_bank,</span><br><span class="line">          MMU_CONF_WIDTH width,</span><br><span class="line">          <span class="type">uint64_t</span> start_depth,</span><br><span class="line">          <span class="type">uint64_t</span> depth&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">inst_mmu_conf_warper</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> type = std::index_sequence&lt;<span class="number">0x12</span>, mmu_item,</span><br><span class="line">                                   start_bank,</span><br><span class="line">                                   <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(width),</span><br><span class="line">                                   start_depth,</span><br><span class="line">                                   depth&gt;;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> <span class="keyword">auto</span> values = std::index_sequence&lt;<span class="number">0x12</span>, mmu_item,</span><br><span class="line">                                                     start_bank,</span><br><span class="line">                                                     <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(width),</span><br><span class="line">                                                     start_depth,</span><br><span class="line">                                                     depth&gt;&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="结构体模板元函数的套路">结构体模板元函数的套路</h2>
<p>其实一开始写模板看不懂就是因为c++的语法太多了,不过我们还是只需要掌握一些主要的语法就可以了.</p>
<p>我主要接触到的模板主要分以下几种表示方法. <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 模板元函数的写法 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义元函数的入参,这里表明这个结构体接收一个类型作为参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">method_1</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们特化上面的那个元函数,通常特化直接写值,但是由于我们当前给的参数还依赖一个未知的`Value`,因此还需要给元函数再加一个模板类型.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> Value&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">method_1</span>&lt;std::integral_constant&lt;<span class="type">size_t</span>, Value&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 同时对于这个模板元的返回值也有两种方法,可以是一个静态的变量,也可以是对应的类型(此时那个类型其实也保存了值)</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> one_v = Value + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">using</span> <span class="type">one_t</span> = std::integral_constant&lt;<span class="type">size_t</span>, Value + <span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2
id="模板元函数编写与匹配的几个套路">模板元函数编写与匹配的几个套路</h2>
<p>在c++17之前我们可以用<code>std::enable_if</code>来决议这个匹配是不是有效的,首先对于同一个函数,他的返回值应该是一致的(保证我们思维的一致性),所以通过<code>enable_if</code>决议当前的输入类型下是否可以匹配.
下面这个例子就是把整形和array类型通过决议分开匹配,从而实现不同的<code>assgin_to_array</code>,不然输入的<code>array</code>还是会被默认匹配到第一个函数:
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span>... Is&gt;</span><br><span class="line"><span class="keyword">constexpr</span> std::<span class="type">enable_if_t</span>&lt;std::is_integral_v&lt;T&gt;, <span class="type">void</span>&gt; <span class="built_in">assgin_to_array</span>(std::array&lt;<span class="type">uint8_t</span>, <span class="built_in">sizeof</span>(T)&gt; &amp;dest, <span class="type">const</span> T &amp;src, std::index_sequence&lt;Is...&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  ((dest[Is] = (src &gt;&gt; (Is * <span class="number">8</span>))), ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="type">size_t</span> N, <span class="type">size_t</span>... Is&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::<span class="type">enable_if_t</span>&lt;<span class="title">sizeof</span><span class="params">(T1)</span> </span>== <span class="built_in">sizeof</span>(T2), <span class="type">void</span>&gt; <span class="built_in">assgin_to_array</span>(std::array&lt;T1, N&gt; &amp;dest, <span class="type">const</span> std::array&lt;T2, N&gt; &amp;src, std::index_sequence&lt;Is...&gt;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">copy</span>(dest.<span class="built_in">data</span>(), src.<span class="built_in">data</span>(), <span class="number">0</span>, std::index_sequence&lt;Is...&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过现在有了<code>constexpr if</code>,我们可以直接在同一个函数中不同的操作,这里要注意一个小坑,就是<code>std::is_array</code>只能检测是不是c风格的数组,但是他不能检测<code>std::array</code>,所以我这里重写了一个<code>is_std_array</code>:
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">size_t</span>... Is&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">assgin_to_array</span><span class="params">(std::array&lt;<span class="type">uint8_t</span>, <span class="keyword">sizeof</span>(T)&gt; &amp;dest, <span class="type">const</span> T &amp;src, std::index_sequence&lt;Is...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral_v&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ((dest[Is] = (src &gt;&gt; (Is * <span class="number">8</span>))), ...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (is_std_array&lt;T&gt;::value)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">copy</span>(dest.<span class="built_in">data</span>(), src.<span class="built_in">data</span>(), <span class="number">0</span>, std::index_sequence&lt;Is...&gt;&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2
id="tuple元素进行fold-expressions中重载操作符遇到的坑">tuple元素进行fold
expressions中重载操作符遇到的坑</h2>
<p>我想重载<code>+</code>然后对<code>tuple</code>进行操作,但是遇到找不到重载加号的问题.最后发现这个操作必须要声明到std才有效.</p>
<h2 id="变长模板匹配的模式">变长模板匹配的模式</h2>
<p>c++变长模板他不能匹配<code>seq&lt;Le..., Ls&gt;</code>这种模式,只能匹配<code>seq&lt;Ls,Le...&gt;</code>,也就是取第一个元素是方便的(或者前n个元素都是方便的),如果你想取最后一个元素那么就需要递归一次.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">take_head</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> Ls, <span class="type">size_t</span>... Le&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">take_head</span>&lt;seq&lt;Ls, Le...&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value = Ls;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">take_two_head</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> Ls, <span class="type">size_t</span>... Le, <span class="type">size_t</span> Rs, <span class="type">size_t</span>... Re&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">take_two_head</span>&lt;seq&lt;Le..., Ls&gt;, seq&lt;Re..., Rs&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value_L = Ls;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">size_t</span> value_R = Rs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test, take_two_head)</span><br><span class="line">&#123;</span><br><span class="line">  take_two_head&lt;seq&lt;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&gt;, seq&lt;<span class="number">5</span>, <span class="number">6</span>&gt;&gt; two&#123;&#125;;</span><br><span class="line">  <span class="comment">//  auto lh = &#123;&#125; value;</span></span><br><span class="line">  <span class="built_in">ic</span>(two.value_L);</span><br><span class="line">  <span class="built_in">ic</span>(two.value_R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="通过隐式转换来实现零成本抽象">通过隐式转换来实现零成本抽象</h2>
<p>通过vector包</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;optional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;span&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arm_neon.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span>... Lanes&gt; <span class="keyword">struct</span> <span class="title class_">native_vector_type</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">native_vector_type</span>&lt;<span class="type">float</span>, <span class="number">32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">float32x4_t</span>[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">native_vector_type</span>&lt;<span class="type">float</span>, <span class="number">4</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="type">float32x4_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span>... Lanes&gt; <span class="keyword">struct</span> <span class="title class_">vector</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> element_type = T;</span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> native_vector_type&lt;T, Lanes...&gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="built_in">sizeof</span>(value_type)) value_type v_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>(<span class="type">const</span> value_type &amp;vec) : <span class="built_in">v_</span>(vec) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">value_type</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> v_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">operator</span> value_type &amp;() <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> v_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">buffer</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">span</span>(<span class="built_in">reinterpret_cast</span>&lt;element_type *&gt;(&amp;v_),</span><br><span class="line">                         (<span class="number">1</span> * ... * Lanes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">float</span>,4&gt; *a = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="type">float</span>,<span class="number">4</span>&gt;();</span><br><span class="line">    a-&gt;<span class="built_in">buffer</span>()[<span class="number">0</span>] = <span class="number">1.0f</span>;</span><br><span class="line">    a-&gt;<span class="built_in">buffer</span>()[<span class="number">1</span>] = <span class="number">2.0f</span>;</span><br><span class="line">    vector&lt;<span class="type">float</span>,4&gt; b;</span><br><span class="line">    b.<span class="built_in">buffer</span>()[<span class="number">0</span>] = <span class="number">1.0f</span>;</span><br><span class="line">    b.<span class="built_in">buffer</span>()[<span class="number">1</span>] = <span class="number">2.0f</span>;</span><br><span class="line">    <span class="comment">// float32x4_t d;</span></span><br><span class="line">    vector&lt;<span class="type">float</span>,4&gt; c = *a * b;</span><br><span class="line">    std::cout &lt;&lt; c.<span class="built_in">buffer</span>()[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; c.<span class="built_in">buffer</span>()[<span class="number">1</span>] &lt;&lt; std::endl;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类">类</h1>
<h2 id="explicit">explicit</h2>
<p>explicit是用于表示当前的构造函数不能进行隐式转换，比如如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlob</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  shared_ptr&lt;vector&lt;string&gt;&gt; data;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">StrBlob</span>() : <span class="built_in">data</span>(make_shared&lt;vector&lt;string&gt;&gt;())&#123;&#125;;</span><br><span class="line">  <span class="built_in">StrBlob</span>(initializer_list&lt;string&gt; il)</span><br><span class="line">      : <span class="built_in">data</span>(make_shared&lt;vector&lt;string&gt;&gt;(il))&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">use_count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data.<span class="built_in">use_count</span>(); &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;front&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> data-&gt;<span class="built_in">front</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> string&amp; <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;back&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> data-&gt;<span class="built_in">back</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123; data-&gt;<span class="built_in">push_back</span>(s); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">check</span>(<span class="number">0</span>, <span class="string">&quot;pop_back&quot;</span>);</span><br><span class="line">    data-&gt;<span class="built_in">pop_back</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">combine</span><span class="params">(StrBlob sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = sb.data-&gt;<span class="built_in">begin</span>(); p != sb.data-&gt;<span class="built_in">end</span>(); p++)</span><br><span class="line">      data-&gt;<span class="built_in">push_back</span>(*p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">size_t</span> i, <span class="type">const</span> string&amp; msg)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>()) &#123; <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(msg); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(test, t_12_5) &#123;</span><br><span class="line">  StrBlob b1&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">  <span class="built_in">ic</span>(*b1.data);</span><br><span class="line">  b1.<span class="built_in">combine</span>(&#123;<span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>&#125;);</span><br><span class="line">  <span class="built_in">ic</span>(*b1.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在调用combine函数的时候需要的是一个StrBlob对象，但是我们实际combine的时候传入的是一个初始化列表，那么这个时候就会把隐式调用对应的构造函数，完成参数传递。这个时候如果我们给对应初始化列表的构造函数进行explicit限制，那么就会出现编译错误，要求传入一个正确的StrBlob对象。</p>
<h1 id="share_ptr">share_ptr</h1>
<h2 id="构造函数">构造函数</h2>
<p>这里有点奇怪，不强行指定<code>initializer_list&lt;int&gt;</code>是无法通过编译的，这太蛋疼了。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">make_shared&lt;vector&lt;<span class="type">int</span>&gt;&gt;(initializer_list&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure> 同时make_shared还不支持new的方式构造shared_ptr。 ##
拷贝赋值</p>
<p>他的赋值是直接把被赋值对象的内容给清空了，被赋值之后，q和
p其实都是q了，最后退出scope的时候，p的use_count会因为q的释放减少。
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(test, shared_ptr_copy) &#123;</span><br><span class="line">  <span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> q = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">11</span>);</span><br><span class="line">    p = q;</span><br><span class="line">    <span class="built_in">ic</span>(*q, q.<span class="built_in">use_count</span>());</span><br><span class="line">    <span class="built_in">ic</span>(*p, p.<span class="built_in">use_count</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">ic</span>(*p, p.<span class="built_in">use_count</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ RUN      ] test.shared_ptr_copy</span><br><span class="line">ic| *q: 11, q.use_count(): 2</span><br><span class="line">ic| *p: 11, p.use_count(): 2</span><br><span class="line">ic| *p: 11, p.use_count(): 1</span><br><span class="line">[       OK ] test.shared_ptr_copy (0 ms)</span><br></pre></td></tr></table></figure>
<h2 id="c-munmap_chunk-invalid-pointer">C++: munmap_chunk(): invalid
pointer</h2>
<ol type="1">
<li>通常这个问题应该是delete的内存不是被new出来的。</li>
<li>指针运行时被修改</li>
<li>指针越界（数组越界赋值了，但是当时不报错）</li>
</ol>
<h1 id="clang编译中报错-no-viable-overloaded">clang编译<map>中报错 no
viable overloaded '='</h1>
<p>这个应该是clang的map头文件实现导致的,</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_LIBCPP_INLINE_VISIBILITY</span><br><span class="line">__value_type&amp; <span class="keyword">operator</span>=(<span class="type">const</span> __value_type&amp; __v)</span><br><span class="line">&#123;</span><br><span class="line">    __ref() = __v.__get_value();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过clangd的类型提示发现: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>: std::__value_type::value_type &amp;__get_value()</span><br><span class="line">no viable overloaded <span class="string">&#x27;=&#x27;</span>GCC</span><br><span class="line">__tree(<span class="number">1662</span>, <span class="number">39</span>): in instantiation of member function <span class="string">&#x27;std::__value_type&lt;const air::Var, int&gt;::operator=&#x27;</span> requested here</span><br></pre></td></tr></table></figure></p>
<p>这个应该就是声明了一个包含<code>const air::Var</code>类型的map,然后类型特化的时候就出错了.</p>
<h1 id="ld-unknown-option--z">ld: unknown option: -z</h1>
<p>这个也是在mac上独有的问题,gcc
ld中可以通过<code>-Wl,-z,relro,-z,now,-z,noexecstack</code>传递linker的参数,但是mac上虽然也可以给apple
clang提供相同的命令行,但是真正调用<code>ld</code>的时候就会报上述错误,原因就是mac上的ld真的不支持这些选项...所以关闭即可.</p>
<h1 id="ld-unknown-corefoundation">ld: unknown CoreFoundation</h1>
<p>我想给target加上link参数,但是用cmake的写法发现有个大坑,
如果直接加Wl然后选项, 再用字符串包裹起来, 是无法编译的,
但是如果不用字符串, 编译器就会把空格后面的东西识别成另一个选项.
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_options</span>(simulator_k510 PUBLIC <span class="string">&quot;-Wl,-framework CoreFoundation&quot;</span>)</span><br></pre></td></tr></table></figure> 所以正确做法是连续的加Wl <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target_link_options(simulator_k510 PUBLIC -Wl,-framework -Wl,CoreFoundation)</span><br></pre></td></tr></table></figure></p>
<h1 id="m1上eigen使用fp16时的坑">m1上eigen使用fp16时的坑</h1>
<p>在m1上eigen会检测到有fp16计算单元,此时<code>__half_raw</code>结构体中包含的就是<code>__fp16</code>类型
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__half_raw</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(EIGEN_HAS_ARM64_FP16_SCALAR_ARITHMETIC)</span></span><br><span class="line">  <span class="keyword">explicit</span> EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR __half_raw(numext::<span class="type">uint16_t</span> raw) : <span class="built_in">x</span>(numext::<span class="built_in">bit_cast</span>&lt;__fp16&gt;(raw)) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  __fp16 x;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="keyword">explicit</span> EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR __half_raw(numext::<span class="type">uint16_t</span> raw) : <span class="built_in">x</span>(raw) &#123;&#125;</span><br><span class="line">  numext::<span class="type">uint16_t</span> x;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果没有那么就是标准的uint16类型,所以此时不能随便将<code>__fp16</code>的<code>x</code>赋值给<code>fp16</code>,需要使用<code>Eigen::numext::bit_cast&lt;uint16_t&gt;(dst_eig_f16.x)</code>才行.</p>
<h1 id="c语言regex使用">c语言regex使用</h1>
<p>c里面的正则库是一个非常老的库,所以他的正则语法和其他语言有一部分正好相反,需要参考<a
target="_blank" rel="noopener" href="https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Basic_Regular_Expressions">这里</a>.</p>
<h1 id="linux下使用shared-memory的坑">linux下使用shared memory的坑</h1>
<p>我是在docker中的ubuntu容器中使用shared memory,
发现虽然可以创建shm文件,但是只要进行内存写入copy的时候就会报错<code>Bus Error</code>.
参考<a
target="_blank" rel="noopener" href="https://georgeoffley.com/blog/shared-memory-in-docker.html">这篇文章</a>才知道是docker本身限制的容器的shared
memory大小只有64M.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">df</span> -h | grep shm</span><br><span class="line">shm                                                          64M   64M     0 100% /dev/shm</span><br></pre></td></tr></table></figure>
<h1 id="命令行调试dotnet-core的dump信息">命令行调试dotnet
core的dump信息</h1>
<ol type="1">
<li>安装<a
target="_blank" rel="noopener" href="https://github.com/dotnet/diagnostics/blob/main/documentation/installing-sos-instructions.md">dotnet
sos</a>
<ol type="1">
<li>注意mac m1系列需要<code>dotnet-sos install --arch Arm64</code></li>
</ol></li>
<li>然后开启core dump收集 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;core.%e.%p&quot;</span> &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure></li>
<li>通过lldb挂载core file</li>
</ol>
<p>这里我直接用vscode插件里面的lldb, 这个版本比较新,好用:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">~/.vscode-server/extensions/vadimcn.vscode-lldb-1.7.2/lldb/bin/lldb -c tests/ForDebug/core..NET\ ThreadPool.298375</span><br></pre></td></tr></table></figure>
<p>然后进去输入<code>bt</code>检查栈内容, 反正一顿调之后,
终于发现问题出在了.net过早的释放了c++的类对象.
原因是这个.net中类是对interpreter的包装,然后再构造entry funciton的对象,
entry function里面包含了interpreter, 但是在调用entry function
invoke的时候.net还是会把interpreter释放掉, 然后c++中就会出现runtime
function运行到一半时访问了被释放的自身.
上面这个问题也只有在.net的release中才会出现, 我怀疑是因为.net优化了</p>
<h1 id="mac中缺少gmp的问题">mac中缺少gmp的问题</h1>
<p>mac中安装clang时候默认是没有gmp.h的,
但是如果安装了python的话是可以在python的inclue中找到. <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">❯ ll /Users/lisa/miniforge3/envs/dl/include | grep gmp</span><br><span class="line">-rw-rw-r--    1 lisa  staff    82K  5 15 18:32 gmp.h</span><br><span class="line">-rw-rw-r--    2 lisa  staff   126K 11 19  2020 gmpxx.h</span><br></pre></td></tr></table></figure></p>
<p>然后可以添加链接库和头文件位置:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CFLAGS=-I/Users/lisa/miniforge3/envs/dl/include</span><br><span class="line">LDFLAGS=-L/Users/lisa/miniforge3/envs/dl/lib</span><br></pre></td></tr></table></figure>
<h1
id="mac中编译出现libclang-cpp.dylib的问题">mac中编译出现libclang-cpp.dylib的问题</h1>
<p>我这里是编译pet的lib, 然后make install的报错如下: <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Reason: tried: <span class="string">&#x27;/usr/local/lib/libclang-cpp.dylib&#x27;</span> (no such file), <span class="string">&#x27;/usr/lib/libclang-cpp.dylib&#x27;</span> (no such file)</span><br></pre></td></tr></table></figure></p>
<p>然后发现是因为他的makefile里面调用了之前链接libclang的可执行文件extract_interface,
但是不知道为什么他的rpath没有设置对,导致还得手动设置<code>LD_LIBRARY_PATH</code>才能找到.so.
然后尝试了一下外部export环境变量,但是在makefile中并不起作用,
所以直接改了makefile: NOTE :
我这里是mac所以使用<code>DYLD_LIBRARY_PATH</code> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">isl.py: libdep.a interface/isl.py.top</span><br><span class="line">	(<span class="built_in">cat</span> $(srcdir)/interface/isl.py.top &amp;&amp; \</span><br><span class="line">		DYLD_LIBRARY_PATH=/Users/lisa/Documents/llvm-project/build/install/lib/ isl/interface/extract_interface$(EXEEXT) \</span><br><span class="line">			--language=python \</span><br><span class="line">			$(DEFAULT_INCLUDES) -I$(top_srcdir)/isl/include -I$(top_builddir)/isl/include \</span><br><span class="line">			<span class="string">&quot;./isl/all.h&quot;</span>) \</span><br><span class="line">			&gt; <span class="variable">$@</span> || (<span class="built_in">rm</span> <span class="variable">$@</span> &amp;&amp; <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p>
<p>找到了根本原因,其实就是他的编译器选项和clang的不同,他使用了<code>-R</code>来声明rpath,
但是clang中要使用<code>-Wl,-rpath,xxx</code>来设置rpath:
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">CLANG_RFLAG=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$CLANG_LDFLAGS</span>&quot;</span> | <span class="variable">$SED</span> -e <span class="string">&#x27;s\/-L\/-R\/g&#x27;</span>`</span><br><span class="line"><span class="comment"># 改成如下即可.</span></span><br><span class="line">CLANG_RFLAG=`<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$CLANG_LDFLAGS</span>&quot;</span> | <span class="variable">$SED</span> -e <span class="string">&#x27;s/-L/-Wl,-rpath,/g&#x27;</span>`</span><br></pre></td></tr></table></figure></p>
<h1 id="mac中stdio.h-file-not-found">mac中'stdio.h' file not found</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/* /usr/local/include/</span><br></pre></td></tr></table></figure>
<h1 id="relocation-r_riscv_jal-out-of-range">relocation R_RISCV_JAL out
of range</h1>
<p>好像是因为.a太大了的缘故,导致relocation跳转不过去.</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[build] ld: error: /home/zqh/workspace/AndeSight_STD_v323/toolchains/nds64le-elf-mculib-v5d/bin/../lib/gcc/riscv64-elf/7.4.0/../../../../riscv64-elf/lib/libc.a(lib_a-memmove.o):(<span class="keyword">function</span> memmove): relocation R_RISCV_JAL out of range: 645800 is not <span class="keyword">in</span> [-524288, 524287]</span><br><span class="line">[build] ld: error: /home/zqh/workspace/AndeSight_STD_v323/toolchains/nds64le-elf-mculib-v5d/bin/../lib/gcc/riscv64-elf/7.4.0/../../../../riscv64-elf/lib/libc.a(lib_a-memmove.o):(<span class="keyword">function</span> memmove): relocation R_RISCV_JAL out of range: 645718 is not <span class="keyword">in</span> [-524288, 524287]</span><br></pre></td></tr></table></figure>
<h1 id="lldb-调试pythonccsharp">lldb 调试python/c++/csharp</h1>
<ol type="1">
<li>添加各种环境变量.</li>
<li>用lldb启动python
<code>❯ lldb-10 /root/miniconda3/envs/ci/bin/python</code></li>
<li>进入后通过run 启动py文件
<code>(lldb) run test_mobilenetv1.py</code></li>
</ol>
<h1 id="lldb-调试通过loadelf启动的可执行文件">lldb
调试通过loadelf启动的可执行文件</h1>
<p>首先是<code>image add</code> <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Add a new module to the current target<span class="string">&#x27;s modules.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Syntax: target modules add [&lt;module&gt;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Command Options Usage:</span></span><br><span class="line"><span class="string">  target modules add [-u &lt;module-uuid&gt;] [-s &lt;filename&gt;] [&lt;path&gt; [&lt;path&gt; [...]]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       -s &lt;filename&gt; ( --symfile &lt;filename&gt; )</span></span><br><span class="line"><span class="string">            Fullpath to a stand alone debug symbols file for when debug symbols</span></span><br><span class="line"><span class="string">            are not in the executable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">       -u &lt;module-uuid&gt; ( --uuid &lt;module-uuid&gt; )</span></span><br><span class="line"><span class="string">            A module UUID value.</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">     This command takes options and free-form arguments.  If your arguments</span></span><br><span class="line"><span class="string">     resemble option specifiers (i.e., they start with a - or --), you must use</span></span><br><span class="line"><span class="string">     &#x27;</span> -- <span class="string">&#x27; between the end of the command options and the beginning of the</span></span><br><span class="line"><span class="string">     arguments.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;</span>image<span class="string">&#x27; is an abbreviation for &#x27;</span>target modules<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
和<code>image load</code>命令: <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Set the load addresses <span class="keyword">for</span> one or more sections <span class="keyword">in</span> a target module.</span><br><span class="line"></span><br><span class="line">Syntax: target modules load [--file &lt;module&gt; --uuid &lt;uuid&gt;] &lt;sect-name&gt; &lt;address&gt; [&lt;sect-name&gt; &lt;address&gt; ....]</span><br><span class="line"></span><br><span class="line">Command Options Usage:</span><br><span class="line">  target modules load [-lp] [-u &lt;module-uuid&gt;] [-f &lt;name&gt;] [-s &lt;offset&gt;] [&lt;filename&gt; [&lt;filename&gt; [...]]]</span><br><span class="line"></span><br><span class="line">       -f &lt;name&gt; ( --file &lt;name&gt; )</span><br><span class="line">            Fullpath or <span class="built_in">basename</span> <span class="keyword">for</span> module to load.</span><br><span class="line"></span><br><span class="line">       -l ( --load )</span><br><span class="line">            Write file contents to the memory.</span><br><span class="line"></span><br><span class="line">       -p ( --set-pc-to-entry )</span><br><span class="line">            Set PC to the entry point. Only applicable with <span class="string">&#x27;--load&#x27;</span> option.</span><br><span class="line"></span><br><span class="line">       -s &lt;offset&gt; ( --slide &lt;offset&gt; )</span><br><span class="line">            Set the load address <span class="keyword">for</span> all sections to be the virtual address <span class="keyword">in</span></span><br><span class="line">            the file plus the offset.</span><br><span class="line"></span><br><span class="line">       -u &lt;module-uuid&gt; ( --uuid &lt;module-uuid&gt; )</span><br><span class="line">            A module UUID value.</span><br><span class="line">     </span><br><span class="line">     This <span class="built_in">command</span> takes options and free-form arguments.  If your arguments</span><br><span class="line">     resemble option specifiers (i.e., they start with a - or --), you must use</span><br><span class="line">     <span class="string">&#x27; -- &#x27;</span> between the end of the <span class="built_in">command</span> options and the beginning of the</span><br><span class="line">     arguments.</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;image&#x27;</span> is an abbreviation <span class="keyword">for</span> <span class="string">&#x27;target modules&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="linux分布式资源分配">linux分布式资源分配</h1>
<p>参考资料: <a
target="_blank" rel="noopener" href="https://manuel.bernhardt.io/posts/2023-11-16-core-pinning/">core-pinning</a>
<a target="_blank" rel="noopener" href="https://www.open-mpi.org/projects/hwloc/">hwloc</a>
这里使用hwloc输出的拓扑图: <img
src="/2021/04/25/cpp-trick/topo.png" /></p>
<h2 id="taskset">taskset</h2>
<p>taskset是用于分配cpu资源, 但是在我这个物理上是128核的机器,
使用taskset是可以设定到0-255核的,
那么说明这个taskset的逻辑和物理的逻辑不一样.
但是taskset和mpi的配合好像不是很好: <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">❯ taskset -c 0-9 mpiexec -n 8 --bind-to core  python summa_3d.py</span><br><span class="line">6 6</span><br><span class="line">2 2</span><br><span class="line">4 4</span><br><span class="line">0 0</span><br><span class="line">5 5</span><br><span class="line">1 1</span><br><span class="line">7 7</span><br><span class="line">3 131</span><br><span class="line">❯ taskset -c 0-4 mpiexec -n 8 --bind-to core  python summa_3d.py</span><br><span class="line">4 4</span><br><span class="line">0 0</span><br><span class="line">5 5</span><br><span class="line">1 1</span><br><span class="line">7 7</span><br><span class="line">3 131</span><br><span class="line">6 134</span><br><span class="line">2 130</span><br></pre></td></tr></table></figure></p>
<h2 id="numactl">numactl</h2>
<p>numactl 是分配内存资源的, 可以和taskset一起使用, 先使用numactl.
是用前可以通过hardware查看自身机器状态 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">❯ numactl --hardware</span><br><span class="line">available: 2 nodes (0-1)</span><br><span class="line">node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191</span><br><span class="line">node 0 size: 1019903 MB</span><br><span class="line">node 0 free: 951010 MB</span><br><span class="line">node 1 cpus: 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255</span><br><span class="line">node 1 size: 1032158 MB</span><br><span class="line">node 1 free: 813857 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0   1 </span><br><span class="line">  0:  10  32 </span><br><span class="line">  1:  32  10 </span><br><span class="line"></span><br><span class="line">❯ numactl --cpunodebind=0 -l --physcpubind=0-64 xxx</span><br></pre></td></tr></table></figure></p>
<h2 id="mpi指定拓扑">mpi指定拓扑</h2>
<p>这里我使用的是mpich的mpiexec,
他提供了<code>--bind-to</code>和<code>--map-by</code>两个参数,
最简单的方式是使用user的方式来设定 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">❯ mpiexec -n 8 --bind-to user:0,1,2,3,3,2,1,0  python summa_3d.py</span><br><span class="line">6 1</span><br><span class="line">5 2</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">4 3</span><br><span class="line">7 0</span><br><span class="line">0 0</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure></p>
<h1 id="perf常用命令">perf常用命令</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">❯ perf record -h</span><br><span class="line"></span><br><span class="line"> Usage: perf record [&lt;options&gt;] [&lt;<span class="built_in">command</span>&gt;]</span><br><span class="line">    or: perf record [&lt;options&gt;] -- &lt;<span class="built_in">command</span>&gt; [&lt;options&gt;]</span><br><span class="line"></span><br><span class="line">    -a, --all-cpus        system-wide collection from all CPUs</span><br><span class="line">    -b, --branch-any      sample any taken branches</span><br><span class="line">    -B, --no-buildid      <span class="keyword">do</span> not collect buildids <span class="keyword">in</span> perf.data</span><br><span class="line">    -c, --count &lt;n&gt;       event period to sample</span><br><span class="line">    -C, --cpu &lt;cpu&gt;       list of cpus to monitor</span><br><span class="line">    -d, --data            Record the sample addresses</span><br><span class="line">    -D, --delay &lt;n&gt;       ms to <span class="built_in">wait</span> before starting measurement after program start</span><br><span class="line">    -e, --event &lt;event&gt;   event selector. use <span class="string">&#x27;perf list&#x27;</span> to list available events</span><br><span class="line">    -F, --freq &lt;freq or <span class="string">&#x27;max&#x27;</span>&gt;</span><br><span class="line">                          profile at this frequency</span><br><span class="line">    -g                    enables call-graph recording</span><br><span class="line">    -G, --cgroup &lt;name&gt;   monitor event <span class="keyword">in</span> cgroup name only</span><br><span class="line">    -I, --intr-regs[=&lt;any register&gt;]</span><br><span class="line">                          sample selected machine registers on interrupt, use <span class="string">&#x27;-I?&#x27;</span> to list register names</span><br><span class="line">    -i, --no-inherit      child tasks <span class="keyword">do</span> not inherit counters</span><br><span class="line">    -j, --branch-filter &lt;branch filter mask&gt;</span><br><span class="line">                          branch stack filter modes</span><br><span class="line">    -k, --clockid &lt;clockid&gt;</span><br><span class="line">                          clockid to use <span class="keyword">for</span> events, see clock_gettime()</span><br><span class="line">    -m, --mmap-pages &lt;pages[,pages]&gt;</span><br><span class="line">                          number of mmap data pages and AUX area tracing mmap pages</span><br><span class="line">    -N, --no-buildid-cache</span><br><span class="line">                          <span class="keyword">do</span> not update the buildid cache</span><br><span class="line">    -n, --no-samples      don<span class="string">&#x27;t sample</span></span><br><span class="line"><span class="string">    -o, --output &lt;file&gt;   output file name</span></span><br><span class="line"><span class="string">    -P, --period          Record the sample period</span></span><br><span class="line"><span class="string">    -p, --pid &lt;pid&gt;       record events on existing process id</span></span><br><span class="line"><span class="string">    -q, --quiet           don&#x27;</span>t <span class="built_in">print</span> any message</span><br><span class="line">    -R, --raw-samples     collect raw sample records from all opened counters</span><br><span class="line">    -r, --realtime &lt;n&gt;    collect data with this RT SCHED_FIFO priority</span><br><span class="line">    -S, --snapshot[=&lt;opts&gt;]</span><br><span class="line">                          AUX area tracing Snapshot Mode</span><br><span class="line">    -s, --<span class="built_in">stat</span>            per thread counts</span><br><span class="line">    -t, --tid &lt;tid&gt;       record events on existing thread <span class="built_in">id</span></span><br><span class="line">    -T, --timestamp       Record the sample timestamps</span><br><span class="line">    -u, --uid &lt;user&gt;      user to profile</span><br><span class="line">    -v, --verbose         be more verbose (show counter open errors, etc)</span><br><span class="line">    -W, --weight          sample by weight (on special events only)</span><br><span class="line">        --affinity &lt;node|cpu&gt;</span><br><span class="line">                          Set affinity mask of trace reading thread to NUMA node cpu mask or cpu of processed mmap buffer</span><br><span class="line">        --aio[=&lt;n&gt;]       Use &lt;n&gt; control blocks <span class="keyword">in</span> asynchronous trace writing mode (default: 1, max: 4)</span><br><span class="line">        --all-kernel      Configure all used events to run <span class="keyword">in</span> kernel space.</span><br><span class="line">        --all-user        Configure all used events to run <span class="keyword">in</span> user space.</span><br><span class="line">        --buildid-all     Record build-id of all DSOs regardless of hits</span><br><span class="line">        --call-graph &lt;record_mode[,record_size]&gt;</span><br><span class="line">                          setup and enables call-graph (stack chain/backtrace):</span><br><span class="line"></span><br><span class="line">                                record_mode:    call graph recording mode (fp|dwarf|lbr)</span><br><span class="line">                                record_size:    <span class="keyword">if</span> record_mode is <span class="string">&#x27;dwarf&#x27;</span>, max size of stack recording (&lt;bytes&gt;)</span><br><span class="line">                                                default: 8192 (bytes)</span><br><span class="line"></span><br><span class="line">                                Default: fp</span><br><span class="line">        --clang-opt &lt;clang options&gt;</span><br><span class="line">                          options passed to clang when compiling BPF scriptlets</span><br><span class="line">        --clang-path &lt;clang path&gt;</span><br><span class="line">                          clang binary to use <span class="keyword">for</span> compiling BPF scriptlets</span><br><span class="line">        --dry-run         Parse options <span class="keyword">then</span> <span class="built_in">exit</span></span><br><span class="line">        --exclude-perf    don<span class="string">&#x27;t record events from perf itself</span></span><br><span class="line"><span class="string">        --filter &lt;filter&gt;</span></span><br><span class="line"><span class="string">                          event filter</span></span><br><span class="line"><span class="string">        --group           put the counters into a counter group</span></span><br><span class="line"><span class="string">        --kernel-callchains</span></span><br><span class="line"><span class="string">                          collect kernel callchains</span></span><br><span class="line"><span class="string">        --mmap-flush &lt;number&gt;</span></span><br><span class="line"><span class="string">                          Minimal number of bytes that is extracted from mmap data pages (default: 1)</span></span><br><span class="line"><span class="string">        --namespaces      Record namespaces events</span></span><br><span class="line"><span class="string">        --no-bpf-event    record bpf events</span></span><br><span class="line"><span class="string">        --no-buffering    collect data without buffering</span></span><br><span class="line"><span class="string">        --overwrite       use overwrite mode</span></span><br><span class="line"><span class="string">        --per-thread      use per-thread mmaps</span></span><br><span class="line"><span class="string">        --phys-data       Record the sample physical addresses</span></span><br><span class="line"><span class="string">        --proc-map-timeout &lt;n&gt;</span></span><br><span class="line"><span class="string">                          per thread proc mmap processing timeout in ms</span></span><br><span class="line"><span class="string">        --running-time    Record running/enabled time of read (:S) events</span></span><br><span class="line"><span class="string">        --sample-cpu      Record the sample cpu</span></span><br><span class="line"><span class="string">        --strict-freq     Fail if the specified frequency can&#x27;</span>t be used</span><br><span class="line">        --switch-events   Record context switch events</span><br><span class="line">        --switch-max-files &lt;n&gt;</span><br><span class="line">                          Limit number of switch output generated files</span><br><span class="line">        --switch-output[=&lt;signal or size[BKMG] or time[smhd]&gt;]</span><br><span class="line">                          Switch output when receiving SIGUSR2 (signal) or cross a size or time threshold</span><br><span class="line">        --tail-synthesize</span><br><span class="line">                          synthesize non-sample events at the end of output</span><br><span class="line">        --timestamp-boundary</span><br><span class="line">                          Record timestamp boundary (time of first/last samples)</span><br><span class="line">        --timestamp-filename</span><br><span class="line">                          append timestamp to output filename</span><br><span class="line">        --transaction     sample transaction flags (special events only)</span><br><span class="line">        --user-callchains</span><br><span class="line">                          collect user callchains</span><br><span class="line">        --user-regs[=&lt;any register&gt;]</span><br><span class="line">                          sample selected machine registers on interrupt, use <span class="string">&#x27;--user-regs=?&#x27;</span> to list register names</span><br><span class="line">        --vmlinux &lt;file&gt;  vmlinux pathname</span><br></pre></td></tr></table></figure>
<p>perf可以通过-e记录一些特定的事件, 比如page-faults,
LLC-loads用于记录cache miss</p>
<p>调用flamegraph, 注意record的时候必须要开-g收集调用栈,
并且如果用fp记录栈，还需要在编译的时候开启<code>-fnoomit-frame-pointer</code>.
这个是linux 2.6的使用方式 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/brendangregg/FlameGraph</span><br><span class="line"><span class="built_in">export</span> FlameGraph=`<span class="built_in">pwd</span>`/FlameGraph</span><br><span class="line">perf record -g your_program</span><br><span class="line">perf script -i perf.data | <span class="variable">$&#123;FlameGraph&#125;</span>/stackcollapse-perf.pl | <span class="variable">$&#123;FlameGraph&#125;</span>/flamegraph.pl &gt; flamegraph.svg</span><br></pre></td></tr></table></figure></p>
<p>而linux 4.9以上只需要使用profile.py即可,
不过我在docker里面可能内核版本比较低,
安装bpfcc之后并没有相关的可执行文件, 不过现在是支持从conda安装.
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">❯ conda install pdrops::bcc</span><br></pre></td></tr></table></figure></p>
<p>但是ebpf在容器中执行需要容器有privilege权限, 否则没法使用.</p>
<h1 id="profile-python">profile python</h1>
<p>可以使用cProfile来profiling整个python脚本 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python -m cProfile --<span class="built_in">help</span></span><br><span class="line">Usage: cProfile.py [-o output_file_path] [-s <span class="built_in">sort</span>] [-m module | scriptfile] [arg] ...</span><br></pre></td></tr></table></figure></p>
<p>然后使用<code>snakeviz</code>来可视化 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">❯ snakeviz program.prof</span><br></pre></td></tr></table></figure></p>
<p>但是snakeviz目前基本不再维护,
mpi的程序可以尝试使用<code>viztracer</code>,
可以通过<code>log_sparse</code>来设定自己感兴趣的区域:
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">❯ mpiexec -n 9  viztracer --pid_suffix --log_sparse --output_dir summa_prof summa.py</span><br><span class="line">❯ viztracer --combine summa_prof/result_*.json -o summa_prof/result.json</span><br><span class="line">❯ vizviewer summa_prof/result.json</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CPP/" rel="tag">CPP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B8%A9%E5%9D%91%E7%BB%8F%E9%AA%8C/" rel="tag">踩坑经验</a></li></ul></div><div class="post-nav"><a class="pre" href="/2021/04/28/ncnn-learn/">ncnn学习</a><a class="next" href="/2021/04/25/cmake-error/">cmake踩坑&amp;爬坑</a></div><script src="https://utteranc.es/client.js" repo="zhen8838/zhen8838.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://zhen8838.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>A Believing Heart Is Your Magic</p><a class="info-icon" href="mailto:597323109@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/zhen8838" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">体系结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%A8%E7%90%86%E6%A1%86%E6%9E%B6/">推理框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E8%AF%91%E5%99%A8/">编译器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/">边缘计算</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%AD%B9%E5%AD%A6/">运筹学</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/%E6%A0%91/" style="font-size: 15px;">树</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/Tensorflow/" style="font-size: 15px;">Tensorflow</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 15px;">树莓派</a> <a href="/tags/%E8%93%9D%E7%89%99/" style="font-size: 15px;">蓝牙</a> <a href="/tags/Matlab/" style="font-size: 15px;">Matlab</a> <a href="/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/" style="font-size: 15px;">遗传算法</a> <a href="/tags/SVM/" style="font-size: 15px;">SVM</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 15px;">链表</a> <a href="/tags/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">半监督学习</a> <a href="/tags/GAN/" style="font-size: 15px;">GAN</a> <a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 15px;">概率论</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/%E9%A6%99%E6%A9%99%E6%B4%BE/" style="font-size: 15px;">香橙派</a> <a href="/tags/%E8%B8%A9%E5%9D%91%E7%BB%8F%E9%AA%8C/" style="font-size: 15px;">踩坑经验</a> <a href="/tags/LeetCode/" style="font-size: 15px;">LeetCode</a> <a href="/tags/Qt/" style="font-size: 15px;">Qt</a> <a href="/tags/%E5%A4%9A%E9%9D%A2%E4%BD%93%E6%A8%A1%E5%9E%8B/" style="font-size: 15px;">多面体模型</a> <a href="/tags/%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/" style="font-size: 15px;">后端优化</a> <a href="/tags/Ampl/" style="font-size: 15px;">Ampl</a> <a href="/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 15px;">图像处理</a> <a href="/tags/K210/" style="font-size: 15px;">K210</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%B3%95/" style="font-size: 15px;">二分法</a> <a href="/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" style="font-size: 15px;">科学上网</a> <a href="/tags/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/" style="font-size: 15px;">损失函数</a> <a href="/tags/cmake/" style="font-size: 15px;">cmake</a> <a href="/tags/CPP/" style="font-size: 15px;">CPP</a> <a href="/tags/Conan/" style="font-size: 15px;">Conan</a> <a href="/tags/OrTools/" style="font-size: 15px;">OrTools</a> <a href="/tags/CSharp/" style="font-size: 15px;">CSharp</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA/" style="font-size: 15px;">数据增强</a> <a href="/tags/VAE/" style="font-size: 15px;">VAE</a> <a href="/tags/%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95/" style="font-size: 15px;">聚类方法</a> <a href="/tags/CostModel/" style="font-size: 15px;">CostModel</a> <a href="/tags/Vscode/" style="font-size: 15px;">Vscode</a> <a href="/tags/%E5%A3%B0%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/" style="font-size: 15px;">声音信号处理</a> <a href="/tags/TVM/" style="font-size: 15px;">TVM</a> <a href="/tags/%E5%8A%A8%E6%80%81shape/" style="font-size: 15px;">动态shape</a> <a href="/tags/%E4%B8%AD%E7%AB%AF%E4%BC%98%E5%8C%96/" style="font-size: 15px;">中端优化</a> <a href="/tags/Equality-Saturation/" style="font-size: 15px;">Equality Saturation</a> <a href="/tags/stm32/" style="font-size: 15px;">stm32</a> <a href="/tags/Keras/" style="font-size: 15px;">Keras</a> <a href="/tags/Halide/" style="font-size: 15px;">Halide</a> <a href="/tags/DSL/" style="font-size: 15px;">DSL</a> <a href="/tags/%E5%A0%86%E6%A0%88/" style="font-size: 15px;">堆栈</a> <a href="/tags/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/" style="font-size: 15px;">大语言模型</a> <a href="/tags/llama/" style="font-size: 15px;">llama</a> <a href="/tags/%E5%BD%92%E4%B8%80%E5%8C%96/" style="font-size: 15px;">归一化</a> <a href="/tags/Makefile/" style="font-size: 15px;">Makefile</a> <a href="/tags/%E5%85%83%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">元学习</a> <a href="/tags/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">模板元编程</a> <a href="/tags/mindspore/" style="font-size: 15px;">mindspore</a> <a href="/tags/LLM/" style="font-size: 15px;">LLM</a> <a href="/tags/tvm/" style="font-size: 15px;">tvm</a> <a href="/tags/mlir/" style="font-size: 15px;">mlir</a> <a href="/tags/%E6%80%A7%E8%83%BD%E5%BB%BA%E6%A8%A1/" style="font-size: 15px;">性能建模</a> <a href="/tags/mxnet/" style="font-size: 15px;">mxnet</a> <a href="/tags/Nand2Tetris/" style="font-size: 15px;">Nand2Tetris</a> <a href="/tags/ncnn/" style="font-size: 15px;">ncnn</a> <a href="/tags/Numpy/" style="font-size: 15px;">Numpy</a> <a href="/tags/PCB/" style="font-size: 15px;">PCB</a> <a href="/tags/%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1/" style="font-size: 15px;">姿态估计</a> <a href="/tags/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/" style="font-size: 15px;">人脸检测</a> <a href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%87%8F%E5%8C%96/" style="font-size: 15px;">神经网络量化</a> <a href="/tags/Yolo/" style="font-size: 15px;">Yolo</a> <a href="/tags/Pytorch/" style="font-size: 15px;">Pytorch</a> <a href="/tags/NB-IOT/" style="font-size: 15px;">NB-IOT</a> <a href="/tags/Retinaface/" style="font-size: 15px;">Retinaface</a> <a href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" style="font-size: 15px;">目标检测</a> <a href="/tags/%E6%8C%87%E4%BB%A4%E9%9B%86/" style="font-size: 15px;">指令集</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 15px;">排序</a> <a href="/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" style="font-size: 15px;">统计学习方法</a> <a href="/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/" style="font-size: 15px;">人脸识别</a> <a href="/tags/%E4%BC%98%E5%8C%96%E5%99%A8/" style="font-size: 15px;">优化器</a> <a href="/tags/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E7%A8%8B/" style="font-size: 15px;">吴恩达课程</a> <a href="/tags/WordCloud/" style="font-size: 15px;">WordCloud</a> <a href="/tags/Zhihu/" style="font-size: 15px;">Zhihu</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8/" style="font-size: 15px;">四轴飞行器</a> <a href="/tags/%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/" style="font-size: 15px;">资源汇总</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 15px;">分布式</a> <a href="/tags/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">无监督学习</a> <a href="/tags/Apple/" style="font-size: 15px;">Apple</a> <a href="/tags/Jittor/" style="font-size: 15px;">Jittor</a> <a href="/tags/Tiramisu/" style="font-size: 15px;">Tiramisu</a> <a href="/tags/Triton/" style="font-size: 15px;">Triton</a> <a href="/tags/vllm/" style="font-size: 15px;">vllm</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/02/14/vllm/">推理框架调研</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/04/distal/">DISTAL: The Distributed Tensor Algebra Compiler</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/04/triton-cpu-lesson-1/">triton-cpu初体验</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/11/07/mesh-matmul/">分布式存储架构下的矩阵乘与编译器</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/08/08/mlc-tutorial/">机器学习编译概念科普</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/08/08/benchmark-notes/">benchmark的经验与技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/06/14/ampl-learn/">Ampl学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/05/08/constraints-solver-internals/">Constraints Solver Internals</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/30/model-driven-optimization/">Model Driven Optimization</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/04/23/mac-amx/">探索AMX: 解锁Apple Silicon隐藏性能</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Zheng's Notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0"></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/latest/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>