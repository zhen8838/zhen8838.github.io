<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2022-08-14">

<title>Polyhedral Tutorials – Zheng’s Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../assets/favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-8b4baf804e461d9b72633f0de59a0cac.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-7072389654d23eff08f359f9aa0d1ee7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Zheng’s Notes</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#quasi-affine-expressions" id="toc-quasi-affine-expressions" class="nav-link active" data-scroll-target="#quasi-affine-expressions">(Quasi) Affine Expressions</a>
  <ul class="collapse">
  <li><a href="#examples" id="toc-examples" class="nav-link" data-scroll-target="#examples">Examples</a></li>
  </ul></li>
  <li><a href="#presburger-formula" id="toc-presburger-formula" class="nav-link" data-scroll-target="#presburger-formula">Presburger Formula</a>
  <ul class="collapse">
  <li><a href="#examples-1" id="toc-examples-1" class="nav-link" data-scroll-target="#examples-1">Examples</a></li>
  </ul></li>
  <li><a href="#presburger-sets" id="toc-presburger-sets" class="nav-link" data-scroll-target="#presburger-sets">Presburger Sets</a>
  <ul class="collapse">
  <li><a href="#basic-set" id="toc-basic-set" class="nav-link" data-scroll-target="#basic-set">Basic Set</a>
  <ul class="collapse">
  <li><a href="#examples-2" id="toc-examples-2" class="nav-link" data-scroll-target="#examples-2">Examples</a></li>
  </ul></li>
  <li><a href="#sparse-basic-sets" id="toc-sparse-basic-sets" class="nav-link" data-scroll-target="#sparse-basic-sets">Sparse Basic Sets</a>
  <ul class="collapse">
  <li><a href="#example" id="toc-example" class="nav-link" data-scroll-target="#example">Example</a></li>
  </ul></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises">Exercises</a></li>
  </ul></li>
  <li><a href="#sets" id="toc-sets" class="nav-link" data-scroll-target="#sets">Sets</a></li>
  <li><a href="#union-set" id="toc-union-set" class="nav-link" data-scroll-target="#union-set">Union Set</a></li>
  <li><a href="#presburger-relations" id="toc-presburger-relations" class="nav-link" data-scroll-target="#presburger-relations">Presburger Relations</a>
  <ul class="collapse">
  <li><a href="#basic-map" id="toc-basic-map" class="nav-link" data-scroll-target="#basic-map">Basic Map</a>
  <ul class="collapse">
  <li><a href="#example-1" id="toc-example-1" class="nav-link" data-scroll-target="#example-1">Example</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#polyhedral-representation" id="toc-polyhedral-representation" class="nav-link" data-scroll-target="#polyhedral-representation">Polyhedral Representation</a>
  <ul class="collapse">
  <li><a href="#statement-instances" id="toc-statement-instances" class="nav-link" data-scroll-target="#statement-instances">Statement instances</a></li>
  <li><a href="#iteration-domain" id="toc-iteration-domain" class="nav-link" data-scroll-target="#iteration-domain">Iteration domain</a>
  <ul class="collapse">
  <li><a href="#question" id="toc-question" class="nav-link" data-scroll-target="#question">Question</a></li>
  <li><a href="#question-1" id="toc-question-1" class="nav-link" data-scroll-target="#question-1">Question</a></li>
  </ul></li>
  <li><a href="#handling-non-unit-strides" id="toc-handling-non-unit-strides" class="nav-link" data-scroll-target="#handling-non-unit-strides">Handling Non-Unit Strides</a>
  <ul class="collapse">
  <li><a href="#question-2" id="toc-question-2" class="nav-link" data-scroll-target="#question-2">Question</a></li>
  </ul></li>
  <li><a href="#handling-conditions" id="toc-handling-conditions" class="nav-link" data-scroll-target="#handling-conditions">Handling Conditions</a>
  <ul class="collapse">
  <li><a href="#question-3" id="toc-question-3" class="nav-link" data-scroll-target="#question-3">Question</a></li>
  <li><a href="#question-4" id="toc-question-4" class="nav-link" data-scroll-target="#question-4">Question</a></li>
  </ul></li>
  <li><a href="#iteration-domains-as-presburger-sets" id="toc-iteration-domains-as-presburger-sets" class="nav-link" data-scroll-target="#iteration-domains-as-presburger-sets">Iteration Domains as Presburger Sets</a>
  <ul class="collapse">
  <li><a href="#question-5" id="toc-question-5" class="nav-link" data-scroll-target="#question-5">Question</a></li>
  <li><a href="#section" id="toc-section" class="nav-link" data-scroll-target="#section"></a></li>
  </ul></li>
  <li><a href="#putting-domains-together" id="toc-putting-domains-together" class="nav-link" data-scroll-target="#putting-domains-together">Putting Domains Together</a></li>
  <li><a href="#plotting-iteration-domains" id="toc-plotting-iteration-domains" class="nav-link" data-scroll-target="#plotting-iteration-domains">Plotting Iteration Domains</a>
  <ul class="collapse">
  <li><a href="#question-6" id="toc-question-6" class="nav-link" data-scroll-target="#question-6">Question</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#schedules" id="toc-schedules" class="nav-link" data-scroll-target="#schedules">Schedules</a>
  <ul class="collapse">
  <li><a href="#definition" id="toc-definition" class="nav-link" data-scroll-target="#definition">Definition</a></li>
  <li><a href="#identity-schedule" id="toc-identity-schedule" class="nav-link" data-scroll-target="#identity-schedule">Identity Schedule</a></li>
  <li><a href="#multidimensional-schedules" id="toc-multidimensional-schedules" class="nav-link" data-scroll-target="#multidimensional-schedules">Multidimensional Schedules</a>
  <ul class="collapse">
  <li><a href="#question-7" id="toc-question-7" class="nav-link" data-scroll-target="#question-7">Question</a></li>
  <li><a href="#question-8" id="toc-question-8" class="nav-link" data-scroll-target="#question-8">Question</a></li>
  </ul></li>
  <li><a href="#representing-lexical-order" id="toc-representing-lexical-order" class="nav-link" data-scroll-target="#representing-lexical-order">Representing Lexical Order</a>
  <ul class="collapse">
  <li><a href="#section-1" id="toc-section-1" class="nav-link" data-scroll-target="#section-1"></a></li>
  <li><a href="#question-9" id="toc-question-9" class="nav-link" data-scroll-target="#question-9">Question</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#modeling-memory-accesses" id="toc-modeling-memory-accesses" class="nav-link" data-scroll-target="#modeling-memory-accesses">Modeling memory accesses</a>
  <ul class="collapse">
  <li><a href="#access-relations" id="toc-access-relations" class="nav-link" data-scroll-target="#access-relations">Access Relations</a>
  <ul class="collapse">
  <li><a href="#question-10" id="toc-question-10" class="nav-link" data-scroll-target="#question-10">Question</a></li>
  <li><a href="#question-11" id="toc-question-11" class="nav-link" data-scroll-target="#question-11">Question</a></li>
  </ul></li>
  <li><a href="#detecting-out-of-bounds-accesses" id="toc-detecting-out-of-bounds-accesses" class="nav-link" data-scroll-target="#detecting-out-of-bounds-accesses">Detecting Out-of-Bounds Accesses</a>
  <ul class="collapse">
  <li><a href="#question-12" id="toc-question-12" class="nav-link" data-scroll-target="#question-12">Question</a></li>
  </ul></li>
  <li><a href="#potentially-dependent-instances" id="toc-potentially-dependent-instances" class="nav-link" data-scroll-target="#potentially-dependent-instances">Potentially Dependent Instances</a>
  <ul class="collapse">
  <li><a href="#question-13" id="toc-question-13" class="nav-link" data-scroll-target="#question-13">Question</a></li>
  </ul></li>
  <li><a href="#reads-and-writes" id="toc-reads-and-writes" class="nav-link" data-scroll-target="#reads-and-writes">Reads and Writes</a>
  <ul class="collapse">
  <li><a href="#question-14" id="toc-question-14" class="nav-link" data-scroll-target="#question-14">Question</a></li>
  </ul></li>
  <li><a href="#selecting-one-write" id="toc-selecting-one-write" class="nav-link" data-scroll-target="#selecting-one-write">Selecting one Write</a>
  <ul class="collapse">
  <li><a href="#question-15" id="toc-question-15" class="nav-link" data-scroll-target="#question-15">Question</a></li>
  <li><a href="#question-16" id="toc-question-16" class="nav-link" data-scroll-target="#question-16">Question:</a></li>
  <li><a href="#section-2" id="toc-section-2" class="nav-link" data-scroll-target="#section-2"></a></li>
  <li><a href="#question-17" id="toc-question-17" class="nav-link" data-scroll-target="#question-17">Question</a></li>
  </ul></li>
  <li><a href="#visualizing-potentially-dependent-instances" id="toc-visualizing-potentially-dependent-instances" class="nav-link" data-scroll-target="#visualizing-potentially-dependent-instances">Visualizing Potentially Dependent Instances</a>
  <ul class="collapse">
  <li><a href="#question-18" id="toc-question-18" class="nav-link" data-scroll-target="#question-18">Question</a></li>
  <li><a href="#question-19" id="toc-question-19" class="nav-link" data-scroll-target="#question-19">Question</a></li>
  <li><a href="#question-20" id="toc-question-20" class="nav-link" data-scroll-target="#question-20">Question</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#dependence-analysis" id="toc-dependence-analysis" class="nav-link" data-scroll-target="#dependence-analysis">Dependence Analysis</a>
  <ul class="collapse">
  <li><a href="#plugging-in-schedule-information" id="toc-plugging-in-schedule-information" class="nav-link" data-scroll-target="#plugging-in-schedule-information">Plugging in Schedule Information</a>
  <ul class="collapse">
  <li><a href="#question-21" id="toc-question-21" class="nav-link" data-scroll-target="#question-21">Question</a></li>
  <li><a href="#question-22" id="toc-question-22" class="nav-link" data-scroll-target="#question-22">Question</a></li>
  </ul></li>
  <li><a href="#memory-based-dependence-analysis" id="toc-memory-based-dependence-analysis" class="nav-link" data-scroll-target="#memory-based-dependence-analysis">Memory-based Dependence Analysis</a>
  <ul class="collapse">
  <li><a href="#flow-dependences" id="toc-flow-dependences" class="nav-link" data-scroll-target="#flow-dependences">Flow Dependences</a></li>
  <li><a href="#question-23" id="toc-question-23" class="nav-link" data-scroll-target="#question-23">Question</a></li>
  <li><a href="#anti-and-output-dependences" id="toc-anti-and-output-dependences" class="nav-link" data-scroll-target="#anti-and-output-dependences">Anti and Output Dependences</a></li>
  <li><a href="#question-input-dependences" id="toc-question-input-dependences" class="nav-link" data-scroll-target="#question-input-dependences">Question: Input Dependences</a></li>
  <li><a href="#question-24" id="toc-question-24" class="nav-link" data-scroll-target="#question-24">Question</a></li>
  </ul></li>
  <li><a href="#value-based-analysis" id="toc-value-based-analysis" class="nav-link" data-scroll-target="#value-based-analysis">Value-based Analysis</a>
  <ul class="collapse">
  <li><a href="#question-25" id="toc-question-25" class="nav-link" data-scroll-target="#question-25">Question</a></li>
  <li><a href="#section-3" id="toc-section-3" class="nav-link" data-scroll-target="#section-3"></a></li>
  <li><a href="#question-26" id="toc-question-26" class="nav-link" data-scroll-target="#question-26">Question</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#classical-loop-transformations" id="toc-classical-loop-transformations" class="nav-link" data-scroll-target="#classical-loop-transformations">Classical Loop Transformations</a>
  <ul class="collapse">
  <li><a href="#setup-ast-generation-infrastructure" id="toc-setup-ast-generation-infrastructure" class="nav-link" data-scroll-target="#setup-ast-generation-infrastructure">Setup AST generation infrastructure</a></li>
  <li><a href="#loop-reversal" id="toc-loop-reversal" class="nav-link" data-scroll-target="#loop-reversal">Loop Reversal</a></li>
  </ul></li>
  <li><a href="#loop-fusion" id="toc-loop-fusion" class="nav-link" data-scroll-target="#loop-fusion">Loop Fusion</a></li>
  <li><a href="#loop-fission-loop-distribution" id="toc-loop-fission-loop-distribution" class="nav-link" data-scroll-target="#loop-fission-loop-distribution">Loop Fission (Loop Distribution)</a></li>
  <li><a href="#loop-interchange" id="toc-loop-interchange" class="nav-link" data-scroll-target="#loop-interchange">Loop Interchange</a></li>
  <li><a href="#strip-mining" id="toc-strip-mining" class="nav-link" data-scroll-target="#strip-mining">Strip Mining</a></li>
  <li><a href="#loop-tiling" id="toc-loop-tiling" class="nav-link" data-scroll-target="#loop-tiling">Loop Tiling</a></li>
  <li><a href="#unroll-and-jam" id="toc-unroll-and-jam" class="nav-link" data-scroll-target="#unroll-and-jam">Unroll-and-jam</a></li>
  <li><a href="#skewing" id="toc-skewing" class="nav-link" data-scroll-target="#skewing">Skewing</a></li>
  <li><a href="#ast-generation" id="toc-ast-generation" class="nav-link" data-scroll-target="#ast-generation">AST Generation</a>
  <ul class="collapse">
  <li><a href="#generate-an-ast" id="toc-generate-an-ast" class="nav-link" data-scroll-target="#generate-an-ast">Generate an AST</a>
  <ul class="collapse">
  <li><a href="#define-a-simple-polyhedral-program-description" id="toc-define-a-simple-polyhedral-program-description" class="nav-link" data-scroll-target="#define-a-simple-polyhedral-program-description">Define a simple polyhedral program description</a></li>
  </ul></li>
  <li><a href="#translate-polyhedral-program-description-to-an-ast" id="toc-translate-polyhedral-program-description-to-an-ast" class="nav-link" data-scroll-target="#translate-polyhedral-program-description-to-an-ast">Translate polyhedral program description to an AST</a></li>
  <li><a href="#ast-generation-for-constraint-sets" id="toc-ast-generation-for-constraint-sets" class="nav-link" data-scroll-target="#ast-generation-for-constraint-sets">AST Generation for Constraint Sets</a></li>
  <li><a href="#a-simple-constraint-set" id="toc-a-simple-constraint-set" class="nav-link" data-scroll-target="#a-simple-constraint-set">A simple constraint set</a></li>
  <li><a href="#recovery-of-modulo-expressions" id="toc-recovery-of-modulo-expressions" class="nav-link" data-scroll-target="#recovery-of-modulo-expressions">Recovery of modulo expressions</a></li>
  <li><a href="#verification-of-complex-conditions" id="toc-verification-of-complex-conditions" class="nav-link" data-scroll-target="#verification-of-complex-conditions">Verification of complex conditions</a></li>
  </ul></li>
  <li><a href="#parse-c-code" id="toc-parse-c-code" class="nav-link" data-scroll-target="#parse-c-code">Parse C Code</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Polyhedral Tutorials</h1>
  <div class="quarto-categories">
    <div class="quarto-category">编译器</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 14, 2022</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>关于<a href="http://playground.pollylabs.org">Polyhedral Tutorials</a>的一个中文翻译归档,其中所有章节原文位于我的<a href="https://github.com/zhen8838/isl_learn">仓库</a>中.</p>
<!--more-->
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> islpy <span class="im">as</span> isl</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> islplot</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> islplot.plotter <span class="im">import</span> plot_set_points</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<section id="quasi-affine-expressions" class="level1">
<h1>(Quasi) Affine Expressions</h1>
<p>Quasi-affine表达式, 即通过常量、变量以及对应基础操作构成的表达式.</p>
<p><strong>Base</strong> - Constants (<span class="math inline">\((c_i)\)</span>) - Parameters (<span class="math inline">\((p_i)\)</span>) - Variables (<span class="math inline">\((v_i)\)</span>)</p>
<p><strong>Operations</strong> - Unary negation <span class="math inline">\(( (-e) )\)</span> - Addition <span class="math inline">\(( ( e\_0 + e\_1 ) )\)</span> - Multiplication by a constant <span class="math inline">\(( (c * e) )\)</span> - Constant division <span class="math inline">\(( (e / c) )\)</span> - Constant remainder <span class="math inline">\(( (e \mod c) )\)</span></p>
<section id="examples" class="level3">
<h3 class="anchored" data-anchor-id="examples">Examples</h3>
<section id="valid-expressions" class="level4">
<h4 class="anchored" data-anchor-id="valid-expressions">Valid Expressions</h4>
<ul>
<li>42</li>
<li>n, m</li>
<li>i, j</li>
<li>-i, 3 * i + 4</li>
<li>i / 2, i % 3 ****</li>
</ul>
</section>
<section id="invalid-expressions" class="level4">
<h4 class="anchored" data-anchor-id="invalid-expressions">Invalid Expressions</h4>
<ul>
<li>i * n, n * m</li>
<li>5 / n, i % j</li>
</ul>
</section>
</section>
</section>
<section id="presburger-formula" class="level1">
<h1>Presburger Formula</h1>
<p>Presburger 公式就是affine表达式进行二元关系组合:</p>
<p><strong>Base</strong> - Boolean constants (⊤, ⊥)</p>
<p><strong>Operations</strong> - Comparisions between quasi-affine expressions</p>
<p><span class="math inline">\((e0 \oplus e1, \oplus \in)\)</span> <span class="math inline">\(\{(&lt;, \le, =, \ne, \ge, &gt;) \}\)</span></p>
<ul>
<li><p>Boolean operations between Presburger Formulas</p>
<p><span class="math inline">\((e0 \otimes e1, \otimes \in)\)</span> <span class="math inline">\(\{(\land, \lor, not, \Rightarrow, \Leftarrow, \Leftrightarrow ) \}\)</span></p></li>
<li><p>Quantified variables</p>
<p><span class="math inline">\(( \exists x: p(x, ...) )\)</span></p>
<p><span class="math inline">\(( \forall x: p(x, ...) )\)</span></p></li>
</ul>
<section id="examples-1" class="level3">
<h3 class="anchored" data-anchor-id="examples-1">Examples</h3>
<section id="valid-expressions-1" class="level4">
<h4 class="anchored" data-anchor-id="valid-expressions-1">Valid Expressions</h4>
<ul>
<li><span class="math inline">\(1 &lt; 0\)</span></li>
<li><span class="math inline">\((j + 3 \le 0 \land 0 \le n)\)</span></li>
</ul>
</section>
<section id="invalid-expressions-1" class="level4">
<h4 class="anchored" data-anchor-id="invalid-expressions-1">Invalid Expressions</h4>
<ul>
<li>42</li>
</ul>
</section>
</section>
</section>
<section id="presburger-sets" class="level1">
<h1>Presburger Sets</h1>
<p>Presburger 集合S, 是一个通过Presburger公式定义的整数向量集合. 通常<span class="math inline">\(p\)</span>作为Presburger公式会被执行为true, 然后<span class="math inline">\((\vec{v})\)</span>则是集合包含的所有元素.</p>
<section id="basic-set" class="level2">
<h2 class="anchored" data-anchor-id="basic-set">Basic Set</h2>
<p>Basic Set 是 Presburger Set的最简单形式,仅允许描述单个凸（但可能是稀疏）集的 Presburger 公式.</p>
<p>集合的<strong>space</strong>被tuple的维度定义.一个集合包含pair被称为2维space.</p>
<section id="examples-2" class="level3">
<h3 class="anchored" data-anchor-id="examples-2">Examples</h3>
<p>以下两个基本集合 <strong>Triangle</strong> 和 <strong>Square</strong> :</p>
<ul>
<li><p>Triangle: <span class="math inline">\((\{A[i,j] \mid 0 &lt; i &lt; j &lt; 10\})\)</span></p></li>
<li><p>Square: <span class="math inline">\((\{ A[i,j] \mid 5 &lt; i &lt; 10 \land 0 &lt; j &lt; 5 \})\)</span></p></li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>Triangle <span class="op">=</span> isl.BasicSet(<span class="st">"{A[i,j] : 0 &lt; i &lt; j &lt; 10}"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>Square <span class="op">=</span> isl.BasicSet(<span class="st">"{A[i,j] : 5 &lt; i &lt; 10 and 0 &lt; j &lt; 5}"</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>plot_set_points(Triangle,color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>plot_set_points(Square,color<span class="op">=</span><span class="st">'orange'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/01_presburger_sets_6_0.png" class="img-fluid"></p>
</section>
</section>
<section id="sparse-basic-sets" class="level2">
<h2 class="anchored" data-anchor-id="sparse-basic-sets">Sparse Basic Sets</h2>
<p>这个例子中展示了集合中存在取模约束,这样集合元素会变成稀疏的.</p>
<section id="example" class="level3">
<h3 class="anchored" data-anchor-id="example">Example</h3>
<p>basic set <strong>Sparse</strong> 是排除某些对角线的正方形.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>Sparse <span class="op">=</span> isl.BasicSet(<span class="st">"{A[i,j] : 0 &lt; i,j &lt; 10 and (i + j) % 3 != 0}"</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>plot_set_points(Sparse,color<span class="op">=</span><span class="st">'blue'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/01_presburger_sets_8_0.png" class="img-fluid"></p>
</section>
</section>
<section id="exercises" class="level2">
<h2 class="anchored" data-anchor-id="exercises">Exercises</h2>
<ol type="a">
<li>Plot a set <strong>UpperTriangle</strong> with a base of width 7.</li>
</ol>
<pre><code>       x
     x x x
   x x x x x
 x x x x x x x</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> isl.BasicSet(<span class="st">"{A[x,y] : 0 &lt;= x &lt; 7 and 0 &lt;= y &lt; 4 and y &lt;= x &lt; 7-y }"</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>plot_set_points(s,color<span class="op">=</span><span class="st">'blue'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/01_presburger_sets_10_0.png" class="img-fluid"></p>
<ol start="2" type="a">
<li>Plot a set <strong>LowerTriangle</strong> with a base of width 7</li>
</ol>
<pre><code>x x x x x x x
  x x x x x
    x x x
      x</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> isl.BasicSet(<span class="st">"{A[x,y] : 0 &lt;= x &lt; 7 and -4 &lt; y &lt;= 0 and  (-y) &lt;= x &lt; 7+y }"</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>plot_set_points(s,color<span class="op">=</span><span class="st">'blue'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/01_presburger_sets_12_0.png" class="img-fluid"></p>
<ol start="3" type="a">
<li>Plot a set <strong>Diamond</strong> with a width and height of 7.</li>
</ol>
<pre><code>       x
     x x x
   x x x x x
 x x x x x x x
   x x x x x
     x x x
       x</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> isl.BasicSet(<span class="st">"{A[x,y] : 0 &lt;= x &lt; 7 and -4 &lt; y &lt; 4 and (-y) &lt;= x &lt; 7+y and y &lt;= x &lt; 7-y }"</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>plot_set_points(s,color<span class="op">=</span><span class="st">'blue'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/01_presburger_sets_14_0.png" class="img-fluid"></p>
<ol start="4" type="a">
<li>Plot a set <strong>Parallelogram</strong> with a height of 4 and a width of 7 with a slope of 1/2.</li>
</ol>
<pre><code>      x x x x x x x
    x x x x x x x  
  x x x x x x x
x x x x x x x</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> isl.BasicSet(<span class="st">"{A[x,y] : 0 &lt;= y &lt; 4 and y &lt;= x &lt; y + 7 }"</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>plot_set_points(s,color<span class="op">=</span><span class="st">'blue'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/01_presburger_sets_16_0.png" class="img-fluid"></p>
</section>
</section>
<section id="sets" class="level1">
<h1>Sets</h1>
<p>集合是有限的基础集合的联合, 他们都属于相同的named space中, 也就是他们的标识维度名都相同.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>Combined <span class="op">=</span> Triangle.union(Square)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Combined: "</span> <span class="op">+</span> <span class="bu">str</span>(Combined))</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>plot_set_points(Combined,color<span class="op">=</span><span class="st">'blue'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Combined: { A[i, j] : i &gt; 0 and j &lt;= 9 and (j &gt; i or (6 &lt;= i &lt;= 9 and 0 &lt; j &lt;= 4)) }</code></pre>
<p><img src="polyherdal-playground/01_presburger_sets_18_1.png" class="img-fluid"></p>
</section>
<section id="union-set" class="level1">
<h1>Union Set</h1>
<p>不同named spaces的有限集合组成的是union set.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> isl.UnionSet(<span class="st">"{A[i,j] : 0 &lt; i,j and  j + i &lt; 10; B[i,j] : 5 &lt;= i,j &lt; 10 }"</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>plot_set_points(u,color<span class="op">=</span><span class="st">'blue'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/01_presburger_sets_20_0.png" class="img-fluid"></p>
</section>
<section id="presburger-relations" class="level1">
<h1>Presburger Relations</h1>
<p>Presburger Relations 是一种映射关系, 将多个Presburger formula描述的set映射起来.</p>
<p>通常可以表示为M = <span class="math inline">\(( \{ \vec{v_1} \rightarrow \vec{v\_2} \mid \vec{v\_1}, \vec{v\_2} \in \mathbb{Z}^n : p (\vec{v\_1}, \vec{v\_2}, \vec{p})\} )\)</span>,其中<code>p</code>是一个 Presburger 公式, 如果元组对 <span class="math inline">\((\vec{v\_1})\)</span> 和 <span class="math inline">\((\vec{v\_2})\)</span> 是 M 的元素, 则计算结果为真.</p>
<section id="basic-map" class="level2">
<h2 class="anchored" data-anchor-id="basic-map">Basic Map</h2>
<p>basic map关联了basic set.</p>
<section id="example-1" class="level3">
<h3 class="anchored" data-anchor-id="example-1">Example</h3>
<p>比如下面关联set A和position X.</p>
<p>Translate = <span class="math inline">\((\{A[i,j] \rightarrow X[i+10,j+1]\})\)</span></p>
<p>To visualize this set, we use it to translate the earlier defined set <strong>Triangle</strong>. Without constraining <strong>Translate</strong> to <strong>Triangle</strong> the map is infinite and cannot be rendered.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> islplot.plotter <span class="im">import</span> <span class="op">*</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>Translate <span class="op">=</span> isl.BasicMap(<span class="st">"{A[i,j] -&gt; X[i+10,j+1]}"</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>b  <span class="op">=</span> Triangle.<span class="bu">apply</span>(Translate)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>Translate <span class="op">=</span> Translate.intersect_domain(Triangle)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>plot_map(Translate)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>plot_set_points(Triangle,color<span class="op">=</span><span class="st">'blue'</span>)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>plot_set_points(b,color<span class="op">=</span><span class="st">'orange'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/01_presburger_sets_23_0.png" class="img-fluid"></p>
</section>
</section>
</section>
<section id="polyhedral-representation" class="level1">
<h1>Polyhedral Representation</h1>
<p>将一个命令式语言的statement作为identifer, 加上loop的约束, 将其转化为Union Set :</p>
<br>
<center>
<table>
<tbody><tr>
<td>
<center>
<b>Imperative Program</b>
</center>
</td>
<td>
</td>
<td>
<center>
<b>Iteration Domain</b>
</center>
</td></tr>
<tr>
<td>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb16"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> N <span class="op">=</span> <span class="dv">100</span><span class="op">;</span> </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> X<span class="op">[</span>N<span class="op">],</span> Y<span class="op">[</span>N<span class="op">],</span> Z<span class="op">[</span><span class="dv">2</span><span class="op">*</span>N<span class="op">];</span> </span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&amp;</span>lt<span class="op">;=</span> <span class="dv">2</span><span class="op">*</span>N<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>S<span class="op">:</span>  Z<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span> </span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&amp;</span>lt<span class="op">;=</span> N<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> </span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&amp;</span>lt<span class="op">;=</span> N<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> </span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>T<span class="op">:</span>    Z<span class="op">[</span>i <span class="op">+</span> j<span class="op">]</span> <span class="op">+=</span> A<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> B<span class="op">[</span>j<span class="op">];</span> </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</td>
<td>
<p>$ $</p>
</td>
<td>
<center>
<p><br></p>
<p><span class="math inline">\(( \{ T[i,j] \mid 0 &lt; i \le j &lt; 10; S[i,0] \mid 0 &lt; i \le 20 \})\)</span></p>
</center></td>
</tr>
</tbody></table>
</center>
<p><br></p>
<section id="statement-instances" class="level2">
<h2 class="anchored" data-anchor-id="statement-instances">Statement instances</h2>
<p>考虑以下计算多项式乘积的代码片段 每个多项式都由其系数数组表示</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb17"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> N <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> X<span class="op">[</span>N<span class="op">],</span> Y<span class="op">[</span>N<span class="op">],</span> Z<span class="op">[</span><span class="dv">2</span><span class="op">*</span>N<span class="op">];</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">2</span><span class="op">*</span>N<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>S<span class="op">:</span>  Z<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> N<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> N<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>T<span class="op">:</span>      Z<span class="op">[</span>i <span class="op">+</span> j<span class="op">]</span> <span class="op">+=</span> A<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> B<span class="op">[</span>j<span class="op">];</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>为其中一些statement添加label作为identifier.</p>
<p>Statement <code>S</code> 初始化数组<code>Z</code>的元素,statement <code>T</code>计算它们. Statement <code>S</code> 被包含在循环中,他将会按以下顺序被执行 <span class="math inline">\(((2\mathtt{N} + 1))\)</span> 次:</p>
<ul>
<li><code>Z[0] = 0.; /* i = 0 */</code></li>
<li><code>Z[1] = 0.; /* i = 1 */</code></li>
<li>…</li>
<li><code>Z[2*N] = 0. /* i = 2*N */;</code></li>
</ul>
<p>把循环中每个单独执行的statement称为 <strong>statement instances</strong> 这样每个instance可以通过语句label和封闭循环迭代器的值来标识, 例如：</p>
<ul>
<li><span class="math inline">\((\mathtt{S}(0))\)</span></li>
<li><span class="math inline">\((\mathtt{S}(1))\)</span></li>
<li>…</li>
<li><span class="math inline">\((\mathtt{S}(2 \mathtt{N}))\)</span></li>
</ul>
<p>如果一个statement包含在多个循环中, 其instance由所有迭代器的值按循环的顺序来标识, 比如statement <code>T</code> 会包含以下这些例子:</p>
<ul>
<li><span class="math inline">\((\mathtt{T}(0,0))\)</span> for <code>Z[0] += A[0] * B[0] /* i = 0, j = 0 */</code>,</li>
<li><span class="math inline">\((\mathtt{T}(0,1))\)</span> for <code>Z[1] += A[0] * B[1] /* i = 0, j = 1 */</code>,</li>
<li>…</li>
<li><span class="math inline">\((\mathtt{T}(\mathtt{N},\mathtt{N}))\)</span> for <code>Z[2*N] += A[N] * B[N] /* i = N, j = N */</code>.</li>
</ul>
</section>
<section id="iteration-domain" class="level2">
<h2 class="anchored" data-anchor-id="iteration-domain">Iteration domain</h2>
<p>一个statement的所有instance的集合被称为 <em>(iteration) domain</em>.</p>
<p>迭代域可以使用 set-builder 表示法来表示:</p>
<p>比如, <span class="math inline">\(( \mathcal{D}_\mathtt{S} = \{ \mathtt{S}[i] : 0 \leq i \leq \mathtt{N} \}. )\)</span> 表达式 <span class="math inline">\(( 0 \leq i \leq \mathtt{N} )\)</span> 被循环起始(<code>i=0</code>)到结束(<code>i&lt;=N</code>)所约束.</p>
<p>注意, 这里 <span class="math inline">\(( \mathtt{N} )\)</span> 被看作是符号常量. 在多面体模型中,这些符号常量通常被称为 <em>(structure) parameters</em>:</p>
<p><span class="math inline">\(( \mathcal{D}\_\mathtt{S} = [N] \rightarrow \{ \mathtt{S}[i] : 0 \leq i \leq N \} )\)</span>, 本质上是将其转换为从参数值到domain set的具体instance的映射. 这样的参数集可以在 <em>isl</em> 中如下定义:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> islpy <span class="im">as</span> isl</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>D_S <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; {S[i] : 0 &lt;= i &lt;= N}"</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D_S)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[N] -&gt; { S[i] : 0 &lt;= i &lt;= N }</code></pre>
<p>同样, 我们可以为statement <code>T</code>定义iteration domain, <span class="math inline">\(( \mathcal{D}_\mathcal{T} = [N] \rightarrow \{ \mathtt{T}(i,j) : 0 \leq i,j \leq N \} )\)</span>.</p>
<p>这个domain被定义为一组二维向量, 向量的每个分量都以嵌套顺序对应于一个封闭循环.</p>
<section id="question" class="level3">
<h3 class="anchored" data-anchor-id="question">Question</h3>
<p>使用 <em>isl</em> 表示定义变量 <code>D_T</code> 使其包含 <code>T</code> 的迭代域, 然后打印它.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>D_T <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; { T[i,j] : 0 &lt;= i, j &lt;= N }"</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D_T)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[N] -&gt; { T[i, j] : 0 &lt;= i &lt;= N and 0 &lt;= j &lt;= N }</code></pre>
<p>如上所示, <em>isl</em> 输出使用连词(logical <em>and</em>)来组合不同迭代器周围的不等式, 这可以很方便循环边界不同的情况.</p>
</section>
<section id="question-1" class="level3">
<h3 class="anchored" data-anchor-id="question-1">Question</h3>
<p>使用 <code>and</code> operator 分离 <code>i</code> 和 <code>j</code>的bounds来重新定义<code>D_T</code> .</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>D_T <span class="op">=</span> isl.Set(<span class="st">" [N] -&gt; { T[i, j] : 0 &lt;= i &lt;= N and 0 &lt;= j &lt;= N }"</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D_T)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[N] -&gt; { T[i, j] : 0 &lt;= i &lt;= N and 0 &lt;= j &lt;= N }</code></pre>
<p>注意, print的输出不一定再现输入的文本形式 相反, 它表示简化后的同一集合, 比如消除了多余的不等式, 并使用更简单的方程来表示出现在第一位的分量. 比如下面这个例子:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(isl.Set(<span class="st">"{[i,j]: i+j &gt;= 0 and i &gt;= 0 and j &gt; 0 and j &gt;= 1}"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ [i, j] : i &gt;= 0 and j &gt; 0 and j &gt;= -i }</code></pre>
</section>
</section>
<section id="handling-non-unit-strides" class="level2">
<h2 class="anchored" data-anchor-id="handling-non-unit-strides">Handling Non-Unit Strides</h2>
<p>考虑以下代码片段, 它取数组中的每个奇数元素的负数.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb26"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> N<span class="op">;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> A<span class="op">[</span><span class="dv">2</span><span class="op">*</span>N<span class="op">];</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">*</span>N<span class="op">;</span> i <span class="op">+=</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>R<span class="op">:</span>  A<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span>A<span class="op">[</span>i<span class="op">];</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>如果数组<code>A</code>存储的是复数的实部和虚部, 那么上面的代码操作计算复共轭.</p>
<p><code>R</code> 的迭代域现在应该限制为 <code>i</code> 的奇数值, 这可以使用模运算符来实现:</p>
<p>$( _: [N] { [i] : 0 i &lt; N i = 1 } $)</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>D_R <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; {R[i]: (i mod 2) = 1 and 0 &lt;= i &lt; N}"</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D_R)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[N] -&gt; { R[i] : (1 + i) mod 2 = 0 and 0 &lt;= i &lt; N }</code></pre>
<p><em>isl</em> 将模运算转换为带底舍入的除法, 这种转换是模运算的两个属性的组合</p>
<p><span class="math inline">\(( a \mod b = c \Leftrightarrow (a + c) \mod b = 0 )\)</span>,</p>
<p><span class="math inline">\(( a \mod b \equiv a - b \lfloor a/b \rfloor )\)</span>.</p>
<section id="question-2" class="level3">
<h3 class="anchored" data-anchor-id="question-2">Question</h3>
<p>在下面的代码中定义代表<code>Q</code>的迭代域的集合, 然后打印出来</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> N<span class="op">;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> A<span class="op">[</span><span class="dv">2</span><span class="op">*</span>N<span class="op">];</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">*</span>N<span class="op">;</span> i <span class="op">+=</span> <span class="dv">2</span><span class="op">)</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>Q<span class="op">:</span>  A<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span>A<span class="op">[</span>i<span class="op">];</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>D_Q <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; {Q[i]: (i mod 2) = 1 and 0 &lt;= i &lt; N}"</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D_Q)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[N] -&gt; { Q[i] : (1 + i) mod 2 = 0 and 0 &lt;= i &lt; N }</code></pre>
</section>
</section>
<section id="handling-conditions" class="level2">
<h2 class="anchored" data-anchor-id="handling-conditions">Handling Conditions</h2>
<p>循环内的条件构造也限制了它们所包含的语句的迭代域, 复共轭计算也可以使用单位步长循环内的分支语句来重写.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb32"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> N<span class="op">;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> A<span class="op">[</span><span class="dv">2</span><span class="op">*</span>N<span class="op">];</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2</span><span class="op">*</span>N<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>P<span class="op">:</span>    A<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">-</span>A<span class="op">[</span>i<span class="op">];</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>迭代域的定义还应该包括语句周围的分支所施加的约束.</p>
<section id="question-3" class="level3">
<h3 class="anchored" data-anchor-id="question-3">Question</h3>
<p>定义代表<code>P</code>的迭代域的集合并打印它.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>D_P <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; {P[i]: (i mod 2) = 1 and 0 &lt;= i &lt; N}"</span>)</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D_P)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[N] -&gt; { P[i] : (1 + i) mod 2 = 0 and 0 &lt;= i &lt; N }</code></pre>
<p>即使 <code>P</code> 和 <code>R</code> 的语句实例集是相同的, 这些域也会被认为是不同的因为是不同的<em>statement name</em>.</p>
</section>
<section id="question-4" class="level3">
<h3 class="anchored" data-anchor-id="question-4">Question</h3>
<p>如何修改<code>D_P</code>, 让他等价于<code>D_R</code>?</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>D_P <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; {R[i]: i mod 2 = 1 and 0 &lt;= i &lt; N}"</span>)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D_P.is_equal(D_R))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>True</code></pre>
</section>
</section>
<section id="iteration-domains-as-presburger-sets" class="level2">
<h2 class="anchored" data-anchor-id="iteration-domains-as-presburger-sets">Iteration Domains as Presburger Sets</h2>
<p>由于<em>isl</em>在Presburger Sets上运行, 因此它可以编码任何可以使用Presburger公式表示的迭代域, 这通常涉及由具有所谓的<em>static control flow</em>的循环和分支包围的语句.</p>
<p>也就是说, loop bounds和分支条件是外部边界和参数的Presburger公式, 其中参数的值未知, 但在整个执行过程中必须保持不变.</p>
<p>作为推论, 控制流不能依赖于被计算的<em>value</em>, 因此, 适合多面体建模的程序部件被称为<em>static control parts</em>或<em>SCoPs</em>.</p>
<section id="question-5" class="level3">
<h3 class="anchored" data-anchor-id="question-5">Question</h3>
<p>定义包含在两个循环和一个具有析取约束的分支中的statement的迭代域.</p>
<p>Hint: 如果有必要, 请使用运算符<code>or</code>和括号来确保优先级</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb37"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> j <span class="op">-</span> <span class="dv">1</span> <span class="op">||</span> i <span class="op">&gt;</span> j <span class="op">+</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>      Z<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>D_Z <span class="op">=</span> isl.Set(<span class="st">" { Z[i,j] : 0 &lt;= i,j &lt; 10 and (i &lt; j - 1 or i &gt; j + 1) } "</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D_Z)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ Z[i, j] : (i &gt;= 0 and 2 + i &lt;= j &lt;= 9) or (i &lt;= 9 and 0 &lt;= j &lt;= -2 + i) }</code></pre>
</section>
<section id="section" class="level3">
<h3 class="anchored" data-anchor-id="section"></h3>
<p>也可以使用Presburger公式表达某些常见的数学运算:</p>
<ul>
<li><code>i &gt;= max(a,b)</code> <span class="math inline">\(( \Leftrightarrow i \geq a \wedge i \geq b )\)</span> (lower bound only)</li>
<li><code>i &lt;= min(a,b)</code> <span class="math inline">\(( \Leftrightarrow i \leq a \wedge i \leq b )\)</span> (upper bound only)</li>
<li><code>a = ceil(b/c)</code> <span class="math inline">\(( \Leftrightarrow a = \lfloor (b - 1)/c \rfloor + 1 )\)</span></li>
</ul>
</section>
</section>
<section id="putting-domains-together" class="level2">
<h2 class="anchored" data-anchor-id="putting-domains-together">Putting Domains Together</h2>
<p>总之, statement的迭代域是一组受仿射表达式约束的多维向量, 仿射表达式出现在statement周围的循环边界和分支条件下.</p>
<p>由于statement名称不同, 多个语句的迭代域存在于不同的<em>Spaces</em>中, 即使它们被相同的循环包围, 通过将它们放入<em>Union set</em>中可以统一操作, 比如组合domain:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb40"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>S1<span class="op">:</span>   Z<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> j <span class="op">+</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>S2<span class="op">:</span>   Z<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>被定义为: <span class="math inline">\(( \mathcal{D} =
    \{\mathtt{S1}[i,j]: 0 \leq i,j &lt; 10 \wedge i &lt; j - 1 \} \cup
    \{\mathtt{S2}[i,j]: 0 \leq i,j &lt; 10 \wedge i &gt; j + 1 \},\)</span>)</p>
<p><em>isl</em>表示如下:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> isl.UnionSet(<span class="st">"{S1[i,j]: 0 &lt;= i,j &lt;= 10 and i &lt; j - 1; S2[i,j]: 0 &lt;= i,j &lt;= 10 and i &gt; j + 1}"</span>)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ S2[i, j] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10 and j &lt;= -2 + i; S1[i, j] : 0 &lt;= i &lt;= 10 and j &gt;= 2 + i and 0 &lt;= j &lt;= 10 }</code></pre>
</section>
<section id="plotting-iteration-domains" class="level2">
<h2 class="anchored" data-anchor-id="plotting-iteration-domains">Plotting Iteration Domains</h2>
<p>可以绘制1D/2D的非参数迭代域集合:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> islplot.plotter <span class="im">import</span> <span class="op">*</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>plot_set_points(D,color<span class="op">=</span><span class="st">'blue'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/02_iteration-domains_25_0.png" class="img-fluid"></p>
<p>可视化可以有效的检查domain的size或者独立的domain交集.</p>
<p>这里例子中,domain完全不相交,意味他们可以被分离的循环所穿过.</p>
<p>如果domain是参数化的,我们首先需要<em>fix</em>所有的参数到constant, 通过以下几种方法:</p>
<ul>
<li>创建一个参数集, 其中域值是固定的;</li>
<li>将domain与这个新set相交;</li>
<li>映射所有参数.</li>
</ul>
<p>下面是对第一个例子的<code>T</code> statement 的操作方法:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>fixer <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; {T[i,j]: N = 5}"</span>)</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>D_T <span class="op">=</span> D_T.intersect(fixer)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>D_T <span class="op">=</span> D_T.project_out(isl.dim_type.param, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>plot_set_points(D_T)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/02_iteration-domains_27_0.png" class="img-fluid"></p>
<p><code>isl.dim_type.param</code>表示你想映射的参数, 后面两个数据分别是第一个参数的位置和将要映射的连续参数的数量.</p>
<p>为了plot出来, 因此把所有维度都映射出来.注意, 如果忘记<em>fix</em>参数大小, 该集将变得unbounds, 无法plot.</p>
<p>与参数类似, 在plot之前可以投影domain dimensions获得两个维度. 使用’isl.dim_type.set’来获取这些</p>
<section id="question-6" class="level3">
<h3 class="anchored" data-anchor-id="question-6">Question</h3>
<p>下面执行LU分解的代码:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb45"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> j<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>Sa<span class="op">:</span>    A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">*</span> A<span class="op">[</span>k<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>Sb<span class="op">:</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">/=</span> A<span class="op">[</span>j<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> i<span class="op">;</span> j <span class="op">&lt;</span> N<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> i<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>Sc<span class="op">:</span>   A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">-=</span> A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">*</span> A<span class="op">[</span>k<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<ol type="1">
<li>为所有的iteration domain定义union set.</li>
<li>检查iteration domain <code>Sa</code> 和 <code>Sc</code> 是否有overlap</li>
<li>绘制domain在(i,j)和(j,k)</li>
</ol>
<p>Hint: 不能<em>直接</em>从union set中映射出domain dimension,因为他们可能存在不同的space中, 但是可以从set中做union得到他.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>D_Sa <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; { Sa[i,j,k] :0 &lt;= k &lt; j &lt; i &lt; N }"</span>)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>D_Sb <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; { Sb[i,j] :0 &lt;= j &lt; i &lt; N }"</span>)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>D_Sc <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; { Sc[i,j,k] :0 &lt;= k &lt; i &lt;= j &lt; N }"</span>)</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> isl.UnionSet(D_Sa).union(D_Sb).union(D_Sc)</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[N] -&gt; { Sc[i, j, k] : i &lt;= j &lt; N and 0 &lt;= k &lt; i; Sa[i, j, k] : i &lt; N and j &lt; i and 0 &lt;= k &lt; j; Sb[i, j] : i &lt; N and 0 &lt;= j &lt; i }</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># </span><span class="al">NOTE</span><span class="co"> 这里需要去掉标识名再做交集.</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>D_Sa_ <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; { [i,j,k] :0 &lt;= k &lt; j &lt; i &lt; N }"</span>)</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>D_Sc_ <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; { [i,j,k] :0 &lt;= k &lt; i &lt;= j &lt; N }"</span>)</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>D_Sa_.intersect(D_Sc_).is_empty()</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>True</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>D_Sa <span class="op">=</span> D_Sa.intersect(isl.Set(<span class="st">"[N] -&gt; { Sa[i,j,k]: N = 8}"</span>))</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>D_Sb <span class="op">=</span> D_Sb.intersect(isl.Set(<span class="st">"[N] -&gt; { Sb[i,j]: N = 8}"</span>))</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>D_Sc <span class="op">=</span> D_Sc.intersect(isl.Set(<span class="st">"[N] -&gt; { Sc[i,j,k]: N = 8}"</span>))</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>D_Sa <span class="op">=</span> D_Sa.project_out(isl.dim_type.param, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>D_Sb <span class="op">=</span> D_Sb.project_out(isl.dim_type.param, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>D_Sc <span class="op">=</span> D_Sc.project_out(isl.dim_type.param, <span class="dv">0</span>, <span class="dv">1</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>D_Sa_ <span class="op">=</span> D_Sa.project_out(isl.dim_type.<span class="bu">set</span>, <span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>D_Sc_ <span class="op">=</span> D_Sc.project_out(isl.dim_type.<span class="bu">set</span>, <span class="dv">2</span>, <span class="dv">1</span>)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>D_ij <span class="op">=</span> isl.UnionSet(D_Sa_).union(D_Sb).union(D_Sc_)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D_ij)</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>plot_set_points(D_ij)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ [i, j] : (i &lt;= 7 and 0 &lt; j &lt; i) or (i &gt; 0 and i &lt;= j &lt;= 7); Sb[i, j] : i &lt;= 7 and 0 &lt;= j &lt; i }</code></pre>
<p><img src="polyherdal-playground/02_iteration-domains_32_1.png" class="img-fluid"></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>D_Sa_ <span class="op">=</span> D_Sa.project_out(isl.dim_type.<span class="bu">set</span>, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>D_Sc_ <span class="op">=</span> D_Sc.project_out(isl.dim_type.<span class="bu">set</span>, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>D_jk <span class="op">=</span> isl.UnionSet(D_Sa_).union(D_Sc_)</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D_jk)</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>plot_set_points(D_jk)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ [j, k] : j &lt;= 7 and 0 &lt;= k &lt; j }</code></pre>
<p><img src="polyherdal-playground/02_iteration-domains_33_1.png" class="img-fluid"></p>
</section>
</section>
</section>
<section id="schedules" class="level1">
<h1>Schedules</h1>
<p>$ { (i,j,k) (i+j, k, i) }$</p>
<section id="definition" class="level2">
<h2 class="anchored" data-anchor-id="definition">Definition</h2>
<p>statement的iteration domain给出了<em>instances</em>的执行信息,但是并没有指定执行顺序.</p>
<p>实际上, 我们可以通过为每个statement instance分配逻辑执行顺序来指定分段 quasi-linear 的顺序.</p>
<p>简而言之, 此<em>schedule</em>可以表示为statement instance和逻辑顺序之间的Presburger映射.</p>
</section>
<section id="identity-schedule" class="level2">
<h2 class="anchored" data-anchor-id="identity-schedule">Identity Schedule</h2>
<p>默认情况下, statement instances按照循环迭代顺序执行. 这可以使用<em>identity</em> schedule relation来表示.</p>
<p>比如一个简单的循环初始化:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb55"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>S<span class="op">:</span>  A<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>iteration domain:</p>
<p><span class="math inline">\(( \mathcal{D}\_\mathtt{S} = [N] \rightarrow \{ \mathtt{S}(i) : 0 \leq i &lt; N \} )\)</span></p>
<p>对应的identity schedule:</p>
<p><span class="math inline">\(( \mathcal{T}\_\mathtt{S} = [N] \rightarrow \{ \mathtt{S}(i) \rightarrow (t_0) : t_0 = i \} )\)</span>.</p>
<p>In <em>isl</em> notation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> islpy <span class="im">as</span> isl</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>D_S <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; { S[i]: 0 &lt;= i &lt; N }"</span>) <span class="co"># 迭代域</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>T_S <span class="op">=</span> isl.Map(<span class="st">"[N] -&gt; {S[i] -&gt; [t0]: t0 = i}"</span>) <span class="co"># schedule</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(T_S)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[N] -&gt; { S[i] -&gt; [t0 = i] }</code></pre>
</section>
<section id="multidimensional-schedules" class="level2">
<h2 class="anchored" data-anchor-id="multidimensional-schedules">Multidimensional Schedules</h2>
<p>如果一个statement instance由多个元素的向量标识, 则表示这个statement包含在多个嵌套循环中, 它通常映射到<em>multidimensional</em>逻辑顺序.</p>
<p>下面的例子中, statement instances以逻辑顺序的<em>lexicographical order</em>进行执行.</p>
<p>比如<span class="math inline">\(((0,42))\)</span>在<span class="math inline">\(((100,0))\)</span>之前, 写作<span class="math inline">\(((0,42) \prec (100,0))\)</span>.</p>
<p>lexicographical order通常扩展到比较不同大小的向量.</p>
<p>短的的向量, 是和较长向量的前缀比较, 例如<span class="math inline">\(((0,42) \prec (0,42,0))\)</span>.</p>
<p>比如, 多维下的初始化:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb58"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> N<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>S<span class="op">:</span>  A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>iteration domain:</p>
<p><span class="math inline">\(( \mathcal{D}_\mathtt{S} = [N] \rightarrow \{ \mathtt{S}(i): 0 \leq i,j &lt; N \} )\)</span></p>
<p>identity schedule:</p>
<p><span class="math inline">\(( \mathcal{T}_\mathtt{S} = [N] \rightarrow \{ \mathtt{S}(i,j) \rightarrow (t_0, t_1) : t_0 = i \wedge t_1 = j \} )\)</span>.</p>
<p>In <em>isl</em> notation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>D_S <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; {S[i,j]: 0 &lt;= i,j &lt; N}"</span>)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>T_S <span class="op">=</span> isl.Map(<span class="st">"[N] -&gt; {S[i,j] -&gt; [t0,t1]: t0 = i and t1 = j}"</span>)</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(T_S)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[N] -&gt; { S[i, j] -&gt; [t0 = i, t1 = j] }</code></pre>
<p>即使理论上schedule可以用单维度来表示:</p>
<p><span class="math inline">\(( \mathcal{T}_\mathtt{S} = [N] \rightarrow \{ \mathtt{S}(i,j) \rightarrow (t_0) : t_0 = Ni + j \} )\)</span></p>
<p>但由于存在变量的乘法, 这种表达式是不能表示为Presburger映射的.</p>
<p>不过当使用实际常量而不是常量参数时, 是可以构建这样的schedule的.</p>
<section id="question-7" class="level3">
<h3 class="anchored" data-anchor-id="question-7">Question</h3>
<p>写出三维数组循环初始化的identity schedule</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb61"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> N<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> N<span class="op">;</span> <span class="op">++</span>k<span class="op">)</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>T<span class="op">:</span>    A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>D_T <span class="op">=</span> isl.Set(<span class="st">"[N] -&gt; { A[i,j,k] : 0 &lt;= i,j,k &lt; N }"</span>)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>T_T <span class="op">=</span> isl.Map(<span class="st">"[N] -&gt; { A[i,j,k] -&gt; [t0 = i,t1 = j,t2 = k] }"</span>)</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>T_T</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>Map("[N] -&gt; { A[i, j, k] -&gt; [t0 = i, t1 = j, t2 = k] }")</code></pre>
</section>
<section id="question-8" class="level3">
<h3 class="anchored" data-anchor-id="question-8">Question</h3>
<p>尝试为同一域定义一个具有乘法的一维计划（会出现错误）.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  T_T_err <span class="op">=</span> isl.Map(<span class="st">"[N] -&gt; {S[i,j,k] -&gt; [t0]: t0 = N*N*i + N*j + k}"</span>)</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span>:</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"got error"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>got error</code></pre>
</section>
</section>
<section id="representing-lexical-order" class="level2">
<h2 class="anchored" data-anchor-id="representing-lexical-order">Representing Lexical Order</h2>
<p>考虑一个循环中包含两个statement:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb66"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>P<span class="op">:</span>  A<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>Q<span class="op">:</span>  B<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>对两个statement使用简单的identity schedule将导致他们具有<em>相同的</em>执行顺序.</p>
<p>然而, 从代码中可以清楚地看出, <code>Q</code>的是在<code>P</code>之后执行的, statement的<em>lexical order</em>可以使用<em>auxiliary</em>维度在schedule中编码.</p>
<p>他分配一个常量, 以便在<code>Q</code>之前强制执行<code>P</code>的statement, 即<code>P</code>的常数小于<code>Q</code>的常数.</p>
<p>由于顺序存在于循环中<em>内部</em>, 因此辅助维度放置在循环维度之后.</p>
<p><span class="math inline">\(( \mathcal{T} =
  \{ P(i) \rightarrow (t\_0, t\_1) : t\_0 = i \wedge t\_1 = 0 \} \cup
  \{ Q(i) \rightarrow (t\_0, t\_1) : t\_0 = i \wedge t\_1 = 1 \} )\)</span></p>
<p>这个map会将顺序<span class="math inline">\(((i,0))\)</span>分配到<code>P</code>, 然后<span class="math inline">\(((i,1))\)</span>分配到<code>Q</code>.</p>
<p>从而清晰的表示<span class="math inline">\(( \forall i, (i,0) \prec (i,1) )\)</span></p>
<p><em>isl</em>中, 不同的 statements的schedules 可以被结合为 union map.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> isl.UnionSet(<span class="st">"{P[i]: 0 &lt;= i &lt; 10; Q[i]: 0 &lt;= i &lt; 10}"</span>) <span class="co"># 首先列出两个statement的set</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> isl.UnionMap(<span class="st">"{P[i] -&gt; [t0,t1]: t0 = i and t1 = 0; Q[i] -&gt; [t0,t1]: t0 = i and t1 = 1}"</span>) <span class="co"># 为他们分别分配额外的执行顺序, P = 0, Q = 1</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(S)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ Q[i] -&gt; [t0 = i, t1 = 1]; P[i] -&gt; [t0 = i, t1 = 0] }</code></pre>
<section id="section-1" class="level3">
<h3 class="anchored" data-anchor-id="section-1"></h3>
<p>考虑两个循环组成的<code>SCoP</code></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb69"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>U<span class="op">:</span>  A<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>V<span class="op">:</span>  B<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>这个例子中,<em>所有的</em><code>U</code>的实例都在<em>所有的</em><code>V</code>的实例之前执行,</p>
<p>因此辅助维度会在循环维度之前加入:</p>
<p><span class="math inline">\(( \mathcal{T} =
  \{ \mathtt{U}(i) \rightarrow (t_0, t_1) : t_0 = 0 \wedge t_1 = i \} \cup
  \{ \mathtt{V}(i) \rightarrow (t_0, t_1) : t_0 = 1 \wedge t_1 = i \}.
)\)</span></p>
<p>Or, in <em>isl</em> notation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>D2 <span class="op">=</span> isl.UnionSet(<span class="st">"{U[i]: 0 &lt;= i &lt; 10; V[i]: 0 &lt;= i &lt; 10}"</span>) <span class="co"># 两个statement分别的set</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>S2 <span class="op">=</span> isl.UnionMap(<span class="st">"{U[i] -&gt; [t0,t1]: t0 = 0 and t1 = i; V[i] -&gt; [t0,t1]: t0 = 1 and t1 = i}"</span>) <span class="co"># 这里把t1作为loop 维度, t0作为辅助维度, 也就是表示两个statement执行循环顺序相同,但是执行整个循环的顺序不同.</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(S2)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ U[i] -&gt; [t0 = 0, t1 = i]; V[i] -&gt; [t0 = 1, t1 = i] }</code></pre>
<p>绘制两个<em>scheduled domain</em>可以发现不同:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> islplot.plotter <span class="im">import</span> <span class="op">*</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>plot_set_points(D.<span class="bu">apply</span>(S))</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D.<span class="bu">apply</span>(S)) <span class="co"># t0表示是外部循环的顺序, t1 表示的内部statement的执行顺序, 此时外部循环0~9, 内部执行顺序0~1</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ [t0, t1 = 1] : 0 &lt;= t0 &lt;= 9; [t0, t1 = 0] : 0 &lt;= t0 &lt;= 9 }</code></pre>
<p><img src="polyherdal-playground/03_schedules_15_1.png" class="img-fluid"></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>plot_set_points(D2.<span class="bu">apply</span>(S2))</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(D2.<span class="bu">apply</span>(S2)) <span class="co"># t0表示是循环外部的顺序, t1表示循环内statement的执行顺序, 此时循环外部有先后顺序, 循环内顺序 0~9</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ [t0 = 1, t1] : 0 &lt;= t1 &lt;= 9; [t0 = 0, t1] : 0 &lt;= t1 &lt;= 9 }</code></pre>
<p><img src="polyherdal-playground/03_schedules_16_1.png" class="img-fluid"></p>
<p>注意, 因为上面将logical dates和所有statement的实例绘制在同一个space中,所以比较难辨认.</p>
</section>
<section id="question-9" class="level3">
<h3 class="anchored" data-anchor-id="question-9">Question</h3>
<p>通常,如果auxiliary dimension被statement共享, 那么定义在循环的最内部,</p>
<p>如果没有被任何loop共享, 那么放到最前面.</p>
<p>为下面的schedule定义auxiliary dimension:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb76"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>S1<span class="op">:</span> A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>S2<span class="op">:</span> B<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> isl.UnionSet(<span class="st">"{ S1[i,j] : 0 &lt;= i &lt; 10 and 0 &lt;= j &lt; 5 ; S2[i,j] : 0 &lt;= i &lt; 10 and 0 &lt;= j &lt; 5 }"</span>)</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> isl.UnionMap(<span class="st">"{ S1[i,j] -&gt; [t0 = i,t1 = 0,t2 = j]; S2[i,j] -&gt; [t0 = i,t1 = 1,t2 = j]; }"</span>)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(S) <span class="co"># t0 作为共享循环i, t1 控制循环j外部的顺序, t2 分别为每个循环j的顺序.</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ S1[i, j] -&gt; [t0 = i, t1 = 0, t2 = j]; S2[i, j] -&gt; [t0 = i, t1 = 1, t2 = j] }</code></pre>
</section>
</section>
</section>
<section id="modeling-memory-accesses" class="level1">
<h1>Modeling memory accesses</h1>
<section id="access-relations" class="level2">
<h2 class="anchored" data-anchor-id="access-relations">Access Relations</h2>
<p>每个statement instance可能会访问一个或多个的variables/ scalars/ arrays.</p>
<p>如果数组的下标索引是loop iterators 和 structure parameters的仿射形式, 那么可以定义Presburger relation来将statement instances和他们访问的数组元素关联起来. 为了简单起见,在polyhedral model中将scalar作为0维数组来表示.</p>
<p>考虑一个矩阵乘的算子:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb79"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> X<span class="op">[</span><span class="dv">100</span><span class="op">],</span> Y<span class="op">[</span><span class="dv">100</span><span class="op">],</span> Z<span class="op">[</span><span class="dv">200</span><span class="op">];</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> zero <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">200</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>S<span class="op">:</span>  Z<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> zero<span class="op">;</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">100</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> <span class="dv">100</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>T<span class="op">:</span>      Z<span class="op">[</span>i <span class="op">+</span> j<span class="op">]</span> <span class="op">+=</span> A<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> B<span class="op">[</span>j<span class="op">];</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>如果只使用句法术语, 可以称为statement <code>S</code> 访问 array <code>Z</code>.</p>
<p>但是,对于每一个独立的<em>instance</em><span class="math inline">\(( \mathtt{S}(i) )\)</span> 只访问其中的一个元素<code>Z[i]</code>.</p>
<p>这可以被编码为 <span class="math inline">\(( \{ \mathtt{S}(i) \rightarrow \mathtt{Z}(a): a = i \} )\)</span>.</p>
<p>进一步, 我们知道array <code>Z</code>的size,因此可以定义额外的约束来避免index out of range.</p>
<p><span class="math inline">\(( \{ \mathtt{Z}(a): 0 \leq a \leq 200 \} )\)</span>.</p>
<p>同时<code>S</code>的iteration domain为:</p>
<p><span class="math inline">\(( \{ \mathtt{S}(i): 0 \leq i \leq 200 \} )\)</span>.</p>
<p>在access relation中加入了以上约束后, 我们可以将上述set和statement domain进行intersect.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> islpy <span class="im">as</span> isl</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>A_S_Z <span class="op">=</span> isl.Map(<span class="st">"{S[i] -&gt; Z[a]: a = i}"</span>) <span class="co"># s访问数组z的映射</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>D_S <span class="op">=</span> isl.Set(<span class="st">"{S[i]: 0 &lt;= i &lt;= 200}"</span>) <span class="co"># S的迭代域</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>C_Z <span class="op">=</span> isl.Set(<span class="st">"{Z[a]: 0 &lt;= a &lt;= 200}"</span>) <span class="co"># 数组Z的domain</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>A_S_Z <span class="op">=</span> A_S_Z.intersect_domain(D_S).intersect_range(C_Z) <span class="co"># 对schedule添加instance domain和数组的range.</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A_S_Z)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ S[i] -&gt; Z[a = i] : 0 &lt;= i &lt;= 200 }</code></pre>
<p>上面最终加入约束后的例子中并没有显式对<span class="math inline">\((a)\)</span>的范围约束,因为存在了隐式的约束<span class="math inline">\((a = i)\)</span>,所以isl会简化最终的表示.</p>
<p>scalar不存在下标索引, 因此他们表示为0维的向量.</p>
<p>但是这个range依旧存在一个name, 比如用<code>zero</code>来表示.</p>
<p><span class="math inline">\(( \{ \mathtt{S}(i) \rightarrow \mathtt{zero}(): 0 \leq i \leq 200 \} )\)</span>.</p>
<p>此时额外的<span class="math inline">\((i)\)</span>的约束将从iteration domain <code>S</code>中获取.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>A_S_zero <span class="op">=</span> isl.Map(<span class="st">"{S[i] -&gt; zero[]:}"</span>) <span class="co"># s访问zero的映射</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>A_S_zero <span class="op">=</span> A_S_zero.intersect_domain(D_S) <span class="co"># 因为zero没有range,所以这里只需要添加domain信息即可.</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A_S_zero)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ S[i] -&gt; zero[] : 0 &lt;= i &lt;= 200 }</code></pre>
<p>最终, 可以将不同数组的访问关系组合成一个描述语句所有访问的联合映射.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>A_S <span class="op">=</span> isl.UnionMap(A_S_Z).union(A_S_zero)</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A_S) <span class="co"># 这里表示的初始化循环中, S访问了浮点值0和Z[i]的relation</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ S[i] -&gt; Z[a = i] : 0 &lt;= i &lt;= 200; S[i] -&gt; zero[] : 0 &lt;= i &lt;= 200 }</code></pre>
<p>因为我们想要区分<em>reads</em> 和 <em>writes</em>的顺序, 因此我们可以分离不同的access relations的unions.</p>
<p>有时候他们会同时触发, 在这里例子中就是一个statement同时读写相同的variable.</p>
<section id="question-10" class="level3">
<h3 class="anchored" data-anchor-id="question-10">Question</h3>
<p>定义map <code>A_T_Z</code>并联合statement <code>T</code>和array <code>Z</code>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>A_T_Z <span class="op">=</span> isl.Map(<span class="st">" { T[i,j] -&gt; Z[a = i + j]} "</span>) <span class="co"># T访问Z的relation.</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A_T_Z)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ T[i, j] -&gt; Z[a = i + j] }</code></pre>
</section>
<section id="question-11" class="level3">
<h3 class="anchored" data-anchor-id="question-11">Question</h3>
<p>分别定义<code>A_T_reads</code> and <code>A_T_writes</code>的union map:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>A_T_reads <span class="op">=</span> isl.UnionMap(<span class="st">" { T[i,j] -&gt; Z[a = i + j] ; T[i,j] -&gt; A[a = i] ; T[i,j] -&gt; B[a = j]} "</span>)</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A_T_reads)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ T[i, j] -&gt; A[a = i]; T[i, j] -&gt; Z[a = i + j]; T[i, j] -&gt; B[a = j] }</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>A_T_writes <span class="op">=</span> isl.Map(<span class="st">"{ T[i,j] -&gt; Z[a = i + j] }"</span>)</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A_T_writes)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ T[i, j] -&gt; Z[a = i + j] }</code></pre>
</section>
</section>
<section id="detecting-out-of-bounds-accesses" class="level2">
<h2 class="anchored" data-anchor-id="detecting-out-of-bounds-accesses">Detecting Out-of-Bounds Accesses</h2>
<p>通过将iteration domain和array size 约束set进行结合,就可以检测出越界访问,</p>
<p>考虑如下代码:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb92"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> A<span class="op">[</span><span class="dv">99</span><span class="op">];</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">99</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>X<span class="op">:</span>  A<span class="op">[</span>i<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>其中的access relation表示为<span class="math inline">\(( a = i + 1 )\)</span></p>
<p>首先将 <code>S</code>的iteration domain 和他的数组<code>A</code>的range约束进行intersect.</p>
<p>返回的access relation中包含了所有的<em>access instances</em>, 也就是所有的statement instance和array 元素的pair.</p>
<p>从domain约束过的relation中减去这个relation得到的结果就是<em>invalid accesses</em>,</p>
<p>表示了所有越界访问的statement instance.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>A_X_A <span class="op">=</span> isl.Map(<span class="st">"{X[i]-&gt;A[a]: a = i+1}"</span>) <span class="co"># X的access relation</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>C_A <span class="op">=</span> isl.Set(<span class="st">"{A[i]: 0 &lt;= i &lt;= 99}"</span>) <span class="co"># 添加数组range信息</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>D_X <span class="op">=</span> isl.Set(<span class="st">"{X[i]: 0 &lt;= i &lt;= 99}"</span>) <span class="co"># 添加statement domain信息</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>correct <span class="op">=</span> A_X_A.intersect_domain(D_X).intersect_range(C_A) <span class="co"># 同时约束domain和range的则是可以执行的statement.</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>incorrect <span class="op">=</span> A_X_A.intersect_domain(D_X).subtract(correct) <span class="co"># 只约束domain的情况下,他的statement set将会大于等于 correct</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(correct)</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(incorrect)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ X[i] -&gt; A[a = 1 + i] : 0 &lt;= i &lt;= 98 }
{ X[i = 99] -&gt; A[a = 100] }</code></pre>
<p>在上面的例子中,statement instance <span class="math inline">\(X(99)\)</span> 就对数组<code>A</code>执行了越界的访问, 这个可以通过将循环上界修改为<code>i &lt; 99</code>来完成修复.</p>
<section id="question-12" class="level3">
<h3 class="anchored" data-anchor-id="question-12">Question</h3>
<p>验证修复后的结果是正确的, 即检查subtract后的集合为空.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>A_X_A <span class="op">=</span> isl.Map(<span class="st">"{X[i]-&gt;A[a]: a = i+1}"</span>) <span class="co"># 首先定义访问关系</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>C_A <span class="op">=</span> isl.Set(<span class="st">"{A[i]: 0 &lt;= i &lt;= 99}"</span>) <span class="co"># 添加数组range信息</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>D_X <span class="op">=</span> isl.Set(<span class="st">"{X[i]: 0 &lt;= i &lt; 99}"</span>) <span class="co"># 添加statement domain信息</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>correct <span class="op">=</span> A_X_A.intersect_domain(D_X).intersect_range(C_A) <span class="co"># 同时约束domain和range的则是可以执行的statement.</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>incorrect <span class="op">=</span> A_X_A.intersect_domain(D_X).subtract(correct) <span class="co"># 只约束domain的情况下,他的statement set将会大于等于 correct</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> incorrect.is_empty() <span class="op">==</span> <span class="va">True</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>公式<span class="math inline">\((1 = 0)\)</span>为false.</p>
<p>在Presburger sets表示中, 这被用于表示一个空的集合,但不丢失name和维度信息.</p>
</section>
</section>
<section id="potentially-dependent-instances" class="level2">
<h2 class="anchored" data-anchor-id="potentially-dependent-instances">Potentially Dependent Instances</h2>
<p>现在来定义<em>inverse</em> access relation, 即映射数组元素到每个访问了这个元素的statement instance.</p>
<p>首先获取原始的access relation:</p>
<p><span class="math inline">\(( \mathcal{A}\_{\mathtt{S} \rightarrow \mathtt{Z}} = \{ \mathtt{S}(i) \rightarrow \mathtt{Z}(a):
    a = i \wedge 0 \leq a,i \leq 200 \} )\)</span>,</p>
<p><em>inverse</em> access relation被<em>相同的约束</em>定义的,但是交换了其中的<code>domain</code>和<code>range</code>.</p>
<p><span class="math inline">\(( \mathcal{A}\_{\mathtt{S} \rightarrow \mathtt{Z}}^{-1} = \{ \mathtt{Z}(a) \rightarrow \mathtt{S}(i):
    a = i \wedge 0 \leq a,i \leq 200 \} )\)</span>.</p>
<p><em>isl</em> can compute inverse relations using:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>A_S_Z_inv <span class="op">=</span> A_S_Z.reverse()</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A_S_Z)</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A_S_Z_inv)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ S[i] -&gt; Z[a = i] : 0 &lt;= i &lt;= 200 }
{ Z[a] -&gt; S[i = a] : 0 &lt;= a &lt;= 200 }</code></pre>
<p>如果两个statement instances访问了<em>相同的</em>array element, 他们可能会互相干扰.</p>
<p>比如,第一个instance写入了值,然后后面第二个instance去读取他.</p>
<p>在没有<code>volatile</code>限定符的情况下,两个statement<em>读取</em>相同的元素是不会被干扰的.</p>
<p>将此定义转换为relations, 我们需要在访问相同数组元素的statement instances之间定义一个映射.</p>
<p>通过access relation, 我们知道statement instance访问了哪些元素.</p>
<p>使用inverse access relation,我们能知道哪些其他的 statement instances访问了数组元素.</p>
<p>结合这两个access relation和数组下标索引, 可以为我们提供潜在的statement instances之间的依赖关系(potentially dependent).</p>
<p>这可以通过access relation之间的组合来完成:</p>
<p><span class="math inline">\(( \mathcal{X} \circ \mathcal{Y} = \{ \pmb{x} \rightarrow \pmb{y} \mid
    \exists \pmb{z} : (\pmb{x},\pmb{z}) \in \mathcal{X} \wedge (\pmb{z},\pmb{y}) \in \mathcal{Y} \} )\)</span>.</p>
<p><em>isl</em>中可以使用<code>apply range</code>操作来进行access relation之间的组合.</p>
<p>比如计算statement <code>S</code>访问相同元素<code>Z</code>的关系:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>dep_S_Z <span class="op">=</span> A_S_Z.apply_range(A_S_Z.reverse()) <span class="co"># A_S_Z 表示S访问数组Z的关系, A_S_Z_inv表示数组Z被S访问的关系.</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dep_S_Z) <span class="co"># 得到了potentially dependent</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ S[i] -&gt; S[i' = i] : 0 &lt;= i &lt;= 200 }</code></pre>
<p>得到了statement instances集合<code>S</code>的map结果.</p>
<p>在这个例子中,本质上是一个恒等的关系, 因为<span class="math inline">\((i^\prime = i)\)</span>是相等的.</p>
<p>这表示不同的<code>S</code>的instance实际访问的是不同的数组元素.</p>
<section id="question-13" class="level3">
<h3 class="anchored" data-anchor-id="question-13">Question</h3>
<p>定义关于instance <code>S</code>访问标量<code>zero</code>的映射<code>dep_S_zero</code>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>dep_S_zero <span class="op">=</span> A_S_zero.apply_range(A_S_zero.reverse())</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dep_S_zero)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ S[i] -&gt; S[i'] : 0 &lt;= i &lt;= 200 and 0 &lt;= i' &lt;= 200 }</code></pre>
<p>上面就可以发现<code>S</code>的每个实例都是相关关联的, 因为他们访问的都是同一个标量值.</p>
<p>不过目前他们只读取这个值, 并没有修改他, 因此是不会与其他的statement instance产生干扰.</p>
</section>
</section>
<section id="reads-and-writes" class="level2">
<h2 class="anchored" data-anchor-id="reads-and-writes">Reads and Writes</h2>
<p>通常,只有至少一次访问为<em>write</em>的时候才会被看作是潜在依赖.</p>
<p>因此,还是需要将read/write分离为不同的relation.</p>
<p>现在用一个更小的数据范围的例子来说明问题:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb102"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> X<span class="op">[</span><span class="dv">10</span><span class="op">],</span> Y<span class="op">[</span><span class="dv">10</span><span class="op">],</span> Z<span class="op">[</span><span class="dv">20</span><span class="op">];</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">20</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>S<span class="op">:</span>  Z<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>T<span class="op">:</span>      Z<span class="op">[</span>i <span class="op">+</span> j<span class="op">]</span> <span class="op">+=</span> A<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> B<span class="op">[</span>j<span class="op">];</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>NOTE 在<em>isl</em>中,复杂度取决于依赖的数量,而不是集合中的数据量.</p>
<p>由于union中的map可以存在于不同的空间中, 因此可以通过组合来自不同语句的单个access (union) map来定义所有读取和写入的映射.</p>
<section id="question-14" class="level3">
<h3 class="anchored" data-anchor-id="question-14">Question</h3>
<p>下面给出了每个单独的access relations, 定义整个<em>SCoP</em>的<code>reads</code> and <code>writes</code> union map.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>A_S_Z <span class="op">=</span> isl.Map(<span class="st">"{S[i]-&gt;Z[a]: a = i and 0 &lt;= a,i &lt;= 20}"</span>) <span class="co"># S 访问数组Z的 access relation</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>A_T_Z <span class="op">=</span> isl.Map(<span class="st">"{T[i,j]-&gt;Z[a]: a = i + j and 0 &lt;= i,j &lt;= 10 and 0 &lt;= a &lt;= 20}"</span>) <span class="co"># T 访问数组Z的access relation</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>A_T_A <span class="op">=</span> isl.Map(<span class="st">"{T[i,j]-&gt;A[a]: a = i and 0 &lt;= a &lt;= 20 and 0 &lt;= i,j &lt;= 10}"</span>) <span class="co"># T 访问数组A的access relation</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>A_T_B <span class="op">=</span> isl.Map(<span class="st">"{T[i,j]-&gt;B[a]: a = j and 0 &lt;= a &lt;= 20 and 0 &lt;= i,j &lt;= 10}"</span>) <span class="co"># T 访问数组B的access relation</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>writes <span class="op">=</span> isl.UnionMap(A_S_Z).union(A_T_Z) <span class="co"># S写入Z[i], T写入Z[i+j]</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>reads <span class="op">=</span> isl.UnionMap(A_T_Z).union(A_T_A).union(A_T_B) <span class="co"># T读Z[i+j], A[i], B[j]</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(reads)</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(writes)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ T[i, j] -&gt; A[a = i] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10; T[i, j] -&gt; Z[a = i + j] : 0 &lt;= i &lt;= 10 and j &gt;= 0 and -i &lt;= j &lt;= 20 - i and j &lt;= 10; T[i, j] -&gt; B[a = j] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10 }
{ T[i, j] -&gt; Z[a = i + j] : 0 &lt;= i &lt;= 10 and j &gt;= 0 and -i &lt;= j &lt;= 20 - i and j &lt;= 10; S[i] -&gt; Z[a = i] : 0 &lt;= i &lt;= 20 }</code></pre>
</section>
</section>
<section id="selecting-one-write" class="level2">
<h2 class="anchored" data-anchor-id="selecting-one-write">Selecting one Write</h2>
<p>为了避免将read access与read access组合的情况, 我们必须确保<code>reads</code>不会同时出现在组合的两边:</p>
<p><span class="math inline">\(( (\mathtt{reads} \circ \mathtt{writes}^{-1}) \cup
    (\mathtt{writes} \circ \mathtt{reads}^{-1}) \cup
    (\mathtt{writes} \circ \mathtt{writes}^{-1}) )\)</span></p>
<p>注意 <code>writes</code>在右边出现了两次, 因此可以将表达式简化为:</p>
<p><span class="math inline">\(( ((\mathtt{reads} \cup \mathtt{writes}) \circ \mathtt{writes}^{-1}) \cup (\mathtt{writes} \circ \mathtt{reads}^{-1}) )\)</span>.</p>
<p>现在来计算union的第一部分:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>reads_writes <span class="op">=</span> reads.union(writes)</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>left_part <span class="op">=</span> reads_writes.apply_range(writes.reverse())</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(left_part)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ S[i] -&gt; S[i' = i] : 0 &lt;= i &lt;= 20; T[i, j] -&gt; S[i' = i + j] : 0 &lt;= i &lt;= 10 and j &gt;= 0 and -i &lt;= j &lt;= 20 - i and j &lt;= 10; T[i, j] -&gt; T[i', j' = i + j - i'] : 0 &lt;= i &lt;= 10 and j &gt;= 0 and -i &lt;= j &lt;= 20 - i and j &lt;= 10 and i' &gt;= -10 + i + j and 0 &lt;= i' &lt;= 10 and i' &lt;= i + j; S[i] -&gt; T[i', j = i - i'] : 0 &lt;= i &lt;= 20 and i' &gt;= -10 + i and 0 &lt;= i' &lt;= 10 and i' &lt;= i }</code></pre>
<section id="question-15" class="level3">
<h3 class="anchored" data-anchor-id="question-15">Question</h3>
<p>计算整个union的第二部分:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a>right_part <span class="op">=</span> writes.apply_range(reads.reverse()) <span class="co"># (writes ∘ reads⁻¹)</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>union <span class="op">=</span> left_part.union(right_part) <span class="co"># 再进行union</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(union)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ S[i] -&gt; T[i', j = i - i'] : i' &gt;= -10 + i and 0 &lt;= i' &lt;= 10 and i' &lt;= i; T[i, j] -&gt; S[i' = i + j] : 0 &lt;= i &lt;= 10 and j &gt;= 0 and -i &lt;= j &lt;= 20 - i and j &lt;= 10; S[i] -&gt; S[i' = i] : 0 &lt;= i &lt;= 20; T[i, j] -&gt; T[i', j' = i + j - i'] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10 and i' &gt;= -10 + i + j and 0 &lt;= i' &lt;= 10 and i' &lt;= i + j }</code></pre>
</section>
<section id="question-16" class="level3">
<h3 class="anchored" data-anchor-id="question-16">Question:</h3>
<p>现在单独计算连接读取相同元素的statement instances的<code>two_reads</code>的relation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>two_reads <span class="op">=</span> reads.apply_range(reads.reverse())</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(two_reads)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ T[i, j] -&gt; T[i', j' = i + j - i'] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10 and i' &gt;= -10 + i + j and 0 &lt;= i' &lt;= 10 and i' &lt;= i + j; T[i, j] -&gt; T[i' = i, j'] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10 and 0 &lt;= j' &lt;= 10; T[i, j] -&gt; T[i', j' = j] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10 and 0 &lt;= i' &lt;= 10 }</code></pre>
</section>
<section id="section-2" class="level3">
<h3 class="anchored" data-anchor-id="section-2"></h3>
<p>比较以上这些relation, 即使它们以不同的顺序打印, <code>union</code>和<code>left_part</code>也完全相同.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(union.is_equal(left_part))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>True</code></pre>
<p>这里是因为在这个例子中<code>left_part</code>实际上就是<code>right_part</code>的一个子集,</p>
<p>因为<code>T</code>读写的都是相同的元素, 因此pair <span class="math inline">\(( \mathtt{S}(i) \rightarrow \mathtt{T}(i',j=i-i') )\)</span></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(right_part.is_subset(left_part))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>True</code></pre>
<p>因此,我们不能只计算潜在依赖statement pair的整体集合,然后减去那些有两次reads的集合. 如果其中出现两次相同的write的关系,就会被抵消.</p>
</section>
<section id="question-17" class="level3">
<h3 class="anchored" data-anchor-id="question-17">Question</h3>
<p>使用read和write的statement instance pair之间的relation, 从中减去 <code>two_reads</code> 并检查它确实只是 <code>union</code> 的一个子集.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>all_pairs <span class="op">=</span> reads_writes.apply_range(reads_writes.reverse())</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>all_pairs <span class="op">=</span> all_pairs.subtract(two_reads)</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(all_pairs.is_equal(union))</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(all_pairs.is_subset(union))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>False
True</code></pre>
</section>
</section>
<section id="visualizing-potentially-dependent-instances" class="level2">
<h2 class="anchored" data-anchor-id="visualizing-potentially-dependent-instances">Visualizing Potentially Dependent Instances</h2>
<p>现在把限制只放在<code>T</code>的实例上</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>T_only <span class="op">=</span> isl.Map(<span class="st">"{ T[i,j] -&gt; T[i',j']: }"</span>) <span class="co"># 过滤出访问点.</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>new_union <span class="op">=</span> union.intersect(T_only)</span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> islplot.plotter <span class="im">import</span> <span class="op">*</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">7</span>), dpi<span class="op">=</span><span class="dv">80</span>)</span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>plot_map(new_union)</span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(new_union)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ T[i, j] -&gt; T[i', j' = i + j - i'] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10 and i' &gt;= -10 + i + j and 0 &lt;= i' &lt;= 10 and i' &lt;= i + j }</code></pre>
<p><img src="polyherdal-playground/04_memory_39_1.png" class="img-fluid"></p>
<p>如上图所示, 每个statement instance都与 <em>他自己</em> 以及同一对角线上的一个或多个instance相关.</p>
<section id="question-18" class="level3">
<h3 class="anchored" data-anchor-id="question-18">Question</h3>
<p>定义一个map <code>left_42</code> 只包含 <span class="math inline">\((\mathtt{T}(4,2) )\)</span> 在左边的pair, 和一个map <code>right_42</code>, 它只包含它在右边的pair</p>
<p><em>提示</em>：map domain和range是集合, 可以对其进行操作</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>left_42 <span class="op">=</span> union.intersect_domain(isl.Set(<span class="st">"{ T[i = 4,j = 2] }"</span>))</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(left_42)</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>right_42 <span class="op">=</span> union.intersect_range(isl.Set(<span class="st">"{ T[i = 4,j = 2] }"</span>))</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(right_42)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ T[i = 4, j = 2] -&gt; S[i' = 6]; T[i = 4, j = 2] -&gt; T[i', j' = 6 - i'] : 0 &lt;= i' &lt;= 6 }
{ T[i, j = 6 - i] -&gt; T[i' = 4, j' = 2] : 0 &lt;= i &lt;= 6; S[i = 6] -&gt; T[i' = 4, j = 2] }</code></pre>
<p>从图上比较这些relation:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">7</span>))</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>plot_map(left_42)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/04_memory_43_0.png" class="img-fluid"></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">7</span>), dpi<span class="op">=</span><span class="dv">80</span>)</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>plot_map(right_42)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/04_memory_44_0.png" class="img-fluid"></p>
<p>从上图可以看出, 两个relation是相同的.</p>
<p>这又是因为对 <code>Z[i+j]</code> 的唯一访问是read和write.</p>
<p>statement instance被连接到了访问相同数据的所有其他statement instance.</p>
<p>但是, 它并不一定会创建<em>依赖</em>. 例如, 依赖于自身并不完全有意义. 对于两个<em>依赖</em>的statement instance, 其中一个应该在另一个<em>之前</em>执行. 也就是说, 第一个statement要么生成第二个statement所需的一些数据, 要么使用一些将被第二个statement覆盖的数据. 依赖计算需要知道statement执行的<em>顺序</em>.</p>
</section>
<section id="question-19" class="level3">
<h3 class="anchored" data-anchor-id="question-19">Question</h3>
<p>给定以下代码, 计算和可视化访问相同数组元素的statement pair, 并且至少其中一个访问是write.</p>
<p><em>Hint:</em> 使用disjunction对同一数组的不同引用中的不同下标进行编码.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb124"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">6</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>S1<span class="op">:</span> X<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> i <span class="op">*</span> j<span class="op">;</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">8</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">13</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">11</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">15</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>S2<span class="op">:</span> Y<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> X<span class="op">[</span>i <span class="op">-</span> <span class="dv">8</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">10</span><span class="op">]</span> <span class="op">-</span> X<span class="op">[</span>i <span class="op">-</span> <span class="dv">7</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">11</span><span class="op">];</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="co"># step 1. 定义每个statement instance的domain</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> isl.UnionSet(<span class="st">" { S1[i,j] : 0 &lt;= i &lt; 6 and 0 &lt;= j &lt; 5 ; S2[i,j] : 8 &lt;= i &lt; 13 and 11 &lt;= j &lt; 15 } "</span>)</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a><span class="co"># S1写入X ; S2写入Y</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>writes <span class="op">=</span> isl.UnionMap(<span class="st">" { S1[i,j] -&gt; X[a = i, b = j]; S2[i,j] -&gt; Y[a = i, b = j] }"</span>)</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a><span class="co"># S2读取X</span></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a>reads <span class="op">=</span> isl.UnionMap(<span class="st">" { S2[i,j] -&gt; X[a,b] : (a = i-8 and b = j-10) or ( a= i-7 and b = j - 11) }"</span>)</span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 添加domain约束</span></span>
<span id="cb125-9"><a href="#cb125-9" aria-hidden="true" tabindex="-1"></a>writes <span class="op">=</span> writes.intersect_domain(domain)</span>
<span id="cb125-10"><a href="#cb125-10" aria-hidden="true" tabindex="-1"></a>reads <span class="op">=</span> reads.intersect_domain(domain)</span>
<span id="cb125-11"><a href="#cb125-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-12"><a href="#cb125-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 依赖计算</span></span>
<span id="cb125-13"><a href="#cb125-13" aria-hidden="true" tabindex="-1"></a>deps <span class="op">=</span> writes.apply_range(reads.reverse())</span>
<span id="cb125-14"><a href="#cb125-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(deps)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ S1[i, j] -&gt; S2[i' = 7 + i, j' = 11 + j] : 0 &lt; i &lt;= 5 and 0 &lt;= j &lt;= 3; S1[i, j] -&gt; S2[i' = 8 + i, j' = 10 + j] : 0 &lt;= i &lt;= 4 and 0 &lt; j &lt;= 4 }</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">7</span>), dpi<span class="op">=</span><span class="dv">80</span>)</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>plot_map(deps)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/04_memory_48_0.png" class="img-fluid"></p>
</section>
<section id="question-20" class="level3">
<h3 class="anchored" data-anchor-id="question-20">Question</h3>
<p>选择 <code>S1</code> 和 <code>S2</code> 的 <em>sample</em> 实例, 并绘制访问同一数组元素的其他语句的实例.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb128"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>point_22 <span class="op">=</span> isl.Set(<span class="st">"{S1[i,j]: i = 2 and j = 2}"</span>) <span class="co"># S1 写入X[2,2]</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>point_1012 <span class="op">=</span> isl.Set(<span class="st">"{S2[i,j]: i = 10 and j = 12}"</span>) <span class="co"># S2 读取 X[2][2] 和 X[3][1];</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>sinks <span class="op">=</span> deps.intersect_domain(point_22)</span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>sources <span class="op">=</span> deps.intersect_range(point_1012)</span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>, <span class="dv">7</span>), dpi<span class="op">=</span><span class="dv">80</span>)</span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>plot_map([sinks,sources])</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/04_memory_50_0.png" class="img-fluid"></p>
</section>
</section>
</section>
<section id="dependence-analysis" class="level1">
<h1>Dependence Analysis</h1>
<p>当程序被转换时,保留程序语义的关键在于确保相同的值以相同的顺序写入和读取内存.</p>
<p>传统上,这是使用<em>data dependences</em>来表示的, 它对程序施加了部分执行顺序约束. 多面体模型的强大之处在于它能够在statement instance级别计算精确的data dependences.</p>
<p>如果一个statement instances在另一个statement instances之前执行, 则两个语句实例被称为<em>依赖</em>, 它们访问相同的数组元素, 并且至少一个访问权限写入该元素.</p>
<p>在<code>Schedules</code>章节中, 我们学习了如何定义statement instance的执行顺序. 在<code>Memory Access</code>章节中, 我们定义了<em>potentially dependent</em>的statement instance的关系, 即访问了相同的数组元素并且至少一个访问是写入.</p>
<p>最简单的依赖分析就是将两部分结合起来, 首先我们给出一个多项式乘积的kernel:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb129"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> A<span class="op">[</span><span class="dv">10</span><span class="op">],</span> B<span class="op">[</span><span class="dv">10</span><span class="op">],</span> Z<span class="op">[</span><span class="dv">20</span><span class="op">];</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">20</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>S<span class="op">:</span>  Z<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> <span class="dv">10</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>T<span class="op">:</span>      Z<span class="op">[</span>i <span class="op">+</span> j<span class="op">]</span> <span class="op">+=</span> A<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> B<span class="op">[</span>j<span class="op">];</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>然后定义对应的domain/schedule/access relations:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> islpy <span class="im">as</span> isl</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> isl.UnionSet(<span class="st">"{S[i]: 0 &lt;= i &lt;= 20; T[i,j]: 0 &lt;= i,j &lt;= 10}"</span>)</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a><span class="co"># t0是最外层的辅助维度, 用于标记外部的执行顺序. t1/t2则是内部循环的执行顺序.</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>schedule <span class="op">=</span> isl.UnionMap(</span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"{S[i]-&gt;[t0,t1,t2]: t0 = 0 and t1 = i and t2 = 0; T[i,j]-&gt;[t0,t1,t2]: t0=1 and t1=i and t2=j}"</span>)</span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>A_S_Z <span class="op">=</span> isl.Map(<span class="st">"{S[i]-&gt;Z[a]: a = i and 0 &lt;= a,i &lt;= 20}"</span>)  <span class="co"># S 写入Z[i]</span></span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>A_T_Z <span class="op">=</span> isl.Map(<span class="st">"{T[i,j]-&gt;Z[a]: a = i + j and 0 &lt;= i,j &lt;= 10 and 0 &lt;= a &lt;= 20}"</span>)  <span class="co"># T写入Z[i+j]</span></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>A_T_A <span class="op">=</span> isl.Map(<span class="st">"{T[i,j]-&gt;A[a]: a = i and 0 &lt;= a &lt;= 20 and 0 &lt;= i,j &lt;= 10}"</span>)  <span class="co"># T读取A[i]</span></span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a>A_T_B <span class="op">=</span> isl.Map(<span class="st">"{T[i,j]-&gt;B[a]: a = j and 0 &lt;= a &lt;= 20 and 0 &lt;= i,j &lt;= 10}"</span>)  <span class="co"># T读取B[i]</span></span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>writes <span class="op">=</span> isl.UnionMap(A_S_Z).union(A_T_Z) </span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a>reads <span class="op">=</span> isl.UnionMap(A_T_Z).union(A_T_A).union(A_T_B)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>我们还可以计算访问相同数组元素的statement instance pair集合.</p>
<section id="plugging-in-schedule-information" class="level2">
<h2 class="anchored" data-anchor-id="plugging-in-schedule-information">Plugging in Schedule Information</h2>
<p>因为statement instances是按照它们各自词典序执行的, 因此我们需要一种在relation中表达它的方法.</p>
<p>最简单的例子就是强制所有的statements的schedule都在相同的<em>space</em>中, 比如我们添加一个辅助维度<span class="math inline">\((t\_2)\)</span>到schedule <code>S</code>的statement <code>T</code>中</p>
<p><em>isl</em> 允许我们定义<code>lexicographic less-than</code>的映射:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb131"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>schedule_space <span class="op">=</span> isl.Set(<span class="st">"{[t0,t1,t2]:}"</span>).get_space()</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>precedes <span class="op">=</span> isl.Map.lex_lt(schedule_space)</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(precedes)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ [t0, t1, t2] -&gt; [t0', t1', t2'] : t0' &gt; t0; [t0, t1, t2] -&gt; [t0' = t0, t1', t2'] : t1' &gt; t1; [t0, t1, t2] -&gt; [t0' = t0, t1' = t1, t2'] : t2' &gt; t2 }</code></pre>
<p>上面的map按照词典序的定义执行, 先比较第一对元素,如果一个在另一个之前, 则顺序成立. 否则假设它们相等并比较第二对, 继续直到最后一对.</p>
<p><code>precedes</code> relation 即前一个词典上在后一个之前成对元组的集合.</p>
<section id="question-21" class="level3">
<h3 class="anchored" data-anchor-id="question-21">Question</h3>
<p>将 <code>schedule</code> 应用到 <code>domain</code> 以便将其映射到调度空间, 将结果保存为 <code>scheduled_domain</code>.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb133"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>scheduled_domain <span class="op">=</span> domain.<span class="bu">apply</span>(schedule)</span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(scheduled_domain)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ [t0 = 1, t1, t2] : 0 &lt;= t1 &lt;= 10 and 0 &lt;= t2 &lt;= 10; [t0 = 0, t1, t2 = 0] : 0 &lt;= t1 &lt;= 20 }</code></pre>
<p>现在我们知道如何将relation从domain空间移动到schedule空间: 将schedule relation apply到domain空间中的所有内容上.</p>
</section>
<section id="question-22" class="level3">
<h3 class="anchored" data-anchor-id="question-22">Question</h3>
<p>检查 <span class="math inline">\(( \mathtt{S}(2) )\)</span> 在 <span class="math inline">\(( \mathtt{T}(0,0) )\)</span> 之前执行.</p>
<p><em>Hint 1</em>: 在两个instances之间定义映射.</p>
<p><em>Hint 2</em>: 在schedule space中,可以检查relation是否是precedes的子集.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb135"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a>rel <span class="op">=</span> isl.UnionMap(<span class="st">"{S[i] -&gt; T[a,b]: i = 2 and a = 0 and b = 0}"</span>) <span class="co"># 构造出对应循环点的instance.</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>rel <span class="op">=</span> rel.apply_domain(schedule).apply_range(schedule) <span class="co"># 为instance添加约束.</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(rel)</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(rel.is_subset(precedes))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ [t0 = 0, t1 = 2, t2 = 0] -&gt; [t0' = 1, t1' = 0, t2' = 0] }
True</code></pre>
</section>
</section>
<section id="memory-based-dependence-analysis" class="level2">
<h2 class="anchored" data-anchor-id="memory-based-dependence-analysis">Memory-based Dependence Analysis</h2>
<section id="flow-dependences" class="level3">
<h3 class="anchored" data-anchor-id="flow-dependences">Flow Dependences</h3>
<p>当数组元素首先由一个statement instance 写入然后由另一个statement instance 读取时, 就会出现数据流依赖性, 必须首先执行<code>writer</code> instance.</p>
<p>因此, 我们首先将左侧的 <code>writes</code> union map与右侧的反向 <code>reads</code> union map组合在一起, <span class="math inline">\(( \mathtt{writes} \circ \mathtt{reads}^{-1} )\)</span>.</p>
<p>然后我们将其转换为schedule space, 并将结果与schedule space中的词典序relation相交, 从而 只保留依赖 <em>source</em>(第一个时间点)在其 <em>sink</em>(第二个时间点)之前执行的对.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb137"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>dep_flow <span class="op">=</span> writes.apply_range(reads.reverse()) <span class="co"># 获取潜在依赖</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>dep_flow <span class="op">=</span> dep_flow.apply_domain(schedule).apply_range(schedule) <span class="co"># 添加约束.</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>dep_flow <span class="op">=</span> dep_flow.intersect(precedes) <span class="co"># 和词典序做交集.</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dep_flow) <span class="co"># 这里得到了执行顺序的交集</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ [t0 = 1, t1, t2] -&gt; [t0' = 1, t1', t2' = t1 + t2 - t1'] : 0 &lt;= t1 &lt;= 10 and 0 &lt;= t2 &lt;= 10 and t1' &gt;= -10 + t1 + t2 and t1' &gt; t1 and 0 &lt;= t1' &lt;= 10 and t1' &lt;= t1 + t2; [t0 = 0, t1, t2 = 0] -&gt; [t0' = 1, t1', t2' = t1 - t1'] : t1' &gt;= -10 + t1 and 0 &lt;= t1' &lt;= 10 and t1' &lt;= t1 }</code></pre>
<p>由此产生的relation是在<em>执行时间点</em>之间,而不是在点之间. 要将其转换回domain space,重新调用一下relation可以很容易地反转. 即反向schedule relation将执行时间点映射到statement instances.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb139"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>dep_flow <span class="op">=</span> dep_flow.apply_domain(schedule.reverse()).apply_range(schedule.reverse()) <span class="co"># 再将其反向映射到数据点上, </span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dep_flow)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ T[i, j] -&gt; T[i', j' = i + j - i'] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10 and i' &gt;= -10 + i + j and i' &gt; i and 0 &lt;= i' &lt;= 10 and i' &lt;= i + j; S[i] -&gt; T[i', j = i - i'] : i' &gt;= -10 + i and 0 &lt;= i' &lt;= 10 and i' &lt;= i }</code></pre>
<p>现在得到了 <code>T</code> 的不同instance之间的依赖关系, 我们可以分析它并与 <em>potentially</em> 依赖语句关系进行比较.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb141"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>dep_flow_T <span class="op">=</span> dep_flow.intersect(isl.UnionMap(<span class="st">"{T[i,j]-&gt;T[i',j']:}"</span>))</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>potential <span class="op">=</span> writes.apply_range(reads.reverse())</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>potential <span class="op">=</span> potential.intersect(isl.UnionMap(<span class="st">"{T[i,j]-&gt;T[i',j']:}"</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb142"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> islplot.plotter <span class="im">import</span> <span class="op">*</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">7</span>))</span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>plot_map(dep_flow_T)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/05_dependences_14_0.png" class="img-fluid"></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb143"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">7</span>))</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>plot_map(potential)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/05_dependences_15_0.png" class="img-fluid"></p>
<p>实际上每个statement instance是不能在其自身之前被执行, 因此观察到statement instances的self-dependences消失了.</p>
</section>
<section id="question-23" class="level3">
<h3 class="anchored" data-anchor-id="question-23">Question</h3>
<p>绘制instance $ (4,2) $ instance 的依赖 <em>samples</em>, 即它所依赖的statement instances和依赖它的statement instances.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb144"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>point <span class="op">=</span> isl.Set(<span class="st">"{T[i,j]: i = 4 and j = 2}"</span>) <span class="co"># 添加instance point约束</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>sources <span class="op">=</span> dep_flow_T.intersect_range(point) </span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>sinks <span class="op">=</span> dep_flow_T.intersect_domain(point)</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sources)</span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sinks)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ T[i, j = 6 - i] -&gt; T[i' = 4, j' = 2] : 0 &lt;= i &lt;= 3 }
{ T[i = 4, j = 2] -&gt; T[i', j' = 6 - i'] : 5 &lt;= i' &lt;= 6 }</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb146"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="co"># sources : 4 + 2 = 6, 他依赖于 [0,6], [1,5], [2,4], [3,3] 这些instance.</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a><span class="co"># sinks: [5,1],[6,0]依赖于[4,2]</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">7</span>))</span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>plot_map([sources, sinks], marker_size<span class="op">=</span><span class="dv">10</span>)  </span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/05_dependences_18_0.png" class="img-fluid"></p>
<p>现在可以看到依赖于给定statement instances的实例都是访问相同数组元素并在它之前执行的实例, 类似地, 在给定statement instances之后执行的语句实例依赖于它.</p>
</section>
<section id="anti-and-output-dependences" class="level3">
<h3 class="anchored" data-anchor-id="anti-and-output-dependences">Anti and Output Dependences</h3>
<p>Anti-dependences是flow dependencs的reverse,即先读后写, 考虑Anti-dependences意味着在读取之前不覆盖他的值, Output dependences,或写后再写,需要保留写的顺序.</p>
<p>这些通常都被称为 <em>false</em> dependences,因为 <em>sink</em> 实例实际上并不 <strong>依赖</strong> <em>source</em> 语句实例产生的 <em>data</em>, 而是需要在后面执行以避免干扰其他实例.</p>
<p>false dependences的 <em>sink</em> 通常是写访问,而<em>source</em>可以是读或写, 因此我们将左侧的读写union与右侧的reverse写组合:</p>
<p><span class="math inline">\(( (\mathtt{reads} \cup \mathtt{writes}) \circ \mathtt{writes}^{-1} )\)</span>.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb147"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>dep_false <span class="op">=</span> writes.union(reads).apply_range(writes.reverse())</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>dep_false <span class="op">=</span> dep_false.apply_domain(schedule).apply_range(schedule)</span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>dep_false <span class="op">=</span> dep_false.intersect(precedes)</span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>dep_false <span class="op">=</span> dep_false.apply_domain(schedule.reverse()).apply_range(schedule.reverse())</span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dep_false)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ T[i, j] -&gt; T[i', j' = i + j - i'] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10 and i' &gt;= -10 + i + j and i' &gt; i and 0 &lt;= i' &lt;= 10 and i' &lt;= i + j; S[i] -&gt; T[i', j = i - i'] : i' &gt;= -10 + i and 0 &lt;= i' &lt;= 10 and i' &lt;= i }</code></pre>
<p>在这个例子中,false dependences与flow dependences完全对应,因为<code>S</code>只写入,而<code>T</code>只读取和写入相同的元素. 实际上一般情况并非如此.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb149"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dep_false.is_equal(dep_flow))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>True</code></pre>
</section>
<section id="question-input-dependences" class="level3">
<h3 class="anchored" data-anchor-id="question-input-dependences">Question: Input Dependences</h3>
<p>即使<em>input</em> 或连续读取通常不被强制执行, 但这个得到他们的依赖关系在程序优化中也很有用. 因此与前两种情况类似地计算input dependences:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb151"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>dep_input <span class="op">=</span> reads.apply_range(reads.reverse()) <span class="co"># 获得reads after reads的map</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>dep_input <span class="op">=</span> dep_input.apply_domain(schedule).apply_range(schedule) <span class="co"># 添加约束.</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>dep_input <span class="op">=</span> dep_input.intersect(precedes) <span class="co"># 和词典序做交集.</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>dep_input <span class="op">=</span> dep_input.apply_domain(schedule.reverse()).apply_range(schedule.reverse()) <span class="co"># 再将其反向映射到数据点上, </span></span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dep_input)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ T[i, j] -&gt; T[i', j' = i + j - i'] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10 and i' &gt;= -10 + i + j and i' &gt; i and 0 &lt;= i' &lt;= 10 and i' &lt;= i + j; T[i, j] -&gt; T[i' = i, j'] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10 and j' &gt; j and 0 &lt;= j' &lt;= 10; T[i, j] -&gt; T[i', j' = j] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10 and i' &gt; i and 0 &lt;= i' &lt;= 10 }</code></pre>
<p>Input dependence看起来和flow dependence/false dependence不同, 其中只出现了<code>T</code>的实例, 这是因为<code>S</code>从来没有读过任何值.</p>
</section>
<section id="question-24" class="level3">
<h3 class="anchored" data-anchor-id="question-24">Question</h3>
<p>绘制input dependence的<em>samples</em>:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb153"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a>point <span class="op">=</span> isl.Set(<span class="st">"{T[i,j]: i = 4 and j = 2}"</span>)</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a><span class="co"># sources 其中竖线表示B[0,1,2]时多次读取A[4]的依赖, 横线表示B[2]时多次读取A[0,1,2,3]的依赖, 斜线表示Z[4,2]对Z[(0+6),(1+5),(2+4),(3+3)]的依赖</span></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a>sources <span class="op">=</span> dep_input.intersect_range(point) </span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>sinks <span class="op">=</span> dep_input.intersect_domain(point)</span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">7</span>))</span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>plot_map([sources, sinks], marker_size<span class="op">=</span><span class="dv">5</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/05_dependences_27_0.png" class="img-fluid"></p>
<p>复杂的依赖pattern会导致同一个statement instance从多个不同的array读取数据.</p>
</section>
</section>
<section id="value-based-analysis" class="level2">
<h2 class="anchored" data-anchor-id="value-based-analysis">Value-based Analysis</h2>
<p>可以观察到每个statement instance依赖了<em>所有</em>访问相同数组元素的实例,但是其实并不是必要的. 比如<code>T(4,2)</code>和<code>T(5,1)</code>的flow dependence:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb154"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>point1 <span class="op">=</span> isl.Set(<span class="st">"{T[i,j]: i = 4 and j = 2}"</span>)</span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>point2 <span class="op">=</span> isl.Set(<span class="st">"{T[i,j]: i = 5 and j = 1}"</span>)</span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>sources1 <span class="op">=</span> dep_flow_T.intersect_range(point1)</span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>sources2 <span class="op">=</span> dep_flow_T.intersect_range(point2)</span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">7</span>))</span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a>plot_map([sources1, sources2],marker_size<span class="op">=</span><span class="dv">10</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/05_dependences_29_0.png" class="img-fluid"></p>
<p>其中<code>T(5,1)</code> 依赖<code>T(4,2)</code>所依赖的所有实例以及<code>T(4,2)</code>本身.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb155"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sources2.domain().subtract(point1).is_equal(sources1.domain())) <span class="co"># 检查是否是子集.</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>True</code></pre>
<p>如果将<code>T(4,2)</code>调度到<code>T(3,3)</code>之后, 那么<code>T(5,1)</code>也需要被调度到<code>T(4,2)</code>之后, 然后<code>T(5,1)</code>也需要调度到<code>T(3,3)</code>之后. 所以这两个实例之间的依赖关系<em>transitively covered(传递地覆盖)</em>其他实例之间的依赖.</p>
<p>我们可以安全地移除传递覆盖的flow dependence. 通过计算词典序最大的source instance对于任意sink instance的依赖,然后删除其他的source instance来完成.</p>
<p>但以上的计算是non- trivial的,并且可能涉及到线性优化问题的求解, <em>isl</em>提供了<em>value-based</em>分析的功能. 但是,它会使用更加精确的树结构来调度, 对于这个例子, 我们将直接提供这个schedule:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb157"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>schedule <span class="op">=</span> isl.Schedule(<span class="st">'{ domain: "{ T[i, j] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 10; S[i] : 0 &lt;= i &lt;= 20 }", child: { sequence: [{ filter: "{ S[i] }", child: { schedule: "[{S[i] -&gt; [(i)]}, {S[i] -&gt; [(0)]}]" </span><span class="sc">}}</span><span class="st">, { filter: "{ T[i, j] }", child: { schedule: "[{T[i, j] -&gt; [(i)]}, {T[i, j] -&gt; [(j)]}]" </span><span class="sc">}}</span><span class="st"> ] } }'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>现在可以来进行<em>value-based</em>的依赖分析:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb158"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>uai <span class="op">=</span> isl.UnionAccessInfo.from_sink(reads)</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>uai <span class="op">=</span> uai.set_must_source(writes)</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>uai <span class="op">=</span> uai.set_schedule(schedule)</span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>flow <span class="op">=</span> uai.compute_flow()</span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>dep_flow_precise <span class="op">=</span> flow.get_may_dependence()</span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dep_flow_precise)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ S[i] -&gt; T[i' = -10 + i, j = 10] : 10 &lt;= i &lt;= 20; S[i] -&gt; T[i' = 0, j = i] : 0 &lt;= i &lt;= 9; T[i, j] -&gt; T[i' = 1 + i, j' = -1 + j] : 0 &lt;= i &lt;= 9 and 0 &lt; j &lt;= 10 }</code></pre>
<p>现在依赖关系已经不再包含transitively covered的例子了.</p>
<section id="question-25" class="level3">
<h3 class="anchored" data-anchor-id="question-25">Question</h3>
<p>将依赖关系限制在<code>T</code>上, 然后绘制<code>T(4,2)</code> 和 <code>T(5,1)</code>的samples, 并将他们<em>memory-based</em>的分析结果进行比较.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb160"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>dep_flow_precise_T <span class="op">=</span> dep_flow_precise.intersect(isl.UnionMap(<span class="st">"{T[i,j]-&gt;T[i',j']:}"</span>))</span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a>sources1 <span class="op">=</span> dep_flow_precise_T.intersect_range(point1)</span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>sources2 <span class="op">=</span> dep_flow_precise_T.intersect_range(point2)</span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">7</span>))</span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a>plot_map([sources1, sources2], marker_size<span class="op">=</span><span class="dv">10</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/05_dependences_37_0.png" class="img-fluid"></p>
</section>
<section id="section-3" class="level3">
<h3 class="anchored" data-anchor-id="section-3"></h3>
<p>可以发现,每个<code>T</code>的实例限制只依赖一个其他<code>T</code>的实例.</p>
<p><em>Memory-based</em> dependences可以通过计算依赖关系的transitive closure来从<em>value-based</em> dependences恢复出来:</p>
</section>
<section id="question-26" class="level3">
<h3 class="anchored" data-anchor-id="question-26">Question</h3>
<p>使用<em>value-based</em>的过程计算input dependences, 并且可视化:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb161"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>uai <span class="op">=</span> isl.UnionAccessInfo.from_sink(reads)</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>uai <span class="op">=</span> uai.set_must_source(reads)</span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>uai <span class="op">=</span> uai.set_schedule(schedule)</span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>flow <span class="op">=</span> uai.compute_flow()</span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>dep_input_precise <span class="op">=</span> flow.get_may_dependence()</span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dep_input_precise)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ T[i, j] -&gt; T[i' = i, j' = 1 + j] : 0 &lt;= i &lt;= 10 and 0 &lt;= j &lt;= 9; T[i, j] -&gt; T[i' = 1 + i, j' = j] : 0 &lt;= i &lt;= 9 and 0 &lt;= j &lt;= 10; T[i, j] -&gt; T[i' = 1 + i, j' = -1 + j] : 0 &lt;= i &lt;= 9 and 0 &lt; j &lt;= 10 }</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb163"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a>dep_flow_precise_T <span class="op">=</span> dep_flow_precise.intersect(isl.UnionMap(<span class="st">"{T[i,j]-&gt;T[i',j']:}"</span>))</span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>sources1 <span class="op">=</span> dep_flow_precise_T.intersect_range(point1)</span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>sources2 <span class="op">=</span> dep_flow_precise_T.intersect_range(point2)</span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">7</span>))</span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a>plot_map([sources1, sources2], marker_size<span class="op">=</span><span class="dv">10</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/05_dependences_41_0.png" class="img-fluid"></p>
</section>
</section>
</section>
<section id="classical-loop-transformations" class="level1">
<h1>Classical Loop Transformations</h1>
<section id="setup-ast-generation-infrastructure" class="level3">
<h3 class="anchored" data-anchor-id="setup-ast-generation-infrastructure">Setup AST generation infrastructure</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb164"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> islpy <span class="im">as</span> isl</span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CSource():</span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, ast):</span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.source <span class="op">=</span> ast</span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _repr_html_(<span class="va">self</span>):</span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">"&lt;pre class='code'&gt;&lt;code class=</span><span class="ch">\"</span><span class="st">cpp hljs</span><span class="ch">\"</span><span class="st">&gt;"</span> <span class="op">+</span> <span class="va">self</span>.source.to_C_str() <span class="op">+</span> <span class="st">"&lt;/code&gt;&lt;/pre&gt;"</span></span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CSourceComparer():</span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, before: CSource, after: CSource):</span>
<span id="cb164-14"><a href="#cb164-14" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.before <span class="op">=</span> before</span>
<span id="cb164-15"><a href="#cb164-15" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.after <span class="op">=</span> after</span>
<span id="cb164-16"><a href="#cb164-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-17"><a href="#cb164-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _repr_html_(<span class="va">self</span>):</span>
<span id="cb164-18"><a href="#cb164-18" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="st">"&lt;b&gt;Before Transform:&lt;/b&gt;</span><span class="ch">\n</span><span class="st">"</span></span>
<span id="cb164-19"><a href="#cb164-19" aria-hidden="true" tabindex="-1"></a>    s <span class="op">+=</span> <span class="va">self</span>.before._repr_html_()</span>
<span id="cb164-20"><a href="#cb164-20" aria-hidden="true" tabindex="-1"></a>    s <span class="op">+=</span> <span class="st">"&lt;b&gt;After Transform:&lt;/b&gt;</span><span class="ch">\n</span><span class="st">"</span></span>
<span id="cb164-21"><a href="#cb164-21" aria-hidden="true" tabindex="-1"></a>    s <span class="op">+=</span> <span class="va">self</span>.after._repr_html_()</span>
<span id="cb164-22"><a href="#cb164-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s</span>
<span id="cb164-23"><a href="#cb164-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-24"><a href="#cb164-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-25"><a href="#cb164-25" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_before_after(domain, schedule_original, schedule_new):</span>
<span id="cb164-26"><a href="#cb164-26" aria-hidden="true" tabindex="-1"></a>  context <span class="op">=</span> isl.Set(<span class="st">"{ : }"</span>)</span>
<span id="cb164-27"><a href="#cb164-27" aria-hidden="true" tabindex="-1"></a>  build <span class="op">=</span> isl.AstBuild.from_context(context)</span>
<span id="cb164-28"><a href="#cb164-28" aria-hidden="true" tabindex="-1"></a>  schedule_original <span class="op">=</span> schedule_original.intersect_domain(domain)</span>
<span id="cb164-29"><a href="#cb164-29" aria-hidden="true" tabindex="-1"></a>  schedule_new <span class="op">=</span> schedule_new.intersect_domain(domain)</span>
<span id="cb164-30"><a href="#cb164-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> CSourceComparer(CSource(build.node_from_schedule_map(schedule_original)),</span>
<span id="cb164-31"><a href="#cb164-31" aria-hidden="true" tabindex="-1"></a>                         CSource(build.node_from_schedule_map(schedule_new)))</span>
<span id="cb164-32"><a href="#cb164-32" aria-hidden="true" tabindex="-1"></a>  <span class="co"># print("&lt;b&gt;Before Transform:&lt;/b&gt;")</span></span>
<span id="cb164-33"><a href="#cb164-33" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ast = build.node_from_schedule_map(schedule_original)</span></span>
<span id="cb164-34"><a href="#cb164-34" aria-hidden="true" tabindex="-1"></a>  <span class="co"># print_code(ast)</span></span>
<span id="cb164-35"><a href="#cb164-35" aria-hidden="true" tabindex="-1"></a>  <span class="co"># print("&lt;b&gt;After Transform:&lt;/b&gt;")</span></span>
<span id="cb164-36"><a href="#cb164-36" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ast = build.node_from_schedule_map(schedule_new)</span></span>
<span id="cb164-37"><a href="#cb164-37" aria-hidden="true" tabindex="-1"></a>  <span class="co"># print_code(ast)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="loop-reversal" class="level2">
<h2 class="anchored" data-anchor-id="loop-reversal">Loop Reversal</h2>
<p>循环反转可以改变循环元素被访问的方向, 反转之后, 之前迭代的第一个元素将会被最后执行, 最后一个元素将会被第一个执行.</p>
<p><strong>Benefits</strong>:</p>
<ul>
<li>可以被用来缩短依赖</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb165"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> isl.UnionSet(<span class="st">"[n] -&gt; {S[i] : 0 &lt;= i &lt; n}"</span>) <span class="co"># 原始迭代域</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>original <span class="op">=</span> isl.UnionMap(<span class="st">"{S[i] -&gt; [i]}"</span>) <span class="co"># 原始schedule</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>transformation <span class="op">=</span> isl.UnionMap(<span class="st">"{[i] -&gt; [-i]}"</span>)</span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a>transformed <span class="op">=</span> original.apply_range(transformation) <span class="co"># 实施transform.</span></span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a>print_before_after(domain, original, transformed) <span class="co"># i \in [0,n-1] =&gt; [-n+1,0]</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<b>Before Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = 0; c0 &lt; n; c0 += 1)
  S(c0);
</code></pre>
<b>After Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = -n + 1; c0 &lt;= 0; c0 += 1)
  S(-c0);
</code></pre>
</section>
</section>
<section id="loop-fusion" class="level1">
<h1>Loop Fusion</h1>
<p>之前分离在两个不同循环的中的statement将会被放到同一个循环中.</p>
<p><strong>Benefits:</strong></p>
<ul>
<li>提高数据局部性</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb166"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> isl.UnionSet(<span class="st">"[n] -&gt; {S[i] : 0 &lt;= i &lt;= n; T[i] : 0 &lt;= i &lt;= n}"</span>) <span class="co"># 原始两个循环, S和T</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>original <span class="op">=</span> isl.UnionMap(<span class="st">"{S[i] -&gt; [0, i]; T[i] -&gt; [1, i]}"</span>) <span class="co"># 原始schedule, 是在循环外部安排顺序</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>transformation <span class="op">=</span> isl.UnionMap(<span class="st">"{[0, i] -&gt; [i,0]; [1, i] -&gt; [i, 1]}"</span>) <span class="co"># 将顺序安排在同一个循环内部.</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>transformed <span class="op">=</span> original.apply_range(transformation) <span class="co"># </span><span class="al">NOTE</span><span class="co"> 现实中要考虑是否存在数据依赖问题.</span></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>print_before_after(domain, original, transformed)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<b>Before Transform:</b>
<pre class="code"><code class="cpp hljs">{
  for (int c1 = 0; c1 &lt;= n; c1 += 1)
    S(c1);
  for (int c1 = 0; c1 &lt;= n; c1 += 1)
    T(c1);
}
</code></pre>
<b>After Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = 0; c0 &lt;= n; c0 += 1) {
  S(c0);
  T(c0);
}
</code></pre>
</section>
<section id="loop-fission-loop-distribution" class="level1">
<h1>Loop Fission (Loop Distribution)</h1>
<p>Loop fission 是指将在同一个循环中执行的statement分配到两个不同的循环中去.</p>
<p><strong>Benefits:</strong></p>
<ul>
<li>减少寄存器压力(在同一个循环中就意味着使用更多的寄存器存储数组地址/索引等)</li>
<li>可以开启其他的优化, 比如一个循环中只有一个statement可以进行<code>SIMDization</code>,此时可以将其分离出去单独进行并行化.</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb167"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> isl.UnionSet(<span class="st">"[n] -&gt; {S[i] : 0 &lt;= i &lt;= n; T[i] : 0 &lt;= i &lt;= n}"</span>)</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>original <span class="op">=</span> isl.UnionMap(<span class="st">"{S[i] -&gt; [i, 0]; T[i] -&gt; [i, 1]}"</span>)</span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>transformation <span class="op">=</span> isl.UnionMap(<span class="st">"{[i, 0] -&gt; [0, i]; [i, 1] -&gt; [1, i]}"</span>)</span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a>transformed <span class="op">=</span> original.apply_range(transformation)</span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a>print_before_after(domain, original, transformed)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<b>Before Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = 0; c0 &lt;= n; c0 += 1) {
  S(c0);
  T(c0);
}
</code></pre>
<b>After Transform:</b>
<pre class="code"><code class="cpp hljs">{
  for (int c1 = 0; c1 &lt;= n; c1 += 1)
    S(c1);
  for (int c1 = 0; c1 &lt;= n; c1 += 1)
    T(c1);
}
</code></pre>
</section>
<section id="loop-interchange" class="level1">
<h1>Loop Interchange</h1>
<p>循环顺序交换</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb168"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> isl.UnionSet(<span class="st">"[n,m] -&gt; {S[i,j] : 0 &lt;= i &lt;= n and 0 &lt;= j &lt;= m }"</span>)</span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a>original <span class="op">=</span> isl.UnionMap(<span class="st">"{S[i,j] -&gt; [i, j]}"</span>)</span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>transformation <span class="op">=</span> isl.UnionMap(<span class="st">"{[i, j] -&gt; [j, i]}"</span>)</span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>transformed <span class="op">=</span> original.apply_range(transformation)</span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a>print_before_after(domain, original, transformed)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<b>Before Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = 0; c0 &lt;= n; c0 += 1)
  for (int c1 = 0; c1 &lt;= m; c1 += 1)
    S(c0, c1);
</code></pre>
<b>After Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = 0; c0 &lt;= m; c0 += 1)
  for (int c1 = 0; c1 &lt;= n; c1 += 1)
    S(c1, c0);
</code></pre>
</section>
<section id="strip-mining" class="level1">
<h1>Strip Mining</h1>
<p>Strip mining是将单个循环按chunk分离为两个循环, 外循环在每个blocks上迭代, 内循环在每个block内部进行迭代.</p>
<p><strong>Benefits:</strong></p>
<ul>
<li>构建loop tiling和unroll-and-jam的block</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb169"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> isl.UnionSet(<span class="st">"{S[i] : 0 &lt;= i &lt; 1024 }"</span>)</span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>original <span class="op">=</span> isl.UnionMap(<span class="st">"{S[i] -&gt; [i]}"</span>)</span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>transformation <span class="op">=</span> isl.UnionMap(<span class="st">"{[i] -&gt; [floor(i/4), i % 4]}"</span>)</span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a>transformed <span class="op">=</span> original.apply_range(transformation)</span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a>print_before_after(domain, original, transformed)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<b>Before Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = 0; c0 &lt;= 1023; c0 += 1)
  S(c0);
</code></pre>
<b>After Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = 0; c0 &lt;= 255; c0 += 1)
  for (int c1 = 0; c1 &lt;= 3; c1 += 1)
    S(4 * c0 + c1);
</code></pre>
</section>
<section id="loop-tiling" class="level1">
<h1>Loop Tiling</h1>
<p>loop tiling是将多维循环切分为group,即tile. 首先一组外部循环在外部循环在所有的tile上迭代, point loops则在每个tile的points上迭代.</p>
<p><strong>Benefits:</strong></p>
<ul>
<li>增加数据局部性</li>
<li>更加粗粒度的并行</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb170"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> isl.UnionSet(<span class="st">"{S[i,j] : 0 &lt;= i,j &lt; 1024 }"</span>)</span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a>original <span class="op">=</span> isl.UnionMap(<span class="st">"{S[i,j] -&gt; [i,j]}"</span>)</span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>transformation <span class="op">=</span> isl.UnionMap(<span class="st">"{[i,j] -&gt; [floor(i/4), i % 4, floor(j/4), j % 4]}"</span>) <span class="co"># 和strip mining类似.</span></span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a>transformed <span class="op">=</span> original.apply_range(transformation)</span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a>print_before_after(domain, original, transformed)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<b>Before Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = 0; c0 &lt;= 1023; c0 += 1)
  for (int c1 = 0; c1 &lt;= 1023; c1 += 1)
    S(c0, c1);
</code></pre>
<b>After Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = 0; c0 &lt;= 255; c0 += 1)
  for (int c1 = 0; c1 &lt;= 3; c1 += 1)
    for (int c2 = 0; c2 &lt;= 255; c2 += 1)
      for (int c3 = 0; c3 &lt;= 3; c3 += 1)
        S(4 * c0 + c1, 4 * c2 + c3);
</code></pre>
</section>
<section id="unroll-and-jam" class="level1">
<h1>Unroll-and-jam</h1>
<p>Unroll-and-jam是将外部循环进行strip-mining分离为tile和point 循环,然后交换point loop和最内层的循环.</p>
<p><strong>Benefits:</strong></p>
<ul>
<li>使得外部循环向量化.</li>
</ul>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb171"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> isl.UnionSet(<span class="st">"{S[i,j] : 0 &lt;= i,j &lt; 1024 }"</span>)</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>original <span class="op">=</span> isl.UnionMap(<span class="st">"{S[i,j] -&gt; [i,j]}"</span>)</span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a>transformation <span class="op">=</span> isl.UnionMap(<span class="st">"{[i,j] -&gt; [floor(i/4), j, i % 4] }"</span>)</span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a>transformed <span class="op">=</span> original.apply_range(transformation)</span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a>print_before_after(domain, original, transformed)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<b>Before Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = 0; c0 &lt;= 1023; c0 += 1)
  for (int c1 = 0; c1 &lt;= 1023; c1 += 1)
    S(c0, c1);
</code></pre>
<b>After Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = 0; c0 &lt;= 255; c0 += 1)
  for (int c1 = 0; c1 &lt;= 1023; c1 += 1)
    for (int c2 = 0; c2 &lt;= 3; c2 += 1)
      S(4 * c0 + c2, c1);
</code></pre>
</section>
<section id="skewing" class="level1">
<h1>Skewing</h1>
<p>倾斜迭代域</p>
<p><strong>Benefits:</strong> - 使得部分无依赖的statement得以并行化.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb172"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> isl.UnionSet(<span class="st">"[n] -&gt; {S[i,j] : 0 &lt;= i,j &lt; n }"</span>)</span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>original <span class="op">=</span> isl.UnionMap(<span class="st">"{S[i,j] -&gt; [i,j]}"</span>)</span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>transformation <span class="op">=</span> isl.UnionMap(<span class="st">"{[i,j] -&gt; [i, i + j]}"</span>)</span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a>transformed <span class="op">=</span> original.apply_range(transformation)</span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a>print_before_after(domain, original, transformed)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<b>Before Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = 0; c0 &lt; n; c0 += 1)
  for (int c1 = 0; c1 &lt; n; c1 += 1)
    S(c0, c1);
</code></pre>
<b>After Transform:</b>
<pre class="code"><code class="cpp hljs">for (int c0 = 0; c0 &lt; n; c0 += 1)
  for (int c1 = c0; c1 &lt; n + c0; c1 += 1)
    S(c0, -c0 + c1);
</code></pre>
</section>
<section id="ast-generation" class="level1">
<h1>AST Generation</h1>
<br>
<center>
<table>
<tbody><tr>
<td>
<center>
<b>Polyhedral Model</b>
</center>
</td>
<td>
</td>
<td>
<center>
<b>Imperative Program</b>
</center>
</td></tr>
<tr>
<td>
<p><b>Iteration Domain</b><br>
<br></p>
<p>$ { T[i,j] &lt; i j &lt; 10; S[i,0] &lt; i }$</p>
<p><br> <br></p>
<p><b>Schedule</b> <br></p>
<p>$ { T[i,j] ; S[i,0] }$</p>
</td>
<td>
<p>&nbsp; &nbsp; &nbsp; $ $ &nbsp; &nbsp; &nbsp;</p>
</td>
<td>
<center>
<p><br></p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb173"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> N <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> X<span class="op">[</span>N<span class="op">],</span> Y<span class="op">[</span>N<span class="op">],</span> Z<span class="op">[</span><span class="dv">2</span><span class="op">*</span>N<span class="op">];</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">2</span><span class="op">*</span>N<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a>S<span class="op">:</span>  Z<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> N<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">;</span> j <span class="op">&lt;=</span> N<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span></span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a>T<span class="op">:</span>      Z<span class="op">[</span>i <span class="op">+</span> j<span class="op">]</span> <span class="op">+=</span> A<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> B<span class="op">[</span>j<span class="op">];</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</center></td>
</tr>
</tbody></table>
</center>
<p><br></p>
<p><a href="https://dl.acm.org/doi/10.1145/2743016">Polyhedral AST generation is more than scanning polyhedra</a></p>
<section id="generate-an-ast" class="level2">
<h2 class="anchored" data-anchor-id="generate-an-ast">Generate an AST</h2>
<section id="define-a-simple-polyhedral-program-description" class="level3">
<h3 class="anchored" data-anchor-id="define-a-simple-polyhedral-program-description">Define a simple polyhedral program description</h3>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb174"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> islpy <span class="im">as</span> isl</span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> islplot.plotter <span class="im">import</span> <span class="op">*</span></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a>context <span class="op">=</span> isl.Set(<span class="st">"{ : }"</span>)</span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> isl.Set(<span class="st">"{ S[t,i] : 1 &lt;=t&lt;=5 and 1&lt;=i&lt;=10 }"</span>)</span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a>schedule <span class="op">=</span> isl.Map(<span class="st">"{ S[t,i] -&gt; T[t+1,i+t+10] }"</span>)</span>
<span id="cb174-7"><a href="#cb174-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-8"><a href="#cb174-8" aria-hidden="true" tabindex="-1"></a>schedule_domain <span class="op">=</span> schedule.intersect_domain(domain)</span>
<span id="cb174-9"><a href="#cb174-9" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>[<span class="dv">10</span>, <span class="dv">7</span>])</span>
<span id="cb174-10"><a href="#cb174-10" aria-hidden="true" tabindex="-1"></a>plot_set_points(domain)</span>
<span id="cb174-11"><a href="#cb174-11" aria-hidden="true" tabindex="-1"></a>plot_map(schedule_domain)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p><img src="polyherdal-playground/07_ast-generation_1_0.png" class="img-fluid"></p>
</section>
</section>
<section id="translate-polyhedral-program-description-to-an-ast" class="level2">
<h2 class="anchored" data-anchor-id="translate-polyhedral-program-description-to-an-ast">Translate polyhedral program description to an AST</h2>
<p>最终生成的AST是实际的AST, 可以通过树操作对其进行遍历和检查.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb175"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CSource():</span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, ast):</span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.source <span class="op">=</span> ast</span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _repr_html_(<span class="va">self</span>):</span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="st">"&lt;pre class='code'&gt;&lt;code class=</span><span class="ch">\"</span><span class="st">cpp hljs</span><span class="ch">\"</span><span class="st">&gt;"</span> <span class="op">+</span> <span class="va">self</span>.source.to_C_str() <span class="op">+</span> <span class="st">"&lt;/code&gt;&lt;/pre&gt;"</span></span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CSourceComparer():</span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, before: CSource, after: CSource):</span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.before <span class="op">=</span> before</span>
<span id="cb175-13"><a href="#cb175-13" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.after <span class="op">=</span> after</span>
<span id="cb175-14"><a href="#cb175-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-15"><a href="#cb175-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> _repr_html_(<span class="va">self</span>):</span>
<span id="cb175-16"><a href="#cb175-16" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> <span class="st">"&lt;b&gt;Before Transform:&lt;/b&gt;</span><span class="ch">\n</span><span class="st">"</span></span>
<span id="cb175-17"><a href="#cb175-17" aria-hidden="true" tabindex="-1"></a>    s <span class="op">+=</span> <span class="va">self</span>.before._repr_html_()</span>
<span id="cb175-18"><a href="#cb175-18" aria-hidden="true" tabindex="-1"></a>    s <span class="op">+=</span> <span class="st">"&lt;b&gt;After Transform:&lt;/b&gt;</span><span class="ch">\n</span><span class="st">"</span></span>
<span id="cb175-19"><a href="#cb175-19" aria-hidden="true" tabindex="-1"></a>    s <span class="op">+=</span> <span class="va">self</span>.after._repr_html_()</span>
<span id="cb175-20"><a href="#cb175-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s</span>
<span id="cb175-21"><a href="#cb175-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-22"><a href="#cb175-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_code(ast):</span>
<span id="cb175-23"><a href="#cb175-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> CSource(ast)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb176"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a>build <span class="op">=</span> isl.AstBuild.from_context(context) </span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>ast <span class="op">=</span> build.node_from_schedule_map(schedule.intersect_domain(domain))</span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>print_code(ast) <span class="co"># 这里生成的domain实际上被isl进行了优化.</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre class="code"><code class="cpp hljs">for (int c0 = 2; c0 &lt;= 6; c0 += 1)
  for (int c1 = c0 + 10; c1 &lt;= c0 + 19; c1 += 1)
    S(c0 - 1, -c0 + c1 - 9);
</code></pre>
</section>
<section id="ast-generation-for-constraint-sets" class="level2">
<h2 class="anchored" data-anchor-id="ast-generation-for-constraint-sets">AST Generation for Constraint Sets</h2>
<p>通常只有当满足特定条件时才可以使用一些transformation优化程序, 要始终实施这种优化方式的话, 那么需要将代码分为不同版本, 当满足特定条件时执行优化后的代码, 否则执行非优化的代码.</p>
<p>一个简单的例子:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb177"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">long</span> n<span class="op">,</span> A<span class="op">[][</span><span class="dv">100</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a>      A<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> i<span class="op">+</span>j<span class="op">;</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>这个代码代码当j小于100时会有更简单的依赖, 也就是要求<code>n&lt;100</code>. 那么就可以使用如下的方法来保证优化后不出错误.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb178"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">long</span> n<span class="op">,</span> A<span class="op">[][</span><span class="dv">100</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">100</span><span class="op">)</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// optimized code</span></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span></span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// otherwise</span></span>
<span id="cb178-6"><a href="#cb178-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>isl的AST generator允许生成任意来自isl的约束bool条件集合.</p>
</section>
<section id="a-simple-constraint-set" class="level2">
<h2 class="anchored" data-anchor-id="a-simple-constraint-set">A simple constraint set</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb179"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>condition <span class="op">=</span> isl.Set(<span class="st">"[n] -&gt; {: n &lt; 100}"</span>)</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>expr <span class="op">=</span> build.expr_from_set(condition)</span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(expr.to_C_str())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>n &lt;= 99</code></pre>
</section>
<section id="recovery-of-modulo-expressions" class="level2">
<h2 class="anchored" data-anchor-id="recovery-of-modulo-expressions">Recovery of modulo expressions</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb181"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a>condition <span class="op">=</span> isl.Set(<span class="st">"[n, m] -&gt; {: n % 100 = 2}"</span>)</span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>expr <span class="op">=</span> build.expr_from_set(condition)</span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(expr.to_C_str())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>(n - 2) % 100 == 0</code></pre>
</section>
<section id="verification-of-complex-conditions" class="level2">
<h2 class="anchored" data-anchor-id="verification-of-complex-conditions">Verification of complex conditions</h2>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb183"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a>condition <span class="op">=</span> isl.Set(<span class="st">"[n, m] -&gt; {: (n != 0 implies m = 5) or n + m = 42}"</span>)</span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>expr <span class="op">=</span> build.expr_from_set(condition)</span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(expr.to_C_str())</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>m == 5 || n == 0 || n + m == 42</code></pre>
</section>
</section>
<section id="parse-c-code" class="level1">
<h1>Parse C Code</h1>
<p>需要手动编译安装pet库.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb185"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pet</span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tempfile</span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_code(source: <span class="bu">str</span>, func_name: <span class="bu">str</span>):</span>
<span id="cb185-7"><a href="#cb185-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">with</span> <span class="bu">open</span>(<span class="st">"/tmp/parse_code.c"</span>, <span class="st">"w"</span>) <span class="im">as</span> f:</span>
<span id="cb185-8"><a href="#cb185-8" aria-hidden="true" tabindex="-1"></a>    f.write(source)</span>
<span id="cb185-9"><a href="#cb185-9" aria-hidden="true" tabindex="-1"></a>  scop <span class="op">=</span> pet.scop.extract_from_C_source(<span class="st">"/tmp/parse_code.c"</span>, func_name)</span>
<span id="cb185-10"><a href="#cb185-10" aria-hidden="true" tabindex="-1"></a>  context <span class="op">=</span> scop.get_context()</span>
<span id="cb185-11"><a href="#cb185-11" aria-hidden="true" tabindex="-1"></a>  schedule <span class="op">=</span> scop.get_schedule()</span>
<span id="cb185-12"><a href="#cb185-12" aria-hidden="true" tabindex="-1"></a>  reads <span class="op">=</span> scop.get_may_reads()</span>
<span id="cb185-13"><a href="#cb185-13" aria-hidden="true" tabindex="-1"></a>  writes <span class="op">=</span> scop.get_may_writes()</span>
<span id="cb185-14"><a href="#cb185-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (context, schedule, reads, writes)</span>
<span id="cb185-15"><a href="#cb185-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-16"><a href="#cb185-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-17"><a href="#cb185-17" aria-hidden="true" tabindex="-1"></a>context, schedule, reads, writes <span class="op">=</span> parse_code(<span class="st">"""</span></span>
<span id="cb185-18"><a href="#cb185-18" aria-hidden="true" tabindex="-1"></a><span class="st">void rotate(int N, int A[N], int B[N])</span></span>
<span id="cb185-19"><a href="#cb185-19" aria-hidden="true" tabindex="-1"></a><span class="st">{</span></span>
<span id="cb185-20"><a href="#cb185-20" aria-hidden="true" tabindex="-1"></a><span class="st">#pragma scop</span></span>
<span id="cb185-21"><a href="#cb185-21" aria-hidden="true" tabindex="-1"></a><span class="st">    for (int i = 0; i &lt; N; ++i)</span></span>
<span id="cb185-22"><a href="#cb185-22" aria-hidden="true" tabindex="-1"></a><span class="st">        A[i] = i == 0 ? B[N - 1] : B[i - 1];</span></span>
<span id="cb185-23"><a href="#cb185-23" aria-hidden="true" tabindex="-1"></a><span class="st">#pragma endscop</span></span>
<span id="cb185-24"><a href="#cb185-24" aria-hidden="true" tabindex="-1"></a><span class="st">}</span></span>
<span id="cb185-25"><a href="#cb185-25" aria-hidden="true" tabindex="-1"></a><span class="st">"""</span>, <span class="st">"rotate"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[N] -&gt; {  : -2147483648 &lt;= N &lt;= 2147483647 }
{ domain: "[N] -&gt; { S_0[i] : 0 &lt;= i &lt; N }", child: { schedule: "[N] -&gt; L_0[{ S_0[i] -&gt; [(i)] }]" } }
[N] -&gt; { S_0[i] -&gt; B[-1 + i] : 0 &lt; i &lt; N; S_0[i = 0] -&gt; B[-1 + N] : N &gt; 0 }
[N] -&gt; { S_0[i] -&gt; A[i] : 0 &lt;= i &lt; N }</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb187"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(context)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[N] -&gt; {  : -2147483648 &lt;= N &lt;= 2147483647 }</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb189"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(schedule)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>{ domain: "[N] -&gt; { S_0[i] : 0 &lt;= i &lt; N }", child: { schedule: "[N] -&gt; L_0[{ S_0[i] -&gt; [(i)] }]" } }</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb191"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(reads)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[N] -&gt; { S_0[i] -&gt; B[-1 + i] : 0 &lt; i &lt; N; S_0[i = 0] -&gt; B[-1 + N] : N &gt; 0 }</code></pre>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb193"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(writes)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<pre><code>[N] -&gt; { S_0[i] -&gt; A[i] : 0 &lt;= i &lt; N }</code></pre>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/zhen8838\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="zhen8838/zhen8838.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>