<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.27">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2026-02-03">

<title>Cute概念速通 – Zheng’s Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../assets/favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-8b4baf804e461d9b72633f0de59a0cac.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-7072389654d23eff08f359f9aa0d1ee7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Zheng’s Notes</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#layout-component" id="toc-layout-component" class="nav-link active" data-scroll-target="#layout-component">Layout Component</a>
  <ul class="collapse">
  <li><a href="#mode" id="toc-mode" class="nav-link" data-scroll-target="#mode">Mode</a></li>
  <li><a href="#domain-codomain" id="toc-domain-codomain" class="nav-link" data-scroll-target="#domain-codomain">Domain &amp; Codomain</a></li>
  </ul></li>
  <li><a href="#complement" id="toc-complement" class="nav-link" data-scroll-target="#complement">Complement</a></li>
  <li><a href="#composition" id="toc-composition" class="nav-link" data-scroll-target="#composition">Composition</a></li>
  <li><a href="#divide" id="toc-divide" class="nav-link" data-scroll-target="#divide">Divide</a>
  <ul class="collapse">
  <li><a href="#zipped_dividetiled_divide" id="toc-zipped_dividetiled_divide" class="nav-link" data-scroll-target="#zipped_dividetiled_divide">zipped_divide/tiled_divide</a></li>
  </ul></li>
  <li><a href="#product" id="toc-product" class="nav-link" data-scroll-target="#product">Product</a>
  <ul class="collapse">
  <li><a href="#zipped-product-tiled-product" id="toc-zipped-product-tiled-product" class="nav-link" data-scroll-target="#zipped-product-tiled-product">Zipped Product &amp; Tiled Product</a></li>
  <li><a href="#block-rroduct" id="toc-block-rroduct" class="nav-link" data-scroll-target="#block-rroduct">Block Rroduct</a></li>
  <li><a href="#raked-product" id="toc-raked-product" class="nav-link" data-scroll-target="#raked-product">Raked product</a></li>
  </ul></li>
  <li><a href="#inverse" id="toc-inverse" class="nav-link" data-scroll-target="#inverse">Inverse</a>
  <ul class="collapse">
  <li><a href="#right-inverse" id="toc-right-inverse" class="nav-link" data-scroll-target="#right-inverse">Right Inverse</a></li>
  </ul></li>
  <li><a href="#thread-value-layout" id="toc-thread-value-layout" class="nav-link" data-scroll-target="#thread-value-layout">Thread Value layout</a></li>
  <li><a href="#swizzlebms" id="toc-swizzlebms" class="nav-link" data-scroll-target="#swizzlebms">Swizzle&lt;B,M,S&gt;</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Cute概念速通</h1>
  <div class="quarto-categories">
    <div class="quarto-category">推理框架</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 3, 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>这篇文章将快速的介绍Cute中的一些基本概念、 layout algorithm、swizzle等，具体代码位于<a href="https://github.com/zhen8838/handson-polyhedral/blob/main/16_cute_concepts.ipynb">cute概念速通</a>。</p>
<!--more-->
<div id="e2802a82" class="cell" data-execution_count="35">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pycute <span class="im">as</span> cute</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> itertools</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>np.set_printoptions(linewidth<span class="op">=</span><span class="dv">100</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<section id="layout-component" class="level1">
<h1>Layout Component</h1>
<p>先介绍Layout本身， 是由Shape,Stride组成的一个结构体， 其中Shape/Stride都是一个可嵌套的向量。</p>
<p>他们组成的Layout是一个从index到offset的函数，它的数学表示为：</p>
<pre><code>Layout(coord) = offset</code></pre>
<p>实际计算过程如下：</p>
<pre><code>Coord ∘ Shape =&gt; Index
Index ∘ Stride =&gt; Offset</code></pre>
<div id="07ecb075" class="cell" data-execution_count="36">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>layout <span class="op">=</span> cute.Layout((<span class="dv">2</span>, <span class="dv">3</span>), (<span class="dv">3</span>, <span class="dv">6</span>))</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>coord <span class="op">=</span> (<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'offset: </span><span class="sc">{</span>layout(coord)<span class="sc">}</span><span class="ss">'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>offset: 15</code></pre>
</div>
</div>
<section id="mode" class="level2">
<h2 class="anchored" data-anchor-id="mode">Mode</h2>
<p>layout可以通过mode取其中的每个元素</p>
<div id="19c19957" class="cell" data-execution_count="37">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'mode 0: </span><span class="sc">{</span>layout[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'mode 1: </span><span class="sc">{</span>layout[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>mode 0: 2:3
mode 1: 3:6</code></pre>
</div>
</div>
</section>
<section id="domain-codomain" class="level2">
<h2 class="anchored" data-anchor-id="domain-codomain">Domain &amp; Codomain</h2>
<p>domain是layout的索引空间，codomain是layout的访问空间。</p>
<div id="2a672ee6" class="cell" data-execution_count="38">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'domain: </span><span class="sc">{</span>layout<span class="sc">.</span>size()<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'codomain: </span><span class="sc">{</span>layout<span class="sc">.</span>cosize()<span class="sc">}</span><span class="ss">'</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>domain: 6
codomain: 16</code></pre>
</div>
</div>
</section>
</section>
<section id="complement" class="level1">
<h1>Complement</h1>
<p>先解释一下为什么需要补集，观察上面，可以发现Layout的domain != codomain，这就意味着在内存中某些位置是不能被访问到的。 而补集就是这些不能被访问到的位置所构成的layout。</p>
<p>Complement是许多layout algorithm中常用的一个操作。 他的主要原理是通过计算codomain，再分解当前的Shape/Stride得到无法访问到的位置，剩余部分所构成的原layout就是补集。</p>
<div id="855b4346" class="cell" data-execution_count="39">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>comp <span class="op">=</span> cute.complement(layout)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>comp</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-display" data-execution_count="39">
<pre><code>Layout(3,1)</code></pre>
</div>
</div>
<div id="a984b3ba" class="cell" data-execution_count="40">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>full <span class="op">=</span> cute.make_layout(layout, comp) <span class="co"># layout ⋆ comp(layout) 得到当前全集 </span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(full)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> full.size() <span class="op">==</span> full.cosize() <span class="co"># size 和 cosize 相等，说明是全集</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>((2, 3), 3):((3, 6), 1)</code></pre>
</div>
</div>
<div id="11b4a6b9" class="cell" data-execution_count="41">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 补集的逻辑很简单，就是从最大N开始不停的除shape*stride</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>comp <span class="op">=</span> cute.complement(layout) </span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(comp) </span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>comp <span class="op">=</span> cute.complement(layout, <span class="dv">54</span>) <span class="co"># 也可以设置更大codom来构建补集</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(comp) <span class="co"># 也就是说如果补的len实际上得先看内部有个多少空洞， 然后最后再添加一个能重复到max idx的。</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cute.size(layout), cute.cosize(layout))</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cute.size(comp), cute.cosize(comp))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>3:1
(3, 3):(1, 18)
6 16
9 39</code></pre>
</div>
</div>
</section>
<section id="composition" class="level1">
<h1>Composition</h1>
<p>C = A ∘ B 表示用B的codomain映射到A的domain上, 这里需要注意是B的codomain需要和A的domain匹配，并且C的domain是C的domain，而codomain是A的domain。</p>
<pre><code>C(coord) = A(B(coord))</code></pre>
<p>composition后的取offsetC等价于如下的公式。</p>
<pre><code>B(coord) =&gt; offsetB
index2crd(offsetB, A.shape) =&gt; coordA
A(coordA) =&gt; offsetC</code></pre>
<p>这里还有一个细节需要注意, 实际index2crd的过程是从左向右进行拆分的，这其实和cute中默认column major的布局对应。这也就是为什么cute中通常把tile的内层放到最左边，而剩余部分放到右边。这样composite出来的结果索引和cute中默认的column major布局是一致的。</p>
<div id="64aaa5ad" class="cell" data-execution_count="42">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> cute.Layout((<span class="dv">8</span>), (<span class="dv">4</span>))</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> cute.Layout((<span class="dv">4</span>), (<span class="dv">1</span>))</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'x ∘ y:'</span>, cute.composition(x, y)) <span class="co"># 此时输出的dom变成了y的dom</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'y ∘ x:'</span>, cute.composition(y, x)) <span class="co"># 此时输出的dom变成了x的dom</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>x ∘ y: 4:4
y ∘ x: 8:4</code></pre>
</div>
</div>
</section>
<section id="divide" class="level1">
<h1>Divide</h1>
<p>他的公式如下</p>
<pre><code>C = A ∘ (B ⋆ comp(B, size(A))). </code></pre>
<p>扩展B的codomain到A的domain，然后进行composite。</p>
<p>实际上divide通常是用于实现tiling， 设想B作为一个固定的inner factor， 将他补到A的domain， 那么(B * restB)匹配A的domain，此时restB就相当于outer factor。 最后再进行一次composite， 就得到了C，此时C的domain由(inner factor,outer factor)组成, 也就是呈现了tiled A。</p>
<div id="2d71228d" class="cell" data-execution_count="43">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> cute.Layout((<span class="dv">128</span>, <span class="dv">32</span>), (<span class="dv">32</span>, <span class="dv">1</span>))</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'original:'</span>, a[<span class="dv">0</span>]) <span class="co"># 对于128，采用不同的factor去divide，会得到不同的结果</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'divide by 8:'</span>, cute.logical_divide(a[<span class="dv">0</span>], cute.Layout(<span class="dv">8</span>)))</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'divide by 4:'</span>, cute.logical_divide(a[<span class="dv">0</span>], cute.Layout(<span class="dv">4</span>)))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>original: 128:32
divide by 8: (8, 16):(32, 256)
divide by 4: (4, 32):(32, 128)</code></pre>
</div>
</div>
<section id="zipped_dividetiled_divide" class="level2">
<h2 class="anchored" data-anchor-id="zipped_dividetiled_divide">zipped_divide/tiled_divide</h2>
<p>不同divide的区别在于返回的layout的group方式不同:</p>
<div id="89c57089" class="cell" data-execution_count="44">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'zipped_divide:'</span>, cute.zipped_divide(a, (<span class="dv">8</span>, <span class="dv">4</span>)))</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'tiled_divide:'</span>, cute.tiled_divide(a, (<span class="dv">8</span>, <span class="dv">4</span>)))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>zipped_divide: ((8, 4), (16, 8)):((32, 1), (256, 4))
tiled_divide: ((8, 4), 16, 8):((32, 1), 256, 4)</code></pre>
</div>
</div>
</section>
</section>
<section id="product" class="level1">
<h1>Product</h1>
<p>公式如下：</p>
<pre><code>C = A ⋆ (comp(A, size(A) * cosize(B)) ∘ B)</code></pre>
<p>如果是divide是拆分layout A，那么product就是重复layout A。保持A本身不变，然后整体是需要把A重复B次，所以需要先补到(size A) * (cosize B)， 再配合一个composite让B映射每一个A上。最后再拼接原始的A，得到C具备 (size A) * (size B) 的domain。</p>
<div id="f50be42e" class="cell" data-execution_count="45">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>ta <span class="op">=</span> cute.Layout((<span class="dv">2</span>, <span class="dv">2</span>), (<span class="dv">4</span>, <span class="dv">1</span>))</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>tb <span class="op">=</span> cute.Layout(<span class="dv">6</span>, <span class="dv">1</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>max_idx <span class="op">=</span> ta.size() <span class="op">*</span> tb.cosize()</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>comp_ta <span class="op">=</span> cute.complement(ta, max_idx)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'max_idx:'</span>, max_idx, <span class="st">'complement:'</span>, comp_ta)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"composite"</span>, cute.composition(comp_ta, tb))</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>tc <span class="op">=</span> cute.make_layout(ta, cute.composition(comp_ta, tb))</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'product:'</span>, tc)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>max_idx: 24 complement: (2, 3):(2, 8)
composite (2, 3):(2, 8)
product: ((2, 2), (2, 3)):((4, 1), (2, 8))</code></pre>
</div>
</div>
<section id="zipped-product-tiled-product" class="level2">
<h2 class="anchored" data-anchor-id="zipped-product-tiled-product">Zipped Product &amp; Tiled Product</h2>
<p>同样也是把inner part放到左边，并且也是在group方式上存在区别。</p>
<div id="123e8dc1" class="cell" data-execution_count="46">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'zipped:'</span>, cute.zipped_product(a, (<span class="dv">8</span>, <span class="dv">4</span>)))</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'tiled:'</span>, cute.tiled_product(a, (<span class="dv">8</span>, <span class="dv">4</span>)))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>zipped: ((128, 32), (8, 4)):((32, 1), (1, 32))
tiled: ((128, 32), 8, 4):((32, 1), 1, 32)</code></pre>
</div>
</div>
</section>
<section id="block-rroduct" class="level2">
<h2 class="anchored" data-anchor-id="block-rroduct">Block Rroduct</h2>
<p>如果是logical product，那么最后的domain就是(A, B)，按照cute默认的迭代方式进行访问，就是先访问A的所有元素，然后按B的方式访问扩展后的A元素。</p>
<p>但是有没有可能，通过调整domain，在默认的迭代方式下实现不同的访问模式呢？ 比如我们有一个小的2维矩阵tiledA(m,n)，它匹配硬件计算的粒度，但是在内存中他是以A(3m, 4n)的形式存储的。 那么我们希望在默认的迭代方式下， 先将A的n维度访问完，再访问m维度，这个需求就需要blocked product来实现。</p>
<p>其实blocked product的本质就是调整logical product的domain顺序， 让inner part的维度在左边， outer part的维度在右边。 这样在默认的迭代方式下，就实现了先访问inner part，再访问outer part的效果。而实际上在内存上的元素顺序并没有任何改变。</p>
<div id="d7c2a17c" class="cell" data-execution_count="47">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> hier_zip(layoutA, layoutB):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">assert</span> <span class="bu">len</span>(layoutA) <span class="op">==</span> <span class="bu">len</span>(layoutB)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> cute.make_layout(itertools.chain((cute.make_layout(layoutA[i], layoutB[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="bu">len</span>(layoutA)))))</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> blocked_product(block, tiler):</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>  res <span class="op">=</span> cute.logical_product(block, tiler)</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> hier_zip(res[<span class="dv">0</span>], res[<span class="dv">1</span>])</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> cute.Layout((<span class="dv">2</span>, <span class="dv">5</span>), (<span class="dv">5</span>, <span class="dv">1</span>))</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> cute.Layout((<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">1</span>, <span class="dv">3</span>))</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>logical_producted <span class="op">=</span> cute.logical_product(a, b)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>blocked_producted <span class="op">=</span> blocked_product(a, b)  <span class="co"># 实际上就是把logical product拆分且zip</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"logical_producted"</span>, logical_producted)</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"blocked_producted"</span>, blocked_producted)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>logical_producted ((2, 5), (3, 4)):((5, 1), (10, 30))
blocked_producted ((2, 3), (5, 4)):((5, 10), (1, 30))</code></pre>
</div>
</div>
<p>我写了一个print_offsets的函数，打印按默认的访问顺序下，layout所映射的offset的情况， 用于展示blocked product的效果。 首先是看logical product的情况，这里crd默认也是按col major生成的，所以layout a会按列呈现在offset矩阵中：</p>
<div id="abe94e4c" class="cell" data-execution_count="48">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> print_offsets(layout: cute.Layout):</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  rk <span class="op">=</span> <span class="bu">len</span>(layout)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  shape <span class="op">=</span> [layout[i].size() <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(rk)]</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  arr <span class="op">=</span> np.zeros(shape, dtype<span class="op">=</span>np.int32)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> crd <span class="kw">in</span> itertools.product(<span class="op">*</span>[<span class="bu">range</span>(shape[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(rk)]):</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    arr[crd] <span class="op">=</span> layout(crd)</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(arr)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>print_offsets(logical_producted)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[[  0  10  20  30  40  50  60  70  80  90 100 110]
 [  5  15  25  35  45  55  65  75  85  95 105 115]
 [  1  11  21  31  41  51  61  71  81  91 101 111]
 [  6  16  26  36  46  56  66  76  86  96 106 116]
 [  2  12  22  32  42  52  62  72  82  92 102 112]
 [  7  17  27  37  47  57  67  77  87  97 107 117]
 [  3  13  23  33  43  53  63  73  83  93 103 113]
 [  8  18  28  38  48  58  68  78  88  98 108 118]
 [  4  14  24  34  44  54  64  74  84  94 104 114]
 [  9  19  29  39  49  59  69  79  89  99 109 119]]</code></pre>
</div>
</div>
<p>但是如果采用blocked product，则是按<code>[m * 3, n * 4]</code>这样的shape来采样，当我们访问A的n维度时，是优先访问完一个tile的n维度，然后跳到下一个tile的n维度进行访问：</p>
<div id="926c76fc" class="cell" data-execution_count="49">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>print_offsets(blocked_producted)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[[  0   1   2   3   4  30  31  32  33  34  60  61  62  63  64  90  91  92  93  94]
 [  5   6   7   8   9  35  36  37  38  39  65  66  67  68  69  95  96  97  98  99]
 [ 10  11  12  13  14  40  41  42  43  44  70  71  72  73  74 100 101 102 103 104]
 [ 15  16  17  18  19  45  46  47  48  49  75  76  77  78  79 105 106 107 108 109]
 [ 20  21  22  23  24  50  51  52  53  54  80  81  82  83  84 110 111 112 113 114]
 [ 25  26  27  28  29  55  56  57  58  59  85  86  87  88  89 115 116 117 118 119]]</code></pre>
</div>
</div>
<p>本质上两个layout表达的offset是相同的，区别在于使用<code>cute默认的迭代顺序</code>下他们的行为，这一点其实是十分重要的，这会令logical/blocked layout进行composite的时候得到完全不同的结果。</p>
<p>当然cute layout的自由度还是很大的，比如对于logical product的结果，我们也可以自行按block coord来采样，再采样tile内部，也是可以得到相同的offset序列的：</p>
<div id="2d7b3c65" class="cell" data-execution_count="50">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>tile <span class="op">=</span> logical_producted[<span class="dv">0</span>]</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>block <span class="op">=</span> logical_producted[<span class="dv">1</span>]</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> block_crd <span class="kw">in</span> itertools.product(<span class="op">*</span>[<span class="bu">range</span>(mode.size()) <span class="cf">for</span> mode <span class="kw">in</span> block]):</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  block_offset <span class="op">=</span> block(block_crd)</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  array <span class="op">=</span> np.zeros(tile.shape, dtype<span class="op">=</span>np.int32)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> tile_crd <span class="kw">in</span> itertools.product(<span class="op">*</span>[<span class="bu">range</span>(mode.size()) <span class="cf">for</span> mode <span class="kw">in</span> tile]):</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    offset <span class="op">=</span> tile(tile_crd)</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>    array[tile_crd] <span class="op">=</span> offset <span class="op">+</span> block_offset</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f"block </span><span class="sc">{</span>block_crd<span class="sc">}</span><span class="ss">:</span><span class="ch">\n</span><span class="ss">"</span>, array)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>block (0, 0):
 [[0 1 2 3 4]
 [5 6 7 8 9]]
block (0, 1):
 [[30 31 32 33 34]
 [35 36 37 38 39]]
block (0, 2):
 [[60 61 62 63 64]
 [65 66 67 68 69]]
block (0, 3):
 [[90 91 92 93 94]
 [95 96 97 98 99]]
block (1, 0):
 [[10 11 12 13 14]
 [15 16 17 18 19]]
block (1, 1):
 [[40 41 42 43 44]
 [45 46 47 48 49]]
block (1, 2):
 [[70 71 72 73 74]
 [75 76 77 78 79]]
block (1, 3):
 [[100 101 102 103 104]
 [105 106 107 108 109]]
block (2, 0):
 [[20 21 22 23 24]
 [25 26 27 28 29]]
block (2, 1):
 [[50 51 52 53 54]
 [55 56 57 58 59]]
block (2, 2):
 [[80 81 82 83 84]
 [85 86 87 88 89]]
block (2, 3):
 [[110 111 112 113 114]
 [115 116 117 118 119]]</code></pre>
</div>
</div>
</section>
<section id="raked-product" class="level2">
<h2 class="anchored" data-anchor-id="raked-product">Raked product</h2>
<p>Raked product和blocked product类似，也是调整logical product的domain顺序，不过是把outer part的维度放到左边， inner part的维度放到右边。 这样在默认的迭代方式下，就实现了先访问outer part，再访问inner part的效果。而实际上在内存上的元素顺序并没有任何改变。</p>
<div id="c315ce69" class="cell" data-execution_count="51">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> raked_product(block, tiler):</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  res <span class="op">=</span> cute.logical_product(block, tiler)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> hier_zip(res[<span class="dv">1</span>], res[<span class="dv">0</span>])</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> cute.Layout((<span class="dv">2</span>, <span class="dv">5</span>), (<span class="dv">5</span>, <span class="dv">1</span>))</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> cute.Layout((<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">1</span>, <span class="dv">3</span>))</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>logical_producted <span class="op">=</span> cute.logical_product(a, b)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>raked_producted <span class="op">=</span> raked_product(a, b) <span class="co"># 实际上就是把logical layout进行了拆分zip, 不过顺序反过来了。</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'logical_producted'</span>, logical_producted)</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'raked_producted'</span>, raked_producted)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>logical_producted ((2, 5), (3, 4)):((5, 1), (10, 30))
raked_producted ((3, 2), (4, 5)):((10, 5), (30, 1))</code></pre>
</div>
</div>
<p>它同样也是先遍历完A的某一个维度，只是遍历维度内部的顺序从inner优先变成了outer优先。</p>
<div id="7250441f" class="cell" data-execution_count="52">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>print_offsets(raked_producted)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>[[  0  30  60  90   1  31  61  91   2  32  62  92   3  33  63  93   4  34  64  94]
 [ 10  40  70 100  11  41  71 101  12  42  72 102  13  43  73 103  14  44  74 104]
 [ 20  50  80 110  21  51  81 111  22  52  82 112  23  53  83 113  24  54  84 114]
 [  5  35  65  95   6  36  66  96   7  37  67  97   8  38  68  98   9  39  69  99]
 [ 15  45  75 105  16  46  76 106  17  47  77 107  18  48  78 108  19  49  79 109]
 [ 25  55  85 115  26  56  86 116  27  57  87 117  28  58  88 118  29  59  89 119]]</code></pre>
</div>
</div>
</section>
</section>
<section id="inverse" class="level1">
<h1>Inverse</h1>
<section id="right-inverse" class="level2">
<h2 class="anchored" data-anchor-id="right-inverse">Right Inverse</h2>
<p>它的数学表示为：</p>
<p>Layout_Rinv(Layout(index)) = index</p>
<p>原始的layout是一个从index到offset的函数，所以right inverse就是得到一个layout invese可以从offset 到 index。</p>
<pre><code>crd2idx(coord)
      |
      v
    index
      |
      v
  F_L(index) -&gt; offset
      ∧             |
      |             v
   index &lt;- F_Linv(offset)</code></pre>
<div id="4b3bd7fe" class="cell" data-execution_count="53">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>layout <span class="op">=</span> cute.Layout((<span class="dv">32</span>, <span class="dv">64</span>), (<span class="dv">64</span>, <span class="dv">1</span>))</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> cute.crd2idx((<span class="dv">3</span>, <span class="dv">4</span>), layout.shape)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'layout:'</span>, layout, <span class="st">"index:"</span>, x, <span class="st">"offset:"</span>, layout(<span class="dv">3</span>, <span class="dv">4</span>))  <span class="co"># 3 * 64 + 4</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>layout: (32, 64):(64, 1) index: 131 offset: 196</code></pre>
</div>
</div>
<div id="fb230971" class="cell" data-execution_count="54">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>layout_inv <span class="op">=</span> cute.right_inverse(layout)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> layout_inv(cute.idx2crd(<span class="dv">196</span>, layout_inv.shape))</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'layout_inv'</span>, layout_inv, <span class="st">"index:"</span>, <span class="dv">196</span>, <span class="st">"offset:"</span>, x)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>layout_inv (64, 32):(32, 1) index: 196 offset: 131</code></pre>
</div>
</div>
<p>所以其实它比较大的用处是, 这样可以快速找到原来的一个coord所对应的index</p>
<p>F_Linv(F_L(coord)) = index</p>
<div id="f16cca53" class="cell" data-execution_count="55">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>crd <span class="op">=</span> (<span class="dv">3</span>, <span class="dv">4</span>)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>index <span class="op">=</span> layout_inv(layout(<span class="op">*</span>crd))</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> layout(index) <span class="op">==</span> layout(<span class="op">*</span>crd)</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"we find the coord </span><span class="sc">{</span>crd<span class="sc">}</span><span class="ss">'s index is:"</span>, index)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>we find the coord (3, 4)'s index is: 131</code></pre>
</div>
</div>
</section>
</section>
<section id="thread-value-layout" class="level1">
<h1>Thread Value layout</h1>
<p>我的理解是这样，thread value layout(tv layout)本质上是提供了一个在thread level的sharding tensor在各个thread上访问local data的方式。 在cute的一个教程中，是这样描述tv layout的使用的：</p>
<pre><code>    (16,256)   :  (2048,1)
     ~~~~~~        ~~~~~~
        |             |        Tiled/Composed with TV Layout
        |             |    
        |             |    o   ((32,4),(8,4)):((128,4),(16,1))
        V             V         
~~~~~~~~~~~~~~~     ~~~~~~~~~~~~~~~~~~~ 
((32,4), (8,4))  :  ((4,8192),(1,2048))
    |      |
    |      `--------&gt; per thread fragment
    |
Thread Block
  Shape

Sliced to Thread local sub-tensor (a (4,8) tile):  tidfrgA[(tidx, None)]</code></pre>
<p>将一个<code>(16,256)</code>的tensor，按32线程，4warp的方式sharding到每个thread上， 每个thread访问一个<code>(4,8)</code>的local tile。 此时tv layout的作用就是提供一个方式，让每个thread可以访问到自己local tile的数据。</p>
<p>注意到这里<code>32线程，4warp的方式</code>是按照<code>(32,4)</code>的shape来描述的，这是因为cute的index to coord是按照从左向右拆分的，所以需要把thread维度放到左边， warp维度放到右边。 这样在默认的迭代方式下，<code>tidfrgA[(tidx, None)]</code>的<code>tidx</code>才能被正确映射到thread，warp上。</p>
<p>在<code>cutlass/python/CuTeDSL/cutlass/cute/core.py#L5093</code>中有一个make tv layout实现，我们来拆解一下：</p>
<div id="4b36b693" class="cell" data-execution_count="56">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. 首先cute的逻辑不是对原始tensor做拆分，而是对thread和value的layout做组合来构建tv layout</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>thr_layout <span class="op">=</span> cute.Layout((<span class="dv">4</span>, <span class="dv">32</span>), (<span class="dv">32</span>, <span class="dv">1</span>))  <span class="co"># 32 threads, 4warps</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>val_layout <span class="op">=</span> cute.Layout((<span class="dv">4</span>, <span class="dv">8</span>), (<span class="dv">8</span>, <span class="dv">1</span>))  <span class="co"># 每个thread访问4行， 每行8个元素</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. 此时thr layout作为block，val layout作为tiler，由于 raked product的结果是tiler优先</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 得到((val_m, thr_m), (val_n, thr_n)) -&gt; [1~M*N]的映射</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>layout_mn <span class="op">=</span> raked_product(thr_layout, val_layout)</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. 然后构建tv domain，即(thr_size, val_size)，这里thr_size=128, val_size=32</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 得到 (threads, values) -&gt; [1~M*N]的映射</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>thr_size, val_size <span class="op">=</span> cute.size(thr_layout), cute.size(val_layout)</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>tv_domain <span class="op">=</span> cute.Layout((thr_size, val_size))</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. layout_mn的右逆是得到了 [1~M*N] -&gt; ((val_m, thr_m), (val_n, thr_n))，</span></span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a><span class="co"># 进行composite： (threads, values) -&gt; [1~M*N] -&gt; [1~M*N] -&gt; ((val_m, thr_m), (val_n, thr_n))</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a><span class="co"># 得到 (threads, values) -&gt; ((val_m, thr_m), (val_n, thr_n))的映射</span></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>layout_tv <span class="op">=</span> cute.composition(cute.right_inverse(layout_mn), tv_domain)</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>tiler_mn <span class="op">=</span> <span class="bu">tuple</span>(cute.product(s) <span class="cf">for</span> s <span class="kw">in</span> layout_mn.shape)</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'tiler_mn:'</span>, tiler_mn)</span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'layout_tv:'</span>, layout_tv)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>tiler_mn: (16, 256)
layout_tv: ((32, 4), (8, 4)):((128, 4), (16, 1))</code></pre>
</div>
</div>
<p>至此得到了layout tv，但实际上它只映射到一个logical的(M,N)上。使用一个实际上的tiled tensor与它进行compose后，可以用layout tv去采样tiled tensor内的元素。 回想之前设计的value layout是<code>((4, 8), (8, 1))</code>，那么去取一个row major矩阵就可以是8个元素连续读，而取一个col major的矩阵就是4个元素连续读：</p>
<div id="84f85c24" class="cell" data-execution_count="57">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>tiledA <span class="op">=</span> cute.Layout((<span class="dv">16</span>, <span class="dv">256</span>), (<span class="dv">512</span>, <span class="dv">1</span>)) <span class="co"># row major tiled tensor</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"row major   tiledA: "</span>, cute.composition(tiledA, layout_tv)) <span class="co"># ... (8, 4) : ... (1,512)</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>tiledA <span class="op">=</span> cute.Layout((<span class="dv">16</span>, <span class="dv">256</span>), (<span class="dv">1</span>, <span class="dv">512</span>)) <span class="co"># colum marjor tiled tensor</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"colum major tiledA: "</span>, cute.composition(tiledA, layout_tv)) <span class="co"># ... (8, 4) : ... (512,1)</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>row major   tiledA:  ((32, 4), (8, 4)):((8, 2048), (1, 512))
colum major tiledA:  ((32, 4), (8, 4)):((4096, 4), (512, 1))</code></pre>
</div>
</div>
</section>
<section id="swizzlebms" class="level1">
<h1>Swizzle&lt;B,M,S&gt;</h1>
<p>Swizzle的本质上是将offset进行重映射到新的offset上，cute这里选择将offset的值拆分为行和列部分的组合，通过移动行和列所对应的bits实现行列交错， 从而将逻辑上同一列的地址映射到物理的不同列上。</p>
<pre><code>0bxxxxxxxxxxxxxxxYYYxxxxxxxZZZxxxx
                 ^-^       ^-^      B 是要移动的位个数
                              ^--^  M 保持不变的位个数
                   ^---------^      S 是移动的距离
                                      (pos shifts YYY to the right, neg shifts YYY to the left)
e.g. Given
0bxxxxxxxxxxxxxxxxYYxxxxxxxxxZZxxx
the result is
0bxxxxxxxxxxxxxxxxYYxxxxxxxxxAAxxx where AA = ZZ xor YY</code></pre>
<p>简单来说， Swizzle这里三个参数可理解为M是保持不变的位个数，对应连续读取的元素个数。S是移动的距离，看做逻辑上的列数。B是要移动的位个数，看作逻辑上的行数。 我下面设计了一个visualize_bank_distribution函数，用于展示swizzle前后，线程访问内存bank的分布情况。</p>
<div id="00b86425" class="cell" data-execution_count="58">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> visualize_bank_distribution(access_indices_per_thread, swizzle<span class="op">=</span><span class="va">None</span>, title<span class="op">=</span><span class="st">""</span>, cols<span class="op">=</span><span class="dv">32</span>):</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1) 先收集所有物理地址</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    phys_addrs <span class="op">=</span> []</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> tid, indices <span class="kw">in</span> access_indices_per_thread.items():</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ptr <span class="kw">in</span> indices:</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>            phys_ptr <span class="op">=</span> swizzle(ptr) <span class="cf">if</span> swizzle <span class="cf">else</span> ptr</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>            phys_addrs.append(phys_ptr)</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> phys_addrs:</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"No accesses."</span>)</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2) 以访问的最大地址决定可视化的“memory”规模</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>    max_addr <span class="op">=</span> <span class="bu">max</span>(phys_addrs)</span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>    total_elems <span class="op">=</span> max_addr <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>    rows <span class="op">=</span> (total_elems <span class="op">+</span> cols <span class="op">-</span> <span class="dv">1</span>) <span class="op">//</span> cols</span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 3) 用 cute.Layout 表示 bank 的二维布局 (row, col) -&gt; linear addr</span></span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>    bank_layout <span class="op">=</span> cute.Layout((rows, cols), (cols, <span class="dv">1</span>))</span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 4) 建立二维表记录每个地址的线程集合</span></span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a>    table <span class="op">=</span> [[<span class="bu">set</span>() <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(cols)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(rows)]</span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> tid, indices <span class="kw">in</span> access_indices_per_thread.items():</span>
<span id="cb55-24"><a href="#cb55-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ptr <span class="kw">in</span> indices:</span>
<span id="cb55-25"><a href="#cb55-25" aria-hidden="true" tabindex="-1"></a>            phys_ptr <span class="op">=</span> swizzle(ptr) <span class="cf">if</span> swizzle <span class="cf">else</span> ptr</span>
<span id="cb55-26"><a href="#cb55-26" aria-hidden="true" tabindex="-1"></a>            r, c <span class="op">=</span> cute.idx2crd(phys_ptr, bank_layout.shape, bank_layout.stride)</span>
<span id="cb55-27"><a href="#cb55-27" aria-hidden="true" tabindex="-1"></a>            table[r][c].add(tid)</span>
<span id="cb55-28"><a href="#cb55-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-29"><a href="#cb55-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 5) 打印整个 memory 的 bank 视图</span></span>
<span id="cb55-30"><a href="#cb55-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">[</span><span class="sc">{</span>title<span class="sc">}</span><span class="ss">] | "</span> <span class="op">+</span> (<span class="ss">f"Swizzle: </span><span class="sc">{</span>swizzle<span class="sc">}</span><span class="ss">"</span> <span class="cf">if</span> swizzle <span class="cf">else</span> <span class="st">"No Swizzle"</span>))</span>
<span id="cb55-31"><a href="#cb55-31" aria-hidden="true" tabindex="-1"></a>    header <span class="op">=</span> <span class="st">"      "</span> <span class="op">+</span> <span class="st">""</span>.join(<span class="ss">f"</span><span class="sc">{</span>b<span class="sc">:02d}</span><span class="ss"> "</span> <span class="cf">for</span> b <span class="kw">in</span> <span class="bu">range</span>(cols))</span>
<span id="cb55-32"><a href="#cb55-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(header)</span>
<span id="cb55-33"><a href="#cb55-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"      "</span> <span class="op">+</span> <span class="st">"-"</span> <span class="op">*</span> (cols <span class="op">*</span> <span class="dv">3</span>))</span>
<span id="cb55-34"><a href="#cb55-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-35"><a href="#cb55-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(rows):</span>
<span id="cb55-36"><a href="#cb55-36" aria-hidden="true" tabindex="-1"></a>        row_cells <span class="op">=</span> []</span>
<span id="cb55-37"><a href="#cb55-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(cols):</span>
<span id="cb55-38"><a href="#cb55-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> table[r][c]:</span>
<span id="cb55-39"><a href="#cb55-39" aria-hidden="true" tabindex="-1"></a>                row_cells.append(<span class="st">"/"</span>.join(<span class="ss">f"</span><span class="sc">{</span>t<span class="sc">:02d}</span><span class="ss">"</span> <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">sorted</span>(table[r][c])))</span>
<span id="cb55-40"><a href="#cb55-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb55-41"><a href="#cb55-41" aria-hidden="true" tabindex="-1"></a>                row_cells.append(<span class="st">"  "</span>)</span>
<span id="cb55-42"><a href="#cb55-42" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"R</span><span class="sc">{</span>r<span class="sc">:02d}</span><span class="ss"> | "</span> <span class="op">+</span> <span class="st">" "</span>.join(<span class="ss">f"</span><span class="sc">{</span>x<span class="sc">:&gt;2}</span><span class="ss">"</span> <span class="cf">for</span> x <span class="kw">in</span> row_cells))</span>
<span id="cb55-43"><a href="#cb55-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-44"><a href="#cb55-44" aria-hidden="true" tabindex="-1"></a>    bank_threads <span class="op">=</span> [<span class="bu">set</span>() <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(cols)]</span>
<span id="cb55-45"><a href="#cb55-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(rows):</span>
<span id="cb55-46"><a href="#cb55-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(cols):</span>
<span id="cb55-47"><a href="#cb55-47" aria-hidden="true" tabindex="-1"></a>            bank_threads[c].update(table[r][c])</span>
<span id="cb55-48"><a href="#cb55-48" aria-hidden="true" tabindex="-1"></a>    max_conflicts <span class="op">=</span> <span class="bu">max</span>(<span class="bu">len</span>(s) <span class="cf">for</span> s <span class="kw">in</span> bank_threads)</span>
<span id="cb55-49"><a href="#cb55-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"最大冲突深度: </span><span class="sc">{</span>max_conflicts<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>假设我们有一个32x64的f32矩阵，采用row-major布局。 32个线程，每个线程访问一列元素，此时这个32个线程刚好访问同一个bank的不同地址，产生严重的bank conflict：</p>
<div id="5b2186ea" class="cell" data-execution_count="59">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> my_access_pattern(layout, threads, v_size):</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>    access_map <span class="op">=</span> {}</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> tid <span class="kw">in</span> <span class="bu">range</span>(threads):</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>        access_map[tid] <span class="op">=</span> [layout(tid, v) <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(v_size)]</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> access_map</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>num_threads <span class="op">=</span> <span class="dv">32</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>vec_size <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>a_layout <span class="op">=</span> cute.Layout((<span class="dv">32</span>, <span class="dv">64</span>), (<span class="dv">64</span>, <span class="dv">1</span>))</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>thread_accesses <span class="op">=</span> my_access_pattern(a_layout, num_threads, vec_size)</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>visualize_bank_distribution(thread_accesses, swizzle<span class="op">=</span><span class="va">None</span>, title<span class="op">=</span><span class="st">"Row-Major Vector Read"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
[Row-Major Vector Read] | No Swizzle
      00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
      ------------------------------------------------------------------------------------------------
R00 | 00                                                                                             
R01 |                                                                                                
R02 | 01                                                                                             
R03 |                                                                                                
R04 | 02                                                                                             
R05 |                                                                                                
R06 | 03                                                                                             
R07 |                                                                                                
R08 | 04                                                                                             
R09 |                                                                                                
R10 | 05                                                                                             
R11 |                                                                                                
R12 | 06                                                                                             
R13 |                                                                                                
R14 | 07                                                                                             
R15 |                                                                                                
R16 | 08                                                                                             
R17 |                                                                                                
R18 | 09                                                                                             
R19 |                                                                                                
R20 | 10                                                                                             
R21 |                                                                                                
R22 | 11                                                                                             
R23 |                                                                                                
R24 | 12                                                                                             
R25 |                                                                                                
R26 | 13                                                                                             
R27 |                                                                                                
R28 | 14                                                                                             
R29 |                                                                                                
R30 | 15                                                                                             
R31 |                                                                                                
R32 | 16                                                                                             
R33 |                                                                                                
R34 | 17                                                                                             
R35 |                                                                                                
R36 | 18                                                                                             
R37 |                                                                                                
R38 | 19                                                                                             
R39 |                                                                                                
R40 | 20                                                                                             
R41 |                                                                                                
R42 | 21                                                                                             
R43 |                                                                                                
R44 | 22                                                                                             
R45 |                                                                                                
R46 | 23                                                                                             
R47 |                                                                                                
R48 | 24                                                                                             
R49 |                                                                                                
R50 | 25                                                                                             
R51 |                                                                                                
R52 | 26                                                                                             
R53 |                                                                                                
R54 | 27                                                                                             
R55 |                                                                                                
R56 | 28                                                                                             
R57 |                                                                                                
R58 | 29                                                                                             
R59 |                                                                                                
R60 | 30                                                                                             
R61 |                                                                                                
R62 | 31                                                                                             
最大冲突深度: 32</code></pre>
</div>
</div>
<p>根据之前对swizzle的理解，它的参数实际上在描述一个逻辑的访问矩阵，要将行和列进行交错实现conflict free。此时一个元素占一个bank，所以M=0 (2^0=1)。然后是访问32行时，每一行都交错开，B=5 (2^5=32)。 最后S=6 (2^6=64)，表示每行有64个元素。</p>
<div id="5f754d5b" class="cell" data-execution_count="60">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>visualize_bank_distribution(thread_accesses, swizzle<span class="op">=</span>cute.Swizzle(<span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">6</span>), title<span class="op">=</span><span class="st">"With Swizzle Optimization"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
[With Swizzle Optimization] | Swizzle: SW_5_0_6
      00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
      ------------------------------------------------------------------------------------------------
R00 | 00                                                                                             
R01 |                                                                                                
R02 |    01                                                                                          
R03 |                                                                                                
R04 |       02                                                                                       
R05 |                                                                                                
R06 |          03                                                                                    
R07 |                                                                                                
R08 |             04                                                                                 
R09 |                                                                                                
R10 |                05                                                                              
R11 |                                                                                                
R12 |                   06                                                                           
R13 |                                                                                                
R14 |                      07                                                                        
R15 |                                                                                                
R16 |                         08                                                                     
R17 |                                                                                                
R18 |                            09                                                                  
R19 |                                                                                                
R20 |                               10                                                               
R21 |                                                                                                
R22 |                                  11                                                            
R23 |                                                                                                
R24 |                                     12                                                         
R25 |                                                                                                
R26 |                                        13                                                      
R27 |                                                                                                
R28 |                                           14                                                   
R29 |                                                                                                
R30 |                                              15                                                
R31 |                                                                                                
R32 |                                                 16                                             
R33 |                                                                                                
R34 |                                                    17                                          
R35 |                                                                                                
R36 |                                                       18                                       
R37 |                                                                                                
R38 |                                                          19                                    
R39 |                                                                                                
R40 |                                                             20                                 
R41 |                                                                                                
R42 |                                                                21                              
R43 |                                                                                                
R44 |                                                                   22                           
R45 |                                                                                                
R46 |                                                                      23                        
R47 |                                                                                                
R48 |                                                                         24                     
R49 |                                                                                                
R50 |                                                                            25                  
R51 |                                                                                                
R52 |                                                                               26               
R53 |                                                                                                
R54 |                                                                                  27            
R55 |                                                                                                
R56 |                                                                                     28         
R57 |                                                                                                
R58 |                                                                                        29      
R59 |                                                                                                
R60 |                                                                                           30   
R61 |                                                                                                
R62 |                                                                                              31
最大冲突深度: 1</code></pre>
</div>
</div>
<p>上面的swizzle是直接异或，对于理解起来不怎么直观，所以我准备了一个更加符合直觉的图示。 实际上我们可以把swizzle还原到一个cute layout，他表示的是一个逻辑上的box，通过将原始tensor offset映射到这个box上，再通过box的coord得到逻辑行和列号（irow，icol），对icol进行异或得到xicol, 保证了<strong>不同行的相同列被映射到不同的列</strong>上。 再使用<code>(irow,xicol)</code>得到的index去访问shared memory bank， 同样通过idx2crd得到<code>(prow,pcol)</code>，即可发现所有的pcol的值都不相同， 实现了bank conflict free。</p>
<pre><code>┌─────────────────────┐          ┌──────────────────────┐          ┌──────────────────────┐
│   TENSOR LAYOUT     │          │   SWIZZLE LAYOUT     │          │  BANK LAYOUT         │
│   stride=64         │          │                      │          │  (32 banks)          │
│   32x64 row-major   │          │  shape: (1,64,32)    │          │                      │
│                     │          │  stride:(1,1,64)     │          │  Bank distribution   │
│ tid=0→addr 0        │---------&gt;│                      │---------&gt;│                      │
│ tid=1→addr 64       │  idx2crd │  (base,icol,irow)    │ idx2crd  │  tid=0→Bank 0        │
│ tid=2→addr 128      │          │  icol%width ^ irow   │          │  tid=1→Bank 1        │
│ tid=3→addr 192      │          │                      │          │  tid=2→Bank 2        │
│ tid=4→addr 256      │          │  (base,xicol,irow)   │          │  tid=3→Bank 3        │
│ tid=5→addr 320      │          │         │            │          │  tid=4→Bank 4        │
│ tid=6→addr 384      │          │         v            │          │  tid=5→Bank 5        │
│ tid=7→addr 448      │          │     phy_offset       │          │  tid=6→Bank 6        │
│                     │          └──────────────────────┘          │  tid=7→Bank 7        │
└─────────────────────┘                                            │                      │
                                                                   │ 已映射到不同 bank      │
                                                                   │ (冲突深度 = 1)        │
                                                                   │ 不存在 bank conflict  │
                                                                   └──────────────────────┘</code></pre>
<div id="bb3ac064" class="cell" data-execution_count="61">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> decompose_swizzle_mapping(access_indices_per_thread, swizzle: cute.Swizzle):</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  base <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> swizzle.base</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  width <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> swizzle.shift</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>  height <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> swizzle.bits</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>  swizzle_layout <span class="op">=</span> cute.Layout((base, width, height), (<span class="dv">1</span>, base, base <span class="op">*</span> width))</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>  max_offset <span class="op">=</span> <span class="bu">max</span>([offset <span class="cf">for</span> _, indices <span class="kw">in</span> access_indices_per_thread.items() <span class="cf">for</span> offset <span class="kw">in</span> indices])</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>  bank_layout <span class="op">=</span> cute.Layout((<span class="dv">32</span>, (max_offset <span class="op">+</span> <span class="dv">32</span>) <span class="op">//</span> <span class="dv">32</span>), (<span class="dv">1</span>, <span class="dv">32</span>))</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> tid, indices <span class="kw">in</span> access_indices_per_thread.items():</span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>      accesses <span class="op">=</span> []</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> offset <span class="kw">in</span> indices:</span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>        (_, icol, irow) <span class="op">=</span> cute.idx2crd(offset, swizzle_layout.shape)</span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a>        micol <span class="op">=</span> icol <span class="op">%</span> width <span class="co"># </span><span class="al">NOTE</span><span class="co"> abs(shift) &gt;= bits</span></span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>        xicol <span class="op">=</span> micol <span class="op">^</span> irow</span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>        phy_offset <span class="op">=</span> swizzle_layout(<span class="dv">0</span>, xicol, irow)</span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>        (pcol, prow) <span class="op">=</span> cute.idx2crd(phy_offset, bank_layout.shape)</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>        accesses.append(<span class="ss">f'(R</span><span class="sc">{</span>prow<span class="sc">:02d}</span><span class="ss">, </span><span class="sc">{</span>pcol<span class="sc">:02d}</span><span class="ss">)'</span>)</span>
<span id="cb61-21"><a href="#cb61-21" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(<span class="ss">f'T</span><span class="sc">{</span>tid<span class="sc">:02d}</span><span class="ss"> accesses: </span><span class="sc">{</span><span class="bu">str</span><span class="sc">.</span>join(<span class="st">", "</span>, accesses)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb61-22"><a href="#cb61-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-23"><a href="#cb61-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-24"><a href="#cb61-24" aria-hidden="true" tabindex="-1"></a>decompose_swizzle_mapping(thread_accesses, cute.Swizzle(<span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">6</span>))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>T00 accesses: (R00, 00)
T01 accesses: (R02, 01)
T02 accesses: (R04, 02)
T03 accesses: (R06, 03)
T04 accesses: (R08, 04)
T05 accesses: (R10, 05)
T06 accesses: (R12, 06)
T07 accesses: (R14, 07)
T08 accesses: (R16, 08)
T09 accesses: (R18, 09)
T10 accesses: (R20, 10)
T11 accesses: (R22, 11)
T12 accesses: (R24, 12)
T13 accesses: (R26, 13)
T14 accesses: (R28, 14)
T15 accesses: (R30, 15)
T16 accesses: (R32, 16)
T17 accesses: (R34, 17)
T18 accesses: (R36, 18)
T19 accesses: (R38, 19)
T20 accesses: (R40, 20)
T21 accesses: (R42, 21)
T22 accesses: (R44, 22)
T23 accesses: (R46, 23)
T24 accesses: (R48, 24)
T25 accesses: (R50, 25)
T26 accesses: (R52, 26)
T27 accesses: (R54, 27)
T28 accesses: (R56, 28)
T29 accesses: (R58, 29)
T30 accesses: (R60, 30)
T31 accesses: (R62, 31)</code></pre>
</div>
</div>
<p>下面再看一个例子，32x48的f32矩阵，依旧row major。 当进行load matrix，每一行load 4个元素(16Byte)，此时8个线程就能组成一个transaction，同样也会访问同一个bank的不同地址，产生严重的bank conflict：</p>
<div id="e0bcbfcb" class="cell" data-execution_count="62">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>num_threads <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>vec_size <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>a_layout <span class="op">=</span> cute.Layout((<span class="dv">32</span>, <span class="dv">64</span>), (<span class="dv">64</span>, <span class="dv">1</span>))</span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>thread_accesses <span class="op">=</span> my_access_pattern(a_layout, num_threads, vec_size)</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>visualize_bank_distribution(thread_accesses, swizzle<span class="op">=</span><span class="va">None</span>, title<span class="op">=</span><span class="st">"32x64 Row-Major vec4 (No Swizzle)"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
[32x64 Row-Major vec4 (No Swizzle)] | No Swizzle
      00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
      ------------------------------------------------------------------------------------------------
R00 | 00 00 00 00                                                                                    
R01 |                                                                                                
R02 | 01 01 01 01                                                                                    
R03 |                                                                                                
R04 | 02 02 02 02                                                                                    
R05 |                                                                                                
R06 | 03 03 03 03                                                                                    
R07 |                                                                                                
R08 | 04 04 04 04                                                                                    
R09 |                                                                                                
R10 | 05 05 05 05                                                                                    
R11 |                                                                                                
R12 | 06 06 06 06                                                                                    
R13 |                                                                                                
R14 | 07 07 07 07                                                                                    
最大冲突深度: 8</code></pre>
</div>
</div>
<p>现在开始计算Swizzle的参数。首先4个元素保持连续，因此M=2 (2^2=4)。需要让每一行的开头位于不同位置，刚好当前tensor stride为64，可以令此时4个元素组成的16个单元作为一行(宽64)，因此S=4 (2^4=16)。最后需要访问8行，因此B=3 (2^3=8)：</p>
<div id="803a4f40" class="cell" data-execution_count="63">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>visualize_bank_distribution(thread_accesses, swizzle<span class="op">=</span>cute.Swizzle(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>),</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>                           title<span class="op">=</span><span class="st">"32x64 Row-Major vec4"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
[32x64 Row-Major vec4] | Swizzle: SW_3_2_4
      00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
      ------------------------------------------------------------------------------------------------
R00 | 00 00 00 00                                                                                    
R01 |                                                                                                
R02 |             01 01 01 01                                                                        
R03 |                                                                                                
R04 |                         02 02 02 02                                                            
R05 |                                                                                                
R06 |                                     03 03 03 03                                                
R07 |                                                                                                
R08 |                                                 04 04 04 04                                    
R09 |                                                                                                
R10 |                                                             05 05 05 05                        
R11 |                                                                                                
R12 |                                                                         06 06 06 06            
R13 |                                                                                                
R14 |                                                                                     07 07 07 07
最大冲突深度: 1</code></pre>
</div>
</div>
<p>我们修改上一个例子的配置为32x48的f32矩阵，依旧row major。同样也会访问同一个bank的不同地址，产生4路冲突的bank conflict：</p>
<div id="de67c386" class="cell" data-execution_count="64">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>num_threads <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>vec_size <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>a_layout <span class="op">=</span> cute.Layout((<span class="dv">32</span>, <span class="dv">48</span>), (<span class="dv">48</span>, <span class="dv">1</span>))</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> my_access_pattern(layout, threads, v_size):</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    access_map <span class="op">=</span> {}</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> tid <span class="kw">in</span> <span class="bu">range</span>(threads):</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>        access_map[tid] <span class="op">=</span> [layout(tid, v) <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(v_size)]</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> access_map</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>thread_accesses <span class="op">=</span> my_access_pattern(a_layout, num_threads, vec_size)</span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>visualize_bank_distribution(thread_accesses, swizzle<span class="op">=</span><span class="va">None</span>, title<span class="op">=</span><span class="st">"32x48 Row-Major vec4"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
[32x48 Row-Major vec4] | No Swizzle
      00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
      ------------------------------------------------------------------------------------------------
R00 | 00 00 00 00                                                                                    
R01 |                                                 01 01 01 01                                    
R02 |                                                                                                
R03 | 02 02 02 02                                                                                    
R04 |                                                 03 03 03 03                                    
R05 |                                                                                                
R06 | 04 04 04 04                                                                                    
R07 |                                                 05 05 05 05                                    
R08 |                                                                                                
R09 | 06 06 06 06                                                                                    
R10 |                                                 07 07 07 07                                    
最大冲突深度: 4</code></pre>
</div>
</div>
<p>依旧4个元素保持连续，因此M=2 (2^2=4)。但是此时访问的stride为48，并且4个元素为一个单元，再叠加cute Swizzle 2的幂次限制，我们只能选择<code>4*8=32</code>或者<code>4*16=64</code>作为行宽度。 由于32/64都并不是48的倍数，所以不能通过匹配S的大小刚好令每一行的开头按顺序错开。 这里其实会存在余数，也就是余数所造成icol的周期循环<code>icol: [(i * 48 % 64) // 4 for i in range(8)] = [0, 12, 8, 4, 0, 12, 8, 4]</code>，但是最终的<code>xicol</code>实际上还需要取决于<code>irow</code>的，因此我目前也没有理清楚对于swizzle的影响公式，需要后续进一步研究：</p>
<div id="7e577f50" class="cell" data-execution_count="65">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>visualize_bank_distribution(thread_accesses, swizzle<span class="op">=</span>cute.Swizzle(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>), title<span class="op">=</span><span class="st">"32x48 Row-Major vec4"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
[32x48 Row-Major vec4] | Swizzle: SW_3_2_4
      00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
      ------------------------------------------------------------------------------------------------
R00 | 00 00 00 00                                                                                    
R01 |                                                 01 01 01 01                                    
R02 |                                                                                                
R03 |             02 02 02 02                                                                        
R04 |                                                                         03 03 03 03            
R05 |                                                                                                
R06 |                                     04 04 04 04                                                
R07 |                                                                                     05 05 05 05
R08 |                                                                                                
R09 |                                                 06 06 06 06                                    
R10 |             07 07 07 07                                                                        
最大冲突深度: 2</code></pre>
</div>
</div>
<p>所以我们选择更小的行宽度，32为一行。同样也有周期循环 <code>icol: [(i * 48 % 32) // 4 for i in range(8)] = [0, 4, 0, 4, 0, 4, 0, 4]</code>， 但是这样最终的xicol反而并不会有重叠：</p>
<div id="83050be0" class="cell" data-execution_count="66">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>visualize_bank_distribution(thread_accesses, swizzle<span class="op">=</span>cute.Swizzle(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>), title<span class="op">=</span><span class="st">"32x48 Row-Major vec4"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
[32x48 Row-Major vec4] | Swizzle: SW_2_2_3
      00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
      ------------------------------------------------------------------------------------------------
R00 | 00 00 00 00                                                                                    
R01 |                                                             01 01 01 01                        
R02 |                                                                                                
R03 |                                     02 02 02 02                                                
R04 |                                                 03 03 03 03                                    
R05 |                                                                                                
R06 |                         04 04 04 04                                                            
R07 |                                                                                     05 05 05 05
R08 |                                                                                                
R09 |             06 06 06 06                                                                        
R10 |                                                                         07 07 07 07            
最大冲突深度: 1</code></pre>
</div>
</div>
<p>下面这个例子下所能达到conflict free的swizzle参数是一个相当反直觉的值，留给后续研究。</p>
<div id="9c798903" class="cell" data-execution_count="67">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>num_threads <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>vec_size <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>a_layout <span class="op">=</span> cute.Layout((<span class="dv">32</span>, <span class="dv">40</span>), (<span class="dv">40</span>, <span class="dv">1</span>))</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>thread_accesses <span class="op">=</span> my_access_pattern(a_layout, num_threads, vec_size)</span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>visualize_bank_distribution(thread_accesses, swizzle<span class="op">=</span>cute.Swizzle(<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>), title<span class="op">=</span><span class="st">"Swizzle"</span>)</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
[Swizzle] | Swizzle: SW_2_1_3
      00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
      ------------------------------------------------------------------------------------------------
R00 | 00 00 00 00                                                                                    
R01 |                                     01 01 01 01                                                
R02 |                                                 02 02 02 02                                    
R03 |                                                                                     03 03 03 03
R04 |                                                                                                
R05 |             04 04 04 04                                                                        
R06 |                         05 05 05 05                                                            
R07 |                                                             06 06 06 06                        
R08 |                                                                         07 07 07 07            
最大冲突深度: 1</code></pre>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/zhen8838\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<script src="https://utteranc.es/client.js" repo="zhen8838/zhen8838.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>