<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>机器学习作业第六周 | Zheng's Notes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">机器学习作业第六周</h1><a id="logo" href="/.">Zheng's Notes</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">机器学习作业第六周</h1><div class="post-meta">2018-12-13<span> | </span><span class="category"><a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.8k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 23</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">难点总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ex6.py"><span class="toc-number">2.</span> <span class="toc-text">ex6.py</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%88%E6%9E%9C"><span class="toc-number">2.1.</span> <span class="toc-text">效果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ex6_spam.py"><span class="toc-number">3.</span> <span class="toc-text">ex6_spam.py</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%88%E6%9E%9C-1"><span class="toc-number">3.1.</span> <span class="toc-text">效果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fucs6.py"><span class="toc-number">4.</span> <span class="toc-text">fucs6.py</span></a></li></ol></div></div><div class="post-content"><p>这周是<code>SVM</code>,其实<code>SVM</code>部分是没有什么难点,主要问题是在于自定义核函数在<code>sklean</code>中比较蛋疼.</p>
<span id="more"></span>
<h1 id="难点总结">难点总结</h1>
<p>在<code>sklean</code>中自定义的核函数必须要可以计算两个相同维数的矩阵,并返回一个新的方阵.</p>
<p>比如我自定义的高斯核函数,如果接受两个<code>[800,2]</code>的矩阵,那么需要返回一个<code>[800,800]</code>的矩阵,代码才可以正常运行.</p>
<h1 id="ex6.py">ex6.py</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.core <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> fucs6 <span class="keyword">import</span> plotData, visualizeBoundaryLinear, gaussianKernel, \</span><br><span class="line">    visualizeBoundary, dataset3Params</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># Machine Learning Online Class</span></span><br><span class="line">    <span class="comment">#  Exercise 6 | Support Vector Machines</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#  Instructions</span></span><br><span class="line">    <span class="comment">#  ------------</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#  This file contains code that helps you get started on the</span></span><br><span class="line">    <span class="comment">#  exercise. You will need to complete the following functions:</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#     gaussianKernel.m</span></span><br><span class="line">    <span class="comment">#     dataset3Params.m</span></span><br><span class="line">    <span class="comment">#     processEmail.m</span></span><br><span class="line">    <span class="comment">#     emailFeatures.m</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#  For this exercise, you will not need to change any code in this file,</span></span><br><span class="line">    <span class="comment">#  or any other files other than those mentioned above.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># =============== Part 1: Loading and Visualizing Data ================</span></span><br><span class="line">    <span class="comment">#  We start the exercise by first loading and visualizing the dataset.</span></span><br><span class="line">    <span class="comment">#  The following code will load the dataset into your environment and plot</span></span><br><span class="line">    <span class="comment">#  the data.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Loading and Visualizing Data ...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load from ex6data1:</span></span><br><span class="line">    <span class="comment"># You will have X, y in your environment</span></span><br><span class="line">    data = loadmat(<span class="string">&#x27;ex6data1.mat&#x27;</span>)</span><br><span class="line">    X = data[<span class="string">&#x27;X&#x27;</span>]  <span class="comment"># [51,2]</span></span><br><span class="line">    y = data[<span class="string">&#x27;y&#x27;</span>]  <span class="comment"># [51,1]</span></span><br><span class="line">    <span class="comment"># Plot training data</span></span><br><span class="line">    plotData(X, y)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Program paused. Press enter to continue.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==================== Part 2: Training Linear SVM ====================</span></span><br><span class="line">    <span class="comment">#  The following code will train a linear SVM on the dataset and plot the</span></span><br><span class="line">    <span class="comment">#  decision boundary learned.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load from ex6data1:</span></span><br><span class="line">    <span class="comment"># You will have X, y in your environment</span></span><br><span class="line">    <span class="comment"># load(&#x27;&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Training Linear SVM ...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># You should try to change the C value below and see how the decision</span></span><br><span class="line">    <span class="comment"># boundary varies (e.g., try C = 1000)</span></span><br><span class="line">    C = <span class="number">1</span></span><br><span class="line">    model = svm.SVC(C, kernel=<span class="string">&#x27;linear&#x27;</span>, tol=<span class="number">1e-3</span>, max_iter=<span class="number">20</span>)</span><br><span class="line">    model.fit(X, y.ravel())</span><br><span class="line"></span><br><span class="line">    visualizeBoundaryLinear(X, y, model)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Program paused. Press enter to continue.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># =============== Part 3: Implementing Gaussian Kernel ===============</span></span><br><span class="line">    <span class="comment">#  You will now implement the Gaussian kernel to use</span></span><br><span class="line">    <span class="comment">#  with the SVM. You should complete the code in gaussianKernel.m</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Evaluating the Gaussian Kernel ...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    x1 = array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">    x2 = array([<span class="number">0</span>, <span class="number">4</span>, -<span class="number">1</span>]).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">    sigma = <span class="number">2</span></span><br><span class="line">    sim = gaussianKernel(x1, x2, sigma)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Gaussian Kernel between x1 = [1; 2; 1], x2 = [0; 4; -1], sigma = &#123;&#125; :\</span></span><br><span class="line"><span class="string">    \n\t&#123;&#125;\n(for sigma = 2, this value should be about 0.324652)&#x27;</span>.<span class="built_in">format</span>(sigma,</span><br><span class="line">                                                                         sim))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Program paused. Press enter to continue.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># =============== Part 4: Visualizing Dataset 2 ================</span></span><br><span class="line">    <span class="comment">#  The following code will load the next dataset into your environment and</span></span><br><span class="line">    <span class="comment">#  plot the data.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Loading and Visualizing Data ...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load from ex6data2:</span></span><br><span class="line">    <span class="comment"># You will have X, y in your environment</span></span><br><span class="line">    data = loadmat(<span class="string">&#x27;ex6data2.mat&#x27;</span>)</span><br><span class="line">    X = data[<span class="string">&#x27;X&#x27;</span>]  <span class="comment"># tpye:ndarray</span></span><br><span class="line">    y = data[<span class="string">&#x27;y&#x27;</span>]  <span class="comment"># tpye:ndarray</span></span><br><span class="line">    <span class="comment"># Plot training data</span></span><br><span class="line">    plotData(X, y)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Program paused. Press enter to continue.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ========== Part 5: Training SVM with RBF Kernel (Dataset 2) ==========</span></span><br><span class="line">    <span class="comment">#  After you have implemented the kernel, we can now use it to train the</span></span><br><span class="line">    <span class="comment">#  SVM classifier.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Training SVM with RBF Kernel (this may take 1 to 2 minutes) ...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load from ex6data2:</span></span><br><span class="line">    <span class="comment"># You will have X, y in your environment</span></span><br><span class="line">    <span class="comment"># load(&#x27;ex6data2.mat&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># SVM Parameters</span></span><br><span class="line">    C = <span class="number">1</span></span><br><span class="line">    sigma = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># We set the tolerance and max_passes lower here so that the code will run</span></span><br><span class="line">    <span class="comment"># faster. However, in practice, you will want to run the training to</span></span><br><span class="line">    <span class="comment"># convergence.</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mykernel</span>(<span class="params">x1, x2</span>): <span class="keyword">return</span> gaussianKernel(x1, x2, sigma)</span><br><span class="line">    model = svm.SVC(C, kernel=mykernel)  <span class="comment"># type:SVC</span></span><br><span class="line">    model.fit(X, y.ravel())</span><br><span class="line">    visualizeBoundary(X, y, model)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Program paused. Press enter to continue.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># =============== Part 6: Visualizing Dataset 3 ================</span></span><br><span class="line">    <span class="comment">#  The following code will load the next dataset into your environment and</span></span><br><span class="line">    <span class="comment">#  plot the data.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Loading and Visualizing Data ...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load from ex6data3:</span></span><br><span class="line">    <span class="comment"># You will have X, y in your environment</span></span><br><span class="line">    data = loadmat(<span class="string">&#x27;ex6data3.mat&#x27;</span>)</span><br><span class="line">    X = data[<span class="string">&#x27;X&#x27;</span>]  <span class="comment"># tpye:ndarray</span></span><br><span class="line">    y = data[<span class="string">&#x27;y&#x27;</span>]  <span class="comment"># tpye:ndarray</span></span><br><span class="line">    Xval = data[<span class="string">&#x27;Xval&#x27;</span>]  <span class="comment"># tpye:ndarray</span></span><br><span class="line">    yval = data[<span class="string">&#x27;yval&#x27;</span>]  <span class="comment"># tpye:ndarray</span></span><br><span class="line">    <span class="comment"># Plot training data</span></span><br><span class="line">    plotData(X, y)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Program paused. Press enter to continue.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ========== Part 7: Training SVM with RBF Kernel (Dataset 3) ==========</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#  This is a different dataset that you can use to experiment with. Try</span></span><br><span class="line">    <span class="comment">#  different values of C and sigma here.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load from ex6data3:</span></span><br><span class="line">    <span class="comment"># You will have X, y in your environment</span></span><br><span class="line">    <span class="comment"># load(&#x27;ex6data3.mat&#x27;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Try different SVM Parameters here</span></span><br><span class="line">    C, sigma = dataset3Params(X, y, Xval, yval)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Train the SVM</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mykernel</span>(<span class="params">x1, x2</span>): <span class="keyword">return</span> gaussianKernel(x1, x2, sigma)</span><br><span class="line">    model = svm.SVC(C, kernel=mykernel)  <span class="comment"># type:SVC</span></span><br><span class="line">    model.fit(X, y.ravel())</span><br><span class="line">    visualizeBoundary(X, y, model)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Program paused. Press enter to continue.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="效果">效果</h2>
<p><img src="/2018/12/13/wenda-week6/1.png" alt="可视化数据" /> <img
src="/2018/12/13/wenda-week6/2.png" alt="linear核函数决策线" /> <img
src="/2018/12/13/wenda-week6/3.png" alt="可视化数据" /> <img
src="/2018/12/13/wenda-week6/4.png" alt="高斯核函数决策线" /> <img
src="/2018/12/13/wenda-week6/5.png" alt="可视化数据" /> <img
src="/2018/12/13/wenda-week6/6.png" alt="高斯核函数决策线" /></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  week6 python3 ex6.py</span><br><span class="line">Loading and Visualizing Data ...</span><br><span class="line">Program paused. Press enter to <span class="built_in">continue</span>.</span><br><span class="line">Training Linear SVM ...</span><br><span class="line">/home/zqh/.local/lib/python3.6/site-packages/sklearn/svm/base.py:244: ConvergenceWarning: Solver terminated early (max_iter=20).  Consider pre-processing your data with StandardScaler or MinMaxScaler.</span><br><span class="line">  % self.max_iter, ConvergenceWarning)</span><br><span class="line">Program paused. Press enter to <span class="built_in">continue</span>.</span><br><span class="line">Evaluating the Gaussian Kernel ...</span><br><span class="line">Gaussian Kernel between x1 = [1; 2; 1], x2 = [0; 4; -1], sigma = 2 :</span><br><span class="line">        [[0.32465247]]</span><br><span class="line">(<span class="keyword">for</span> sigma = 2, this value should be about 0.324652)</span><br><span class="line">Program paused. Press enter to <span class="built_in">continue</span>.</span><br><span class="line">Loading and Visualizing Data ...</span><br><span class="line">Program paused. Press enter to <span class="built_in">continue</span>.</span><br><span class="line">Training SVM with RBF Kernel (this may take 1 to 2 minutes) ...</span><br><span class="line">Program paused. Press enter to <span class="built_in">continue</span>.</span><br><span class="line">Loading and Visualizing Data ...</span><br><span class="line">Program paused. Press enter to <span class="built_in">continue</span>.</span><br><span class="line">Program paused. Press enter to <span class="built_in">continue</span>.</span><br></pre></td></tr></table></figure>
<h1 id="ex6_spam.py">ex6_spam.py</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.core <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> fucs6 <span class="keyword">import</span> gaussianKernel, dataset3Params, processEmail,\</span><br><span class="line">    readFile, emailFeatures, getVocabList</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># Machine Learning Online Class</span></span><br><span class="line">    <span class="comment">#  Exercise 6 | Spam Classification with SVMs</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#  Instructions</span></span><br><span class="line">    <span class="comment">#  ------------</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#  This file contains code that helps you get started on the</span></span><br><span class="line">    <span class="comment">#  exercise. You will need to complete the following functions:</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#     gaussianKernel.m</span></span><br><span class="line">    <span class="comment">#     dataset3Params.m</span></span><br><span class="line">    <span class="comment">#     processEmail.m</span></span><br><span class="line">    <span class="comment">#     emailFeatures.m</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#  For this exercise, you will not need to change any code in this file,</span></span><br><span class="line">    <span class="comment">#  or any other files other than those mentioned above.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==================== Part 1: Email Preprocessing ====================</span></span><br><span class="line">    <span class="comment">#  To use an SVM to classify emails into Spam v.s. Non-Spam, you first need</span></span><br><span class="line">    <span class="comment">#  to convert each email into a vector of features. In this part, you will</span></span><br><span class="line">    <span class="comment">#  implement the preprocessing steps for each email. You should</span></span><br><span class="line">    <span class="comment">#  complete the code in processEmail.m to produce a word indices vector</span></span><br><span class="line">    <span class="comment">#  for a given email.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Preprocessing sample email (emailSample1.txt)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Extract Features</span></span><br><span class="line">    file_contents = readFile(<span class="string">&#x27;emailSample1.txt&#x27;</span>)</span><br><span class="line">    word_indices = processEmail(file_contents)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print Stats</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Word Indices: &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(word_indices)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nProgram paused. Press enter to continue.&#x27;</span>)</span><br><span class="line">    <span class="comment"># pause</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ==================== Part 2: Feature Extraction ====================</span></span><br><span class="line">    <span class="comment">#  Now, you will convert each email into a vector of features in R^n.</span></span><br><span class="line">    <span class="comment">#  You should complete the code in emailFeatures.m to produce a feature</span></span><br><span class="line">    <span class="comment">#  vector for a given email.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Extracting features from sample email (emailSample1.txt)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Extract Features</span></span><br><span class="line">    file_contents = readFile(<span class="string">&#x27;emailSample1.txt&#x27;</span>)</span><br><span class="line">    word_indices = processEmail(file_contents)</span><br><span class="line">    features = emailFeatures(word_indices)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print Stats</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Length of feature vector: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(size(features, <span class="number">0</span>)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Number of non-zero entries: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">sum</span>(features &gt; <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Program paused. Press enter to continue.&#x27;</span>)</span><br><span class="line">    <span class="comment"># pause</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># =========== Part 3: Train Linear SVM for Spam Classification ========</span></span><br><span class="line">    <span class="comment">#  In this section, you will train a linear classifier to determine if an</span></span><br><span class="line">    <span class="comment">#  email is Spam or Not-Spam.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load the Spam Email dataset</span></span><br><span class="line">    <span class="comment"># You will have X, y in your environment</span></span><br><span class="line">    data = loadmat(<span class="string">&#x27;spamTrain.mat&#x27;</span>)</span><br><span class="line">    X = data[<span class="string">&#x27;X&#x27;</span>]</span><br><span class="line">    y = data[<span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Training Linear SVM (Spam Classification)&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;(this may take 1 to 2 minutes) ...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    C = <span class="number">0.1</span></span><br><span class="line">    model = svm.SVC(C=C, kernel=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">    model.fit(X, y.ravel())</span><br><span class="line"></span><br><span class="line">    p = model.predict(X)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Training Accuracy: &#123;&#125;%&#x27;</span>.<span class="built_in">format</span>(mean(array(p == y)) * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># =================== Part 4: Test Spam Classification ================</span></span><br><span class="line">    <span class="comment">#  After training the classifier, we can evaluate it on a test set. We have</span></span><br><span class="line">    <span class="comment">#  included a test set in spamTest.mat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load the test dataset</span></span><br><span class="line">    <span class="comment"># You will have Xtest, ytest in your environment</span></span><br><span class="line">    data = loadmat(<span class="string">&#x27;spamTest.mat&#x27;</span>)</span><br><span class="line">    Xtest = data[<span class="string">&#x27;Xtest&#x27;</span>]</span><br><span class="line">    ytest = data[<span class="string">&#x27;ytest&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Evaluating the trained Linear SVM on a test set ...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p = model.predict(Xtest)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Test Accuracy: &#123;&#125;%&#x27;</span>.<span class="built_in">format</span>(mean(array(p == ytest)) * <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ================= Part 5: Top Predictors of Spam ====================</span></span><br><span class="line">    <span class="comment">#  Since the model we are training is a linear SVM, we can inspect the</span></span><br><span class="line">    <span class="comment">#  weights learned by the model to understand better how it is determining</span></span><br><span class="line">    <span class="comment">#  whether an email is spam or not. The following code finds the words with</span></span><br><span class="line">    <span class="comment">#  the highest weights in the classifier. Informally, the classifier</span></span><br><span class="line">    <span class="comment">#  &#x27;thinks&#x27; that these words are the most likely indicators of spam.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Sort the weights and obtin the vocabulary list</span></span><br><span class="line">    temp = model.coef_.copy().ravel()</span><br><span class="line">    weight = argsort(temp.ravel())[::-<span class="number">1</span>]</span><br><span class="line">    vocabList = getVocabList()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Top predictors of spam: &#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27; &#123;:^15&#125;\t&#123;&#125; &#x27;</span>.<span class="built_in">format</span>(vocabList[weight[i]], weight[i]))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\nProgram paused. Press enter to continue.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># =================== Part 6: Try Your Own Emails =====================</span></span><br><span class="line">    <span class="comment">#  Now that you&#x27;ve trained the spam classifier, you can use it on your own</span></span><br><span class="line">    <span class="comment">#  emails! In the starter code, we have included spamSample1.txt,</span></span><br><span class="line">    <span class="comment">#  spamSample2.txt, emailSample1.txt and emailSample2.txt as examples.</span></span><br><span class="line">    <span class="comment">#  The following code reads in one of these emails and then uses your</span></span><br><span class="line">    <span class="comment">#  learned SVM classifier to determine whether the email is Spam or</span></span><br><span class="line">    <span class="comment">#  Not Spam</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the file to be read in (change this to spamSample2.txt,</span></span><br><span class="line">    <span class="comment"># emailSample1.txt or emailSample2.txt to see different predictions on</span></span><br><span class="line">    <span class="comment"># different emails types). Try your own emails as well!</span></span><br><span class="line">    filename = <span class="string">&#x27;spamSample1.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read and predict</span></span><br><span class="line">    file_contents = readFile(filename)</span><br><span class="line">    word_indices = processEmail(file_contents)</span><br><span class="line">    x = emailFeatures(word_indices).reshape(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">    p = model.predict(x)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Processed &#123;&#125;\n\nSpam Classification: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(filename, p))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;(1 indicates spam, 0 indicates not spam)\n&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="效果-1">效果</h2>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">➜  week6 python3 ex6_spam.py</span><br><span class="line">Preprocessing sample email (emailSample1.txt)</span><br><span class="line"></span><br><span class="line">==== Processed Email ====</span><br><span class="line">anyon know how much it cost to host a web portal it depend on how mani visitor you re expect can be anywher from less than number buck a month to a coupl of dollarnumb should checkout httpaddr or perhap amazon ecnumb your run someth big unsubscrib yourself from thi mail list send an email to</span><br><span class="line"></span><br><span class="line">=======================</span><br><span class="line">Word Indices:</span><br><span class="line">[86, 916, 794, 1077, 883, 370, 1699, 790, 1822, 883, 431, 1171, 794, 1002, 1893, 1364, 592, 238, 162, 89, 688, 945, 1663, 1120, 1062, 1699, 375, 1162, 479, 1510, 799, 1182, 1237, 1895, 1440, 1547, 181, 1758, 1896, 688, 1676, 992, 961, 1477, 71, 530, 1699]</span><br><span class="line"></span><br><span class="line">Program paused. Press enter to <span class="built_in">continue</span>.</span><br><span class="line">Extracting features from sample email (emailSample1.txt)</span><br><span class="line"></span><br><span class="line">==== Processed Email ====</span><br><span class="line">anyon know how much it cost to host a web portal it depend on how mani visitor you re expect can be anywher from less than number buck a month to a coupl of dollarnumb should checkout httpaddr or perhap amazon ecnumb your run someth big unsubscrib yourself from thi mail list send an email to</span><br><span class="line"></span><br><span class="line">=======================</span><br><span class="line">Length of feature vector: 1899</span><br><span class="line">Number of non-zero entries: 42</span><br><span class="line">Program paused. Press enter to <span class="built_in">continue</span>.</span><br><span class="line">Training Linear SVM (Spam Classification)</span><br><span class="line">(this may take 1 to 2 minutes) ...</span><br><span class="line">Training Accuracy: 56.56122500000001%</span><br><span class="line">Evaluating the trained Linear SVM on a <span class="built_in">test</span> <span class="built_in">set</span> ...</span><br><span class="line">Test Accuracy: 57.1808%</span><br><span class="line">Top predictors of spam:</span><br><span class="line">       our              1190</span><br><span class="line">      click             297</span><br><span class="line">      remov             1397</span><br><span class="line">    guarante            738</span><br><span class="line">      visit             1795</span><br><span class="line">    basenumb            155</span><br><span class="line">     dollar             476</span><br><span class="line">      will              1851</span><br><span class="line">      price             1298</span><br><span class="line">      pleas             1263</span><br><span class="line">      most              1066</span><br><span class="line">      nbsp              1088</span><br><span class="line">       lo               965</span><br><span class="line">       ga               698</span><br><span class="line">      hour              791</span><br><span class="line"></span><br><span class="line">Program paused. Press enter to <span class="built_in">continue</span>.</span><br><span class="line"></span><br><span class="line">==== Processed Email ====</span><br><span class="line"><span class="keyword">do</span> you want to make dollarnumb or more per week you are a motiv and qualifi individu i person demonstr to you a system that will you dollarnumb number per week or more thi is not mlm our number hour pre record number to get the number need peopl <span class="built_in">who</span> want to make seriou money make call and get the fact number minut <span class="keyword">in</span> yourself now number forward to your call and i will introduc youpeopl like yourself current make dollarnumb number plu per week number numberleannumberlrmsnumbnumberwxhonumberqiytnumb numberrjuvnumberhqcfnumb</span><br><span class="line"></span><br><span class="line">=======================</span><br><span class="line">Processed spamSample1.txt</span><br><span class="line"></span><br><span class="line">Spam Classification: [1]</span><br><span class="line">(1 indicates spam, 0 indicates not spam)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="fucs6.py">fucs6.py</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy.core <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> numpy.matrixlib <span class="keyword">import</span> mat</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> c_, r_, meshgrid, square, where, <span class="built_in">min</span>, <span class="built_in">max</span></span><br><span class="line"><span class="keyword">from</span> scipy.special <span class="keyword">import</span> expit</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> fmin_cg</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> re <span class="keyword">import</span> sub, split</span><br><span class="line"><span class="keyword">from</span> nltk.stem <span class="keyword">import</span> PorterStemmer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plotData</span>(<span class="params">X: ndarray, y: ndarray</span>):</span><br><span class="line">    <span class="comment"># PLOTDATA Plots the data points X and y into a new figure</span></span><br><span class="line">    <span class="comment">#   PLOTDATA(x,y) plots the data points with + for the positive examples</span></span><br><span class="line">    <span class="comment">#   and o for the negative examples. X is assumed to be a Mx2 matrix.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Note: This was slightly modified such that it expects y = 1 or y = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find Indices of Positive and Negative Examples</span></span><br><span class="line">    pos = nonzero(y == <span class="number">1</span>)</span><br><span class="line">    neg = nonzero(y == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Plot Examples</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(X[pos[<span class="number">0</span>], <span class="number">0</span>], X[pos[<span class="number">0</span>], <span class="number">1</span>], <span class="string">&#x27;k+&#x27;</span>)</span><br><span class="line">    plt.plot(X[neg[<span class="number">0</span>], <span class="number">0</span>], X[neg[<span class="number">0</span>], <span class="number">1</span>], <span class="string">&#x27;yo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualizeBoundaryLinear</span>(<span class="params">X, y, model</span>):</span><br><span class="line">    <span class="comment"># VISUALIZEBOUNDARYLINEAR plots a linear decision boundary learned by the</span></span><br><span class="line">    <span class="comment"># SVM</span></span><br><span class="line">    <span class="comment">#   VISUALIZEBOUNDARYLINEAR(X, y, model) plots a linear decision boundary</span></span><br><span class="line">    <span class="comment">#   learned by the SVM and overlays the data on it</span></span><br><span class="line"></span><br><span class="line">    xp = linspace(<span class="built_in">min</span>(X[:, <span class="number">0</span>]), <span class="built_in">max</span>(X[:, <span class="number">0</span>]), <span class="number">100</span>)</span><br><span class="line">    yp = linspace(<span class="built_in">min</span>(X[:, <span class="number">1</span>]), <span class="built_in">max</span>(X[:, <span class="number">1</span>]), <span class="number">100</span>)</span><br><span class="line">    plotData(X, y)</span><br><span class="line">    YY, XX = meshgrid(yp, xp)</span><br><span class="line">    xy = vstack([XX.ravel(), YY.ravel()]).T</span><br><span class="line">    Z = model.decision_function(xy).reshape(XX.shape)</span><br><span class="line">    plt.contour(XX, YY, Z, colors=<span class="string">&#x27;b&#x27;</span>, levels=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualizeBoundary</span>(<span class="params">X: ndarray, y: ndarray, model: svm.SVC, varargin=<span class="number">0</span></span>):</span><br><span class="line">    <span class="comment"># VISUALIZEBOUNDARY plots a non-linear decision boundary learned by the SVM</span></span><br><span class="line">    <span class="comment">#   VISUALIZEBOUNDARYLINEAR(X, y, model) plots a non-linear decision</span></span><br><span class="line">    <span class="comment">#   boundary learned by the SVM and overlays the data on it</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Plot the training data on top of the boundary</span></span><br><span class="line">    plotData(X, y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make classification predictions over a grid of values</span></span><br><span class="line">    x1plot = linspace(<span class="built_in">min</span>(X[:, <span class="number">0</span>]), <span class="built_in">max</span>(X[:, <span class="number">0</span>]), <span class="number">100</span>)</span><br><span class="line">    x2plot = linspace(<span class="built_in">min</span>(X[:, <span class="number">1</span>]), <span class="built_in">max</span>(X[:, <span class="number">1</span>]), <span class="number">100</span>)</span><br><span class="line">    xx, yy = meshgrid(x1plot, x2plot)  <span class="comment"># type:ndarray</span></span><br><span class="line"></span><br><span class="line">    Z = model.predict(c_[xx.ravel(), yy.ravel()])  <span class="comment"># type:ndarray</span></span><br><span class="line">    Z.resize(xx.shape)</span><br><span class="line">    <span class="comment"># Plot the SVM boundary</span></span><br><span class="line">    plt.contour(xx, yy, Z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gaussianKernel</span>(<span class="params">x1: ndarray, x2: ndarray, sigma</span>):</span><br><span class="line">    <span class="comment"># RBFKERNEL returns a radial basis function kernel between x1 and x2</span></span><br><span class="line">    <span class="comment"># sim = gaussianKernel(x1, x2) returns a gaussian kernel between x1 and x2</span></span><br><span class="line">    <span class="comment"># and returns the value in sim</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ensure that x1 and x2 are column vectors</span></span><br><span class="line">    m = size(x1, <span class="number">0</span>)</span><br><span class="line">    n = size(x2, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># You need to return the following variables correctly.</span></span><br><span class="line">    sim = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ====================== YOUR CODE HERE ======================</span></span><br><span class="line">    <span class="comment"># Instructions: Fill in this function to return the similarity between x1</span></span><br><span class="line">    <span class="comment">#               and x2 computed using a Gaussian kernel with bandwidth</span></span><br><span class="line">    <span class="comment">#               sigma</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># Note: use the matrix compute the distence</span></span><br><span class="line">    M = x1@x2.T</span><br><span class="line">    H1 = <span class="built_in">sum</span>(square(mat(x1)), <span class="number">1</span>)  <span class="comment"># [m,1]</span></span><br><span class="line">    H2 = <span class="built_in">sum</span>(square(mat(x2)), <span class="number">1</span>)  <span class="comment"># [n,1]</span></span><br><span class="line">    D = H1+H2.T-<span class="number">2</span>*M</span><br><span class="line"></span><br><span class="line">    sim = exp(-D/(<span class="number">2</span>*sigma*sigma))</span><br><span class="line">    <span class="comment"># =============================================================</span></span><br><span class="line">    <span class="keyword">return</span> sim</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dataset3Params</span>(<span class="params">X: ndarray, y: ndarray, Xval: ndarray, yval: ndarray</span>):</span><br><span class="line">    <span class="comment"># DATASET3PARAMS returns your choice of C and sigma for Part 3 of the</span></span><br><span class="line">    <span class="comment"># exercise where you select the optimal (C, sigma) learning parameters to</span></span><br><span class="line">    <span class="comment"># use for SVM with RBF kernel</span></span><br><span class="line">    <span class="comment"># [C, sigma] = DATASET3PARAMS(X, y, Xval, yval) returns your choice of C</span></span><br><span class="line">    <span class="comment"># and sigma. You should complete this function to return the optimal C and</span></span><br><span class="line">    <span class="comment"># sigma based on a cross-validation set.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># You need to return the following variables correctly.</span></span><br><span class="line">    C = <span class="number">1</span></span><br><span class="line">    sigma = <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ====================== YOUR CODE HERE ======================</span></span><br><span class="line">    <span class="comment"># Instructions: Fill in this function to return the optimal C and sigma</span></span><br><span class="line">    <span class="comment">#               learning parameters found using the cross validation set.</span></span><br><span class="line">    <span class="comment">#               You can use svmPredict to predict the labels on the cross</span></span><br><span class="line">    <span class="comment">#               validation set. For example,</span></span><br><span class="line">    <span class="comment">#                   predictions = svmPredict(model, Xval);</span></span><br><span class="line">    <span class="comment">#               will return the predictions on the cross validation set.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#  Note: You can compute the prediction error using</span></span><br><span class="line">    <span class="comment">#        mean(double(predictions ~= yval))</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    C_vec = [<span class="number">0.01</span>, <span class="number">0.03</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">30</span>]</span><br><span class="line">    sigma_vec = [<span class="number">0.01</span>, <span class="number">0.03</span>, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">30</span>]</span><br><span class="line">    error_val = zeros((<span class="built_in">len</span>(C_vec), <span class="built_in">len</span>(sigma_vec)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(C_vec)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sigma_vec)):</span><br><span class="line">            <span class="keyword">def</span> <span class="title function_">mykernel</span>(<span class="params">x1, x2</span>): <span class="keyword">return</span> gaussianKernel(x1, x2, sigma_vec[j])</span><br><span class="line">            model = svm.SVC(C=C_vec[i], kernel=mykernel)  <span class="comment"># type:SVC</span></span><br><span class="line">            model.fit(X, y.ravel())</span><br><span class="line">            pred = model.predict(Xval)</span><br><span class="line">            <span class="comment"># compute the error</span></span><br><span class="line">            error_val[i, j] = mean(array(pred != yval))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># choose the best C and sigma</span></span><br><span class="line">    i, j = where(error_val == <span class="built_in">min</span>(error_val))</span><br><span class="line">    C = C_vec[i[<span class="number">0</span>]]</span><br><span class="line">    sigma = sigma_vec[j[<span class="number">0</span>]]</span><br><span class="line">    <span class="comment"># =========================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C, sigma</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readFile</span>(<span class="params">filename: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="comment"># READFILE reads a file and returns its entire contents</span></span><br><span class="line">    <span class="comment">#   file_contents = READFILE(filename) reads a file and returns its entire</span></span><br><span class="line">    <span class="comment">#   contents in file_contents</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load File</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> fid:</span><br><span class="line">        file_contents = fid.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> file_contents</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getVocabList</span>():</span><br><span class="line">    <span class="comment"># GETVOCABLIST reads the fixed vocabulary list in vocab.txt and returns a</span></span><br><span class="line">    <span class="comment"># cell array of the words</span></span><br><span class="line">    <span class="comment">#   vocabList = GETVOCABLIST() reads the fixed vocabulary list in vocab.txt</span></span><br><span class="line">    <span class="comment">#   and returns a cell array of the words in vocabList.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read the fixed vocabulary list</span></span><br><span class="line">    fid = <span class="built_in">open</span>(<span class="string">&#x27;vocab.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Store all dictionary words in cell array vocab&#123;&#125;</span></span><br><span class="line">    n = <span class="number">1899</span>  <span class="comment"># Total number of words in the dictionary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># For ease of implementation, we use a struct to map the strings =&gt;</span></span><br><span class="line">    <span class="comment"># integers</span></span><br><span class="line">    <span class="comment"># In practice, you&#x27;ll want to use some form of hashmap</span></span><br><span class="line">    vocabList = <span class="built_in">dict</span>()  <span class="comment"># type:<span class="built_in">dict</span></span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># Word Index (can ignore since it will be = i)</span></span><br><span class="line">        line = fid.readline()  <span class="comment"># type:<span class="built_in">str</span></span></span><br><span class="line">        ll = line.strip().split(<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">        <span class="comment"># Actual Word</span></span><br><span class="line">        vocabList[i] = ll[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    fid.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vocabList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">processEmail</span>(<span class="params">email_contents: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="comment"># PROCESSEMAIL preprocesses a the body of an email and</span></span><br><span class="line">    <span class="comment"># returns a list of word_indices</span></span><br><span class="line">    <span class="comment">#   word_indices = PROCESSEMAIL(email_contents) preprocesses</span></span><br><span class="line">    <span class="comment">#   the body of an email and returns a list of indices of the</span></span><br><span class="line">    <span class="comment">#   words contained in the email.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load Vocabulary</span></span><br><span class="line">    vocabList = getVocabList()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Init return value</span></span><br><span class="line">    word_indices = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ========================== Preprocess Email ===========================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the Headers ( \n\n and remove )</span></span><br><span class="line">    <span class="comment"># Uncomment the following lines if you are working with raw emails with the</span></span><br><span class="line">    <span class="comment"># full headers</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># hdrstart = strfind(email_contents, ([char(10) char(10)]));</span></span><br><span class="line">    <span class="comment"># email_contents = email_contents(hdrstart(1):end);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Lower case</span></span><br><span class="line">    email_contents = email_contents.lower()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Strip all HTML</span></span><br><span class="line">    <span class="comment"># Looks for any expression that starts with &lt; and ends with &gt; and replace</span></span><br><span class="line">    <span class="comment"># and does not have any &lt; or &gt; in the tag it with a space</span></span><br><span class="line">    email_contents = sub(<span class="string">&#x27;&lt;[^&lt;&gt;]+&gt;&#x27;</span>, <span class="string">&#x27; &#x27;</span>, email_contents)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Handle Numbers</span></span><br><span class="line">    <span class="comment"># Look for one or more characters between 0-9</span></span><br><span class="line">    email_contents = sub(<span class="string">&#x27;[0-9]+&#x27;</span>, <span class="string">&#x27;number&#x27;</span>, email_contents)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Handle URLS</span></span><br><span class="line">    <span class="comment"># Look for strings starting with http:// or https://</span></span><br><span class="line">    email_contents = sub(<span class="string">&#x27;(http|https)://[^\s]*&#x27;</span>, <span class="string">&#x27;httpaddr&#x27;</span>, email_contents)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Handle Email Addresses</span></span><br><span class="line">    <span class="comment"># Look for strings with @ in the middle</span></span><br><span class="line">    email_contents = sub(<span class="string">&#x27;[^\s]+@[^\s]+&#x27;</span>, <span class="string">&#x27;emailaddr&#x27;</span>, email_contents)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Handle $ sign</span></span><br><span class="line">    email_contents = sub(<span class="string">&#x27;[$]+&#x27;</span>, <span class="string">&#x27;dollar&#x27;</span>, email_contents)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ========================== Tokenize Email ===========================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Output the email to screen as well</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n==== Processed Email ====&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Process file</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Tokenize and also get rid of any punctuation</span></span><br><span class="line">    s = split(</span><br><span class="line">        <span class="string">r&#x27;,|\.|/|;|\&#x27;|`|\[|\]|&lt;|&gt;|\?|:|&quot;|\&#123;|\&#125;|\~|!|@|#|\$|#|\^|&amp;|\(|\)|-|=|\_|\+|\</span></span><br><span class="line"><span class="string">        ，|。|、|；|‘|’|【|】|·|！| |…|（|）&#x27;</span>, email_contents)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Remove any non alphanumeric characters</span></span><br><span class="line">    s = [it <span class="keyword">for</span> it <span class="keyword">in</span> s <span class="keyword">if</span> it.isalnum()]</span><br><span class="line"></span><br><span class="line">    stemmer = PorterStemmer()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># Stem the word</span></span><br><span class="line">        <span class="comment"># (the porterStemmer sometimes has issues, so we use a try catch block)</span></span><br><span class="line">        st = stemmer.stem(s[i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Look up the word in the dictionary and add to word_indices if</span></span><br><span class="line">        <span class="comment"># found</span></span><br><span class="line">        <span class="comment"># ====================== YOUR CODE HERE ======================</span></span><br><span class="line">        <span class="comment"># Instructions: Fill in this function to add the index of s to</span></span><br><span class="line">        <span class="comment">#               word_indices if it is in the vocabulary. At this point</span></span><br><span class="line">        <span class="comment">#               of the code, you have a stemmed word from the email in</span></span><br><span class="line">        <span class="comment">#               the variable str. You should look up str in the</span></span><br><span class="line">        <span class="comment">#               vocabulary list (vocabList). If a match exists, you</span></span><br><span class="line">        <span class="comment">#               should add the index of the word to the word_indices</span></span><br><span class="line">        <span class="comment">#               vector. Concretely, if str = &#x27;action&#x27;, then you should</span></span><br><span class="line">        <span class="comment">#               look up the vocabulary list to find where in vocabList</span></span><br><span class="line">        <span class="comment">#               &#x27;action&#x27; appears. For example, if vocabList&#123;18&#125; =</span></span><br><span class="line">        <span class="comment">#               &#x27;action&#x27;, then, you should add 18 to the word_indices</span></span><br><span class="line">        <span class="comment">#               vector (e.g., word_indices = [word_indices ; 18]; ).</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># Note: vocabList&#123;idx&#125; returns a the word with index idx in the</span></span><br><span class="line">        <span class="comment">#       vocabulary list.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># Note: You can use strcmp(str1, str2) to compare two strings (str1 and</span></span><br><span class="line">        <span class="comment">#       str2). It will return 1 only if the two strings are equivalent.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(vocabList)):</span><br><span class="line">            <span class="keyword">if</span> vocabList[i] == st:</span><br><span class="line">                word_indices.append(i+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># =============================================================</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Print to screen, ensuring that the output lines are not too long</span></span><br><span class="line">        <span class="keyword">if</span> (l + <span class="built_in">len</span>(st) + <span class="number">1</span>) &gt; <span class="number">78</span>:</span><br><span class="line">            l = <span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(st), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        l = l + <span class="built_in">len</span>(st) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print footer</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n\n=======================&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> word_indices</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">emailFeatures</span>(<span class="params">word_indices: <span class="built_in">list</span></span>)-&gt;ndarray:</span><br><span class="line">    <span class="comment"># EMAILFEATURES takes in a word_indices vector and produces a feature</span></span><br><span class="line">    <span class="comment"># vector from the word indices</span></span><br><span class="line">    <span class="comment">#   x = EMAILFEATURES(word_indices) takes in a word_indices vector and</span></span><br><span class="line">    <span class="comment">#   produces a feature vector from the word indices.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Total number of words in the dictionary</span></span><br><span class="line">    n = <span class="number">1899</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># You need to return the following variables correctly.</span></span><br><span class="line">    x = zeros((n, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ====================== YOUR CODE HERE ======================</span></span><br><span class="line">    <span class="comment"># Instructions: Fill in this function to return a feature vector for the</span></span><br><span class="line">    <span class="comment">#      given email (word_indices). To help make it easier to</span></span><br><span class="line">    <span class="comment">#      process the emails, we have have already pre-processed each</span></span><br><span class="line">    <span class="comment">#      email and converted each word in the email into an index in</span></span><br><span class="line">    <span class="comment">#      a fixed dictionary (of 1899 words). The variable</span></span><br><span class="line">    <span class="comment">#      word_indices contains the list of indices of the words</span></span><br><span class="line">    <span class="comment">#      which occur in one email.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      Concretely, if an email has the text:</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      The quick brown fox jumped over the lazy dog.</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      Then, the word_indices vector for this text might look</span></span><br><span class="line">    <span class="comment">#      like:</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      60  100   33   44   10     53  60  58   5</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      where, we have mapped each word onto a number, for example:</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      the   -- 60</span></span><br><span class="line">    <span class="comment">#      quick -- 100</span></span><br><span class="line">    <span class="comment">#      ...</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      (note: the above numbers are just an example and are not the</span></span><br><span class="line">    <span class="comment">#      actual mappings).</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      Your task is take one such word_indices vector and construct</span></span><br><span class="line">    <span class="comment">#      a binary feature vector that indicates whether a particular</span></span><br><span class="line">    <span class="comment">#      word occurs in the email. That is, x(i) = 1 when word i</span></span><br><span class="line">    <span class="comment">#      is present in the email. Concretely, if the word &#x27;the&#x27; (say,</span></span><br><span class="line">    <span class="comment">#      index 60) appears in the email, then x(60) = 1. The feature</span></span><br><span class="line">    <span class="comment">#      vector should look like:</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#      x = [ 0 0 0 0 1 0 0 0 ... 0 0 0 0 1 ... 0 0 0 1 0 ..];</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> word_indices:</span><br><span class="line">        x[i-<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># =========================================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E7%A8%8B/" rel="tag">吴恩达课程</a></li></ul></div><div class="post-nav"><a class="pre" href="/2018/12/15/wenda-week7/">机器学习作业第七周</a><a class="next" href="/2018/12/11/addfoldpy/">代码块自动添加折叠</a></div><script src="https://utteranc.es/client.js" repo="zhen8838/zhen8838.github.io" issue-term="url" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://zhen8838.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="关于"><img class="nofancybox" src="/img/avatar.png"/></a><p>A Believing Heart Is Your Magic</p><a class="info-icon" href="mailto:597323109@qq.com" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/zhen8838" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">体系结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/">工具使用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8E%A8%E7%90%86%E6%A1%86%E6%9E%B6/">推理框架</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E8%AF%91%E5%99%A8/">编译器</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/">边缘计算</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%AD%B9%E5%AD%A6/">运筹学</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/%E6%A0%91/" style="font-size: 15px;">树</a> <a href="/tags/C/" style="font-size: 15px;">C</a> <a href="/tags/Tensorflow/" style="font-size: 15px;">Tensorflow</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 15px;">树莓派</a> <a href="/tags/%E8%93%9D%E7%89%99/" style="font-size: 15px;">蓝牙</a> <a href="/tags/Matlab/" style="font-size: 15px;">Matlab</a> <a href="/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/" style="font-size: 15px;">遗传算法</a> <a href="/tags/SVM/" style="font-size: 15px;">SVM</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 15px;">链表</a> <a href="/tags/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">半监督学习</a> <a href="/tags/GAN/" style="font-size: 15px;">GAN</a> <a href="/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/" style="font-size: 15px;">概率论</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/%E9%A6%99%E6%A9%99%E6%B4%BE/" style="font-size: 15px;">香橙派</a> <a href="/tags/%E8%B8%A9%E5%9D%91%E7%BB%8F%E9%AA%8C/" style="font-size: 15px;">踩坑经验</a> <a href="/tags/LeetCode/" style="font-size: 15px;">LeetCode</a> <a href="/tags/Qt/" style="font-size: 15px;">Qt</a> <a href="/tags/%E5%A4%9A%E9%9D%A2%E4%BD%93%E6%A8%A1%E5%9E%8B/" style="font-size: 15px;">多面体模型</a> <a href="/tags/%E5%90%8E%E7%AB%AF%E4%BC%98%E5%8C%96/" style="font-size: 15px;">后端优化</a> <a href="/tags/Ampl/" style="font-size: 15px;">Ampl</a> <a href="/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 15px;">图像处理</a> <a href="/tags/K210/" style="font-size: 15px;">K210</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%B3%95/" style="font-size: 15px;">二分法</a> <a href="/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" style="font-size: 15px;">科学上网</a> <a href="/tags/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/" style="font-size: 15px;">损失函数</a> <a href="/tags/cmake/" style="font-size: 15px;">cmake</a> <a href="/tags/CPP/" style="font-size: 15px;">CPP</a> <a href="/tags/Conan/" style="font-size: 15px;">Conan</a> <a href="/tags/OrTools/" style="font-size: 15px;">OrTools</a> <a href="/tags/CSharp/" style="font-size: 15px;">CSharp</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA/" style="font-size: 15px;">数据增强</a> <a href="/tags/VAE/" style="font-size: 15px;">VAE</a> <a href="/tags/%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95/" style="font-size: 15px;">聚类方法</a> <a href="/tags/CostModel/" style="font-size: 15px;">CostModel</a> <a href="/tags/Vscode/" style="font-size: 15px;">Vscode</a> <a href="/tags/%E5%A3%B0%E9%9F%B3%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/" style="font-size: 15px;">声音信号处理</a> <a href="/tags/TVM/" style="font-size: 15px;">TVM</a> <a href="/tags/%E5%8A%A8%E6%80%81shape/" style="font-size: 15px;">动态shape</a> <a href="/tags/%E4%B8%AD%E7%AB%AF%E4%BC%98%E5%8C%96/" style="font-size: 15px;">中端优化</a> <a href="/tags/Equality-Saturation/" style="font-size: 15px;">Equality Saturation</a> <a href="/tags/stm32/" style="font-size: 15px;">stm32</a> <a href="/tags/Keras/" style="font-size: 15px;">Keras</a> <a href="/tags/Halide/" style="font-size: 15px;">Halide</a> <a href="/tags/DSL/" style="font-size: 15px;">DSL</a> <a href="/tags/%E5%A0%86%E6%A0%88/" style="font-size: 15px;">堆栈</a> <a href="/tags/%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/" style="font-size: 15px;">大语言模型</a> <a href="/tags/llama/" style="font-size: 15px;">llama</a> <a href="/tags/%E5%BD%92%E4%B8%80%E5%8C%96/" style="font-size: 15px;">归一化</a> <a href="/tags/Makefile/" style="font-size: 15px;">Makefile</a> <a href="/tags/%E5%85%83%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">元学习</a> <a href="/tags/%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B/" style="font-size: 15px;">模板元编程</a> <a href="/tags/mindspore/" style="font-size: 15px;">mindspore</a> <a href="/tags/LLM/" style="font-size: 15px;">LLM</a> <a href="/tags/tvm/" style="font-size: 15px;">tvm</a> <a href="/tags/mlir/" style="font-size: 15px;">mlir</a> <a href="/tags/%E6%80%A7%E8%83%BD%E5%BB%BA%E6%A8%A1/" style="font-size: 15px;">性能建模</a> <a href="/tags/mxnet/" style="font-size: 15px;">mxnet</a> <a href="/tags/Nand2Tetris/" style="font-size: 15px;">Nand2Tetris</a> <a href="/tags/ncnn/" style="font-size: 15px;">ncnn</a> <a href="/tags/Numpy/" style="font-size: 15px;">Numpy</a> <a href="/tags/PCB/" style="font-size: 15px;">PCB</a> <a href="/tags/%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1/" style="font-size: 15px;">姿态估计</a> <a href="/tags/%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/" style="font-size: 15px;">人脸检测</a> <a href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E9%87%8F%E5%8C%96/" style="font-size: 15px;">神经网络量化</a> <a href="/tags/Yolo/" style="font-size: 15px;">Yolo</a> <a href="/tags/Pytorch/" style="font-size: 15px;">Pytorch</a> <a href="/tags/NB-IOT/" style="font-size: 15px;">NB-IOT</a> <a href="/tags/Retinaface/" style="font-size: 15px;">Retinaface</a> <a href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" style="font-size: 15px;">目标检测</a> <a href="/tags/%E6%8C%87%E4%BB%A4%E9%9B%86/" style="font-size: 15px;">指令集</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 15px;">排序</a> <a href="/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/" style="font-size: 15px;">统计学习方法</a> <a href="/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/" style="font-size: 15px;">人脸识别</a> <a href="/tags/%E4%BC%98%E5%8C%96%E5%99%A8/" style="font-size: 15px;">优化器</a> <a href="/tags/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E7%A8%8B/" style="font-size: 15px;">吴恩达课程</a> <a href="/tags/WordCloud/" style="font-size: 15px;">WordCloud</a> <a href="/tags/Zhihu/" style="font-size: 15px;">Zhihu</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8/" style="font-size: 15px;">四轴飞行器</a> <a href="/tags/%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/" style="font-size: 15px;">资源汇总</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 15px;">分布式</a> <a href="/tags/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">无监督学习</a> <a href="/tags/Apple/" style="font-size: 15px;">Apple</a> <a href="/tags/Jittor/" style="font-size: 15px;">Jittor</a> <a href="/tags/Tiramisu/" style="font-size: 15px;">Tiramisu</a> <a href="/tags/Triton/" style="font-size: 15px;">Triton</a> <a href="/tags/vllm/" style="font-size: 15px;">vllm</a> <a href="/tags/%E7%AE%97%E5%AD%90/" style="font-size: 15px;">算子</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2025/10/15/jax-reshard/">探究jax reshard优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/09/26/flashattn/">Flash Attention记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/08/28/chimera/">Chimera: An Analytical Optimizing Framework for Effective Compute-intensive Operators Fusion</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/14/vllm/">推理框架调研</a></li><li class="post-list-item"><a class="post-list-link" href="/2025/02/04/distal/">DISTAL: The Distributed Tensor Algebra Compiler</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/12/04/triton-cpu-lesson-1/">triton-cpu初体验</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/11/07/mesh-matmul/">分布式存储架构下的矩阵乘与编译器</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/08/08/mlc-tutorial/">机器学习编译概念科普</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/08/08/benchmark-notes/">benchmark的经验与技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/06/14/ampl-learn/">Ampl学习</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2025 <a href="/." rel="nofollow">Zheng's Notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="复制成功！"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>